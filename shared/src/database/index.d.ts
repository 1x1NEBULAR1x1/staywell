
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model Apartment
 * 
 */
export type Apartment = $Result.DefaultSelection<Prisma.$ApartmentPayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model Amenity
 * 
 */
export type Amenity = $Result.DefaultSelection<Prisma.$AmenityPayload>
/**
 * Model ApartmentAmenity
 * 
 */
export type ApartmentAmenity = $Result.DefaultSelection<Prisma.$ApartmentAmenityPayload>
/**
 * Model ApartmentImage
 * 
 */
export type ApartmentImage = $Result.DefaultSelection<Prisma.$ApartmentImagePayload>
/**
 * Model BedType
 * 
 */
export type BedType = $Result.DefaultSelection<Prisma.$BedTypePayload>
/**
 * Model ApartmentBed
 * 
 */
export type ApartmentBed = $Result.DefaultSelection<Prisma.$ApartmentBedPayload>
/**
 * Model BookingVariant
 * 
 */
export type BookingVariant = $Result.DefaultSelection<Prisma.$BookingVariantPayload>
/**
 * Model Reservation
 * 
 */
export type Reservation = $Result.DefaultSelection<Prisma.$ReservationPayload>
/**
 * Model Booking
 * 
 */
export type Booking = $Result.DefaultSelection<Prisma.$BookingPayload>
/**
 * Model AdditionalOption
 * 
 */
export type AdditionalOption = $Result.DefaultSelection<Prisma.$AdditionalOptionPayload>
/**
 * Model BookingAdditionalOption
 * 
 */
export type BookingAdditionalOption = $Result.DefaultSelection<Prisma.$BookingAdditionalOptionPayload>
/**
 * Model BookingEvent
 * 
 */
export type BookingEvent = $Result.DefaultSelection<Prisma.$BookingEventPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model TransferDetail
 * 
 */
export type TransferDetail = $Result.DefaultSelection<Prisma.$TransferDetailPayload>
/**
 * Model CardDetail
 * 
 */
export type CardDetail = $Result.DefaultSelection<Prisma.$CardDetailPayload>
/**
 * Model Event
 * 
 */
export type Event = $Result.DefaultSelection<Prisma.$EventPayload>
/**
 * Model EventImage
 * 
 */
export type EventImage = $Result.DefaultSelection<Prisma.$EventImagePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const NotificationType: {
  BOOKING: 'BOOKING',
  RESERVATION: 'RESERVATION',
  MESSAGE: 'MESSAGE',
  ERROR: 'ERROR',
  WARNING: 'WARNING'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const NotificationAction: {
  UPDATE: 'UPDATE',
  NEW: 'NEW'
};

export type NotificationAction = (typeof NotificationAction)[keyof typeof NotificationAction]


export const ApartmentType: {
  BUDGET: 'BUDGET',
  STANDARD: 'STANDARD',
  EXCLUSIVE: 'EXCLUSIVE',
  SUPERIOR: 'SUPERIOR',
  LUXURY: 'LUXURY'
};

export type ApartmentType = (typeof ApartmentType)[keyof typeof ApartmentType]


export const BookingStatus: {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type BookingStatus = (typeof BookingStatus)[keyof typeof BookingStatus]


export const PaymentMethod: {
  CASH: 'CASH',
  CARD: 'CARD',
  TRANSFER: 'TRANSFER'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const TransactionStatus: {
  PENDING: 'PENDING',
  SUCCESS: 'SUCCESS',
  CANCELED: 'CANCELED',
  FAILED: 'FAILED'
};

export type TransactionStatus = (typeof TransactionStatus)[keyof typeof TransactionStatus]


export const TransactionType: {
  DEPOSIT: 'DEPOSIT',
  PAYMENT: 'PAYMENT',
  REFUND: 'REFUND',
  FINE: 'FINE'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]


export const Role: {
  USER: 'USER',
  ADMIN: 'ADMIN',
  GUIDE: 'GUIDE'
};

export type Role = (typeof Role)[keyof typeof Role]

}

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type NotificationAction = $Enums.NotificationAction

export const NotificationAction: typeof $Enums.NotificationAction

export type ApartmentType = $Enums.ApartmentType

export const ApartmentType: typeof $Enums.ApartmentType

export type BookingStatus = $Enums.BookingStatus

export const BookingStatus: typeof $Enums.BookingStatus

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type TransactionStatus = $Enums.TransactionStatus

export const TransactionStatus: typeof $Enums.TransactionStatus

export type TransactionType = $Enums.TransactionType

export const TransactionType: typeof $Enums.TransactionType

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.apartment`: Exposes CRUD operations for the **Apartment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Apartments
    * const apartments = await prisma.apartment.findMany()
    * ```
    */
  get apartment(): Prisma.ApartmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.amenity`: Exposes CRUD operations for the **Amenity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Amenities
    * const amenities = await prisma.amenity.findMany()
    * ```
    */
  get amenity(): Prisma.AmenityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.apartmentAmenity`: Exposes CRUD operations for the **ApartmentAmenity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApartmentAmenities
    * const apartmentAmenities = await prisma.apartmentAmenity.findMany()
    * ```
    */
  get apartmentAmenity(): Prisma.ApartmentAmenityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.apartmentImage`: Exposes CRUD operations for the **ApartmentImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApartmentImages
    * const apartmentImages = await prisma.apartmentImage.findMany()
    * ```
    */
  get apartmentImage(): Prisma.ApartmentImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bedType`: Exposes CRUD operations for the **BedType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BedTypes
    * const bedTypes = await prisma.bedType.findMany()
    * ```
    */
  get bedType(): Prisma.BedTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.apartmentBed`: Exposes CRUD operations for the **ApartmentBed** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApartmentBeds
    * const apartmentBeds = await prisma.apartmentBed.findMany()
    * ```
    */
  get apartmentBed(): Prisma.ApartmentBedDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookingVariant`: Exposes CRUD operations for the **BookingVariant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookingVariants
    * const bookingVariants = await prisma.bookingVariant.findMany()
    * ```
    */
  get bookingVariant(): Prisma.BookingVariantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reservation`: Exposes CRUD operations for the **Reservation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reservations
    * const reservations = await prisma.reservation.findMany()
    * ```
    */
  get reservation(): Prisma.ReservationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.booking`: Exposes CRUD operations for the **Booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.booking.findMany()
    * ```
    */
  get booking(): Prisma.BookingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.additionalOption`: Exposes CRUD operations for the **AdditionalOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdditionalOptions
    * const additionalOptions = await prisma.additionalOption.findMany()
    * ```
    */
  get additionalOption(): Prisma.AdditionalOptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookingAdditionalOption`: Exposes CRUD operations for the **BookingAdditionalOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookingAdditionalOptions
    * const bookingAdditionalOptions = await prisma.bookingAdditionalOption.findMany()
    * ```
    */
  get bookingAdditionalOption(): Prisma.BookingAdditionalOptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookingEvent`: Exposes CRUD operations for the **BookingEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookingEvents
    * const bookingEvents = await prisma.bookingEvent.findMany()
    * ```
    */
  get bookingEvent(): Prisma.BookingEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transferDetail`: Exposes CRUD operations for the **TransferDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransferDetails
    * const transferDetails = await prisma.transferDetail.findMany()
    * ```
    */
  get transferDetail(): Prisma.TransferDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cardDetail`: Exposes CRUD operations for the **CardDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CardDetails
    * const cardDetails = await prisma.cardDetail.findMany()
    * ```
    */
  get cardDetail(): Prisma.CardDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eventImage`: Exposes CRUD operations for the **EventImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventImages
    * const eventImages = await prisma.eventImage.findMany()
    * ```
    */
  get eventImage(): Prisma.EventImageDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.13.0
   * Query Engine version: 361e86d0ea4987e9f53a565309b3eed797a6bcbd
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Notification: 'Notification',
    Message: 'Message',
    Apartment: 'Apartment',
    Review: 'Review',
    Amenity: 'Amenity',
    ApartmentAmenity: 'ApartmentAmenity',
    ApartmentImage: 'ApartmentImage',
    BedType: 'BedType',
    ApartmentBed: 'ApartmentBed',
    BookingVariant: 'BookingVariant',
    Reservation: 'Reservation',
    Booking: 'Booking',
    AdditionalOption: 'AdditionalOption',
    BookingAdditionalOption: 'BookingAdditionalOption',
    BookingEvent: 'BookingEvent',
    Transaction: 'Transaction',
    TransferDetail: 'TransferDetail',
    CardDetail: 'CardDetail',
    Event: 'Event',
    EventImage: 'EventImage'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "notification" | "message" | "apartment" | "review" | "amenity" | "apartmentAmenity" | "apartmentImage" | "bedType" | "apartmentBed" | "bookingVariant" | "reservation" | "booking" | "additionalOption" | "bookingAdditionalOption" | "bookingEvent" | "transaction" | "transferDetail" | "cardDetail" | "event" | "eventImage"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      Apartment: {
        payload: Prisma.$ApartmentPayload<ExtArgs>
        fields: Prisma.ApartmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApartmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApartmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApartmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApartmentPayload>
          }
          findFirst: {
            args: Prisma.ApartmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApartmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApartmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApartmentPayload>
          }
          findMany: {
            args: Prisma.ApartmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApartmentPayload>[]
          }
          create: {
            args: Prisma.ApartmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApartmentPayload>
          }
          createMany: {
            args: Prisma.ApartmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApartmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApartmentPayload>[]
          }
          delete: {
            args: Prisma.ApartmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApartmentPayload>
          }
          update: {
            args: Prisma.ApartmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApartmentPayload>
          }
          deleteMany: {
            args: Prisma.ApartmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApartmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApartmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApartmentPayload>[]
          }
          upsert: {
            args: Prisma.ApartmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApartmentPayload>
          }
          aggregate: {
            args: Prisma.ApartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApartment>
          }
          groupBy: {
            args: Prisma.ApartmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApartmentCountArgs<ExtArgs>
            result: $Utils.Optional<ApartmentCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      Amenity: {
        payload: Prisma.$AmenityPayload<ExtArgs>
        fields: Prisma.AmenityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AmenityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AmenityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          findFirst: {
            args: Prisma.AmenityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AmenityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          findMany: {
            args: Prisma.AmenityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>[]
          }
          create: {
            args: Prisma.AmenityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          createMany: {
            args: Prisma.AmenityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AmenityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>[]
          }
          delete: {
            args: Prisma.AmenityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          update: {
            args: Prisma.AmenityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          deleteMany: {
            args: Prisma.AmenityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AmenityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AmenityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>[]
          }
          upsert: {
            args: Prisma.AmenityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          aggregate: {
            args: Prisma.AmenityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAmenity>
          }
          groupBy: {
            args: Prisma.AmenityGroupByArgs<ExtArgs>
            result: $Utils.Optional<AmenityGroupByOutputType>[]
          }
          count: {
            args: Prisma.AmenityCountArgs<ExtArgs>
            result: $Utils.Optional<AmenityCountAggregateOutputType> | number
          }
        }
      }
      ApartmentAmenity: {
        payload: Prisma.$ApartmentAmenityPayload<ExtArgs>
        fields: Prisma.ApartmentAmenityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApartmentAmenityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApartmentAmenityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApartmentAmenityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApartmentAmenityPayload>
          }
          findFirst: {
            args: Prisma.ApartmentAmenityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApartmentAmenityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApartmentAmenityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApartmentAmenityPayload>
          }
          findMany: {
            args: Prisma.ApartmentAmenityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApartmentAmenityPayload>[]
          }
          create: {
            args: Prisma.ApartmentAmenityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApartmentAmenityPayload>
          }
          createMany: {
            args: Prisma.ApartmentAmenityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApartmentAmenityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApartmentAmenityPayload>[]
          }
          delete: {
            args: Prisma.ApartmentAmenityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApartmentAmenityPayload>
          }
          update: {
            args: Prisma.ApartmentAmenityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApartmentAmenityPayload>
          }
          deleteMany: {
            args: Prisma.ApartmentAmenityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApartmentAmenityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApartmentAmenityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApartmentAmenityPayload>[]
          }
          upsert: {
            args: Prisma.ApartmentAmenityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApartmentAmenityPayload>
          }
          aggregate: {
            args: Prisma.ApartmentAmenityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApartmentAmenity>
          }
          groupBy: {
            args: Prisma.ApartmentAmenityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApartmentAmenityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApartmentAmenityCountArgs<ExtArgs>
            result: $Utils.Optional<ApartmentAmenityCountAggregateOutputType> | number
          }
        }
      }
      ApartmentImage: {
        payload: Prisma.$ApartmentImagePayload<ExtArgs>
        fields: Prisma.ApartmentImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApartmentImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApartmentImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApartmentImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApartmentImagePayload>
          }
          findFirst: {
            args: Prisma.ApartmentImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApartmentImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApartmentImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApartmentImagePayload>
          }
          findMany: {
            args: Prisma.ApartmentImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApartmentImagePayload>[]
          }
          create: {
            args: Prisma.ApartmentImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApartmentImagePayload>
          }
          createMany: {
            args: Prisma.ApartmentImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApartmentImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApartmentImagePayload>[]
          }
          delete: {
            args: Prisma.ApartmentImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApartmentImagePayload>
          }
          update: {
            args: Prisma.ApartmentImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApartmentImagePayload>
          }
          deleteMany: {
            args: Prisma.ApartmentImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApartmentImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApartmentImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApartmentImagePayload>[]
          }
          upsert: {
            args: Prisma.ApartmentImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApartmentImagePayload>
          }
          aggregate: {
            args: Prisma.ApartmentImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApartmentImage>
          }
          groupBy: {
            args: Prisma.ApartmentImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApartmentImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApartmentImageCountArgs<ExtArgs>
            result: $Utils.Optional<ApartmentImageCountAggregateOutputType> | number
          }
        }
      }
      BedType: {
        payload: Prisma.$BedTypePayload<ExtArgs>
        fields: Prisma.BedTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BedTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BedTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedTypePayload>
          }
          findFirst: {
            args: Prisma.BedTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BedTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedTypePayload>
          }
          findMany: {
            args: Prisma.BedTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedTypePayload>[]
          }
          create: {
            args: Prisma.BedTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedTypePayload>
          }
          createMany: {
            args: Prisma.BedTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BedTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedTypePayload>[]
          }
          delete: {
            args: Prisma.BedTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedTypePayload>
          }
          update: {
            args: Prisma.BedTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedTypePayload>
          }
          deleteMany: {
            args: Prisma.BedTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BedTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BedTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedTypePayload>[]
          }
          upsert: {
            args: Prisma.BedTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedTypePayload>
          }
          aggregate: {
            args: Prisma.BedTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBedType>
          }
          groupBy: {
            args: Prisma.BedTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<BedTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.BedTypeCountArgs<ExtArgs>
            result: $Utils.Optional<BedTypeCountAggregateOutputType> | number
          }
        }
      }
      ApartmentBed: {
        payload: Prisma.$ApartmentBedPayload<ExtArgs>
        fields: Prisma.ApartmentBedFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApartmentBedFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApartmentBedPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApartmentBedFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApartmentBedPayload>
          }
          findFirst: {
            args: Prisma.ApartmentBedFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApartmentBedPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApartmentBedFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApartmentBedPayload>
          }
          findMany: {
            args: Prisma.ApartmentBedFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApartmentBedPayload>[]
          }
          create: {
            args: Prisma.ApartmentBedCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApartmentBedPayload>
          }
          createMany: {
            args: Prisma.ApartmentBedCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApartmentBedCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApartmentBedPayload>[]
          }
          delete: {
            args: Prisma.ApartmentBedDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApartmentBedPayload>
          }
          update: {
            args: Prisma.ApartmentBedUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApartmentBedPayload>
          }
          deleteMany: {
            args: Prisma.ApartmentBedDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApartmentBedUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApartmentBedUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApartmentBedPayload>[]
          }
          upsert: {
            args: Prisma.ApartmentBedUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApartmentBedPayload>
          }
          aggregate: {
            args: Prisma.ApartmentBedAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApartmentBed>
          }
          groupBy: {
            args: Prisma.ApartmentBedGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApartmentBedGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApartmentBedCountArgs<ExtArgs>
            result: $Utils.Optional<ApartmentBedCountAggregateOutputType> | number
          }
        }
      }
      BookingVariant: {
        payload: Prisma.$BookingVariantPayload<ExtArgs>
        fields: Prisma.BookingVariantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingVariantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingVariantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingVariantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingVariantPayload>
          }
          findFirst: {
            args: Prisma.BookingVariantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingVariantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingVariantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingVariantPayload>
          }
          findMany: {
            args: Prisma.BookingVariantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingVariantPayload>[]
          }
          create: {
            args: Prisma.BookingVariantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingVariantPayload>
          }
          createMany: {
            args: Prisma.BookingVariantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingVariantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingVariantPayload>[]
          }
          delete: {
            args: Prisma.BookingVariantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingVariantPayload>
          }
          update: {
            args: Prisma.BookingVariantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingVariantPayload>
          }
          deleteMany: {
            args: Prisma.BookingVariantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingVariantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookingVariantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingVariantPayload>[]
          }
          upsert: {
            args: Prisma.BookingVariantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingVariantPayload>
          }
          aggregate: {
            args: Prisma.BookingVariantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookingVariant>
          }
          groupBy: {
            args: Prisma.BookingVariantGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingVariantGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingVariantCountArgs<ExtArgs>
            result: $Utils.Optional<BookingVariantCountAggregateOutputType> | number
          }
        }
      }
      Reservation: {
        payload: Prisma.$ReservationPayload<ExtArgs>
        fields: Prisma.ReservationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReservationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReservationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          findFirst: {
            args: Prisma.ReservationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReservationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          findMany: {
            args: Prisma.ReservationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>[]
          }
          create: {
            args: Prisma.ReservationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          createMany: {
            args: Prisma.ReservationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReservationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>[]
          }
          delete: {
            args: Prisma.ReservationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          update: {
            args: Prisma.ReservationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          deleteMany: {
            args: Prisma.ReservationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReservationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReservationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>[]
          }
          upsert: {
            args: Prisma.ReservationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          aggregate: {
            args: Prisma.ReservationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReservation>
          }
          groupBy: {
            args: Prisma.ReservationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReservationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReservationCountArgs<ExtArgs>
            result: $Utils.Optional<ReservationCountAggregateOutputType> | number
          }
        }
      }
      Booking: {
        payload: Prisma.$BookingPayload<ExtArgs>
        fields: Prisma.BookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findFirst: {
            args: Prisma.BookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findMany: {
            args: Prisma.BookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          create: {
            args: Prisma.BookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          createMany: {
            args: Prisma.BookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          delete: {
            args: Prisma.BookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          update: {
            args: Prisma.BookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          deleteMany: {
            args: Prisma.BookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          upsert: {
            args: Prisma.BookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          aggregate: {
            args: Prisma.BookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooking>
          }
          groupBy: {
            args: Prisma.BookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingCountArgs<ExtArgs>
            result: $Utils.Optional<BookingCountAggregateOutputType> | number
          }
        }
      }
      AdditionalOption: {
        payload: Prisma.$AdditionalOptionPayload<ExtArgs>
        fields: Prisma.AdditionalOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdditionalOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdditionalOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdditionalOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdditionalOptionPayload>
          }
          findFirst: {
            args: Prisma.AdditionalOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdditionalOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdditionalOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdditionalOptionPayload>
          }
          findMany: {
            args: Prisma.AdditionalOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdditionalOptionPayload>[]
          }
          create: {
            args: Prisma.AdditionalOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdditionalOptionPayload>
          }
          createMany: {
            args: Prisma.AdditionalOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdditionalOptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdditionalOptionPayload>[]
          }
          delete: {
            args: Prisma.AdditionalOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdditionalOptionPayload>
          }
          update: {
            args: Prisma.AdditionalOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdditionalOptionPayload>
          }
          deleteMany: {
            args: Prisma.AdditionalOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdditionalOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdditionalOptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdditionalOptionPayload>[]
          }
          upsert: {
            args: Prisma.AdditionalOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdditionalOptionPayload>
          }
          aggregate: {
            args: Prisma.AdditionalOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdditionalOption>
          }
          groupBy: {
            args: Prisma.AdditionalOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdditionalOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdditionalOptionCountArgs<ExtArgs>
            result: $Utils.Optional<AdditionalOptionCountAggregateOutputType> | number
          }
        }
      }
      BookingAdditionalOption: {
        payload: Prisma.$BookingAdditionalOptionPayload<ExtArgs>
        fields: Prisma.BookingAdditionalOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingAdditionalOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingAdditionalOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingAdditionalOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingAdditionalOptionPayload>
          }
          findFirst: {
            args: Prisma.BookingAdditionalOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingAdditionalOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingAdditionalOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingAdditionalOptionPayload>
          }
          findMany: {
            args: Prisma.BookingAdditionalOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingAdditionalOptionPayload>[]
          }
          create: {
            args: Prisma.BookingAdditionalOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingAdditionalOptionPayload>
          }
          createMany: {
            args: Prisma.BookingAdditionalOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingAdditionalOptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingAdditionalOptionPayload>[]
          }
          delete: {
            args: Prisma.BookingAdditionalOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingAdditionalOptionPayload>
          }
          update: {
            args: Prisma.BookingAdditionalOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingAdditionalOptionPayload>
          }
          deleteMany: {
            args: Prisma.BookingAdditionalOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingAdditionalOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookingAdditionalOptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingAdditionalOptionPayload>[]
          }
          upsert: {
            args: Prisma.BookingAdditionalOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingAdditionalOptionPayload>
          }
          aggregate: {
            args: Prisma.BookingAdditionalOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookingAdditionalOption>
          }
          groupBy: {
            args: Prisma.BookingAdditionalOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingAdditionalOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingAdditionalOptionCountArgs<ExtArgs>
            result: $Utils.Optional<BookingAdditionalOptionCountAggregateOutputType> | number
          }
        }
      }
      BookingEvent: {
        payload: Prisma.$BookingEventPayload<ExtArgs>
        fields: Prisma.BookingEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingEventPayload>
          }
          findFirst: {
            args: Prisma.BookingEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingEventPayload>
          }
          findMany: {
            args: Prisma.BookingEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingEventPayload>[]
          }
          create: {
            args: Prisma.BookingEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingEventPayload>
          }
          createMany: {
            args: Prisma.BookingEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingEventPayload>[]
          }
          delete: {
            args: Prisma.BookingEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingEventPayload>
          }
          update: {
            args: Prisma.BookingEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingEventPayload>
          }
          deleteMany: {
            args: Prisma.BookingEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookingEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingEventPayload>[]
          }
          upsert: {
            args: Prisma.BookingEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingEventPayload>
          }
          aggregate: {
            args: Prisma.BookingEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookingEvent>
          }
          groupBy: {
            args: Prisma.BookingEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingEventCountArgs<ExtArgs>
            result: $Utils.Optional<BookingEventCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      TransferDetail: {
        payload: Prisma.$TransferDetailPayload<ExtArgs>
        fields: Prisma.TransferDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransferDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransferDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferDetailPayload>
          }
          findFirst: {
            args: Prisma.TransferDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransferDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferDetailPayload>
          }
          findMany: {
            args: Prisma.TransferDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferDetailPayload>[]
          }
          create: {
            args: Prisma.TransferDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferDetailPayload>
          }
          createMany: {
            args: Prisma.TransferDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransferDetailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferDetailPayload>[]
          }
          delete: {
            args: Prisma.TransferDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferDetailPayload>
          }
          update: {
            args: Prisma.TransferDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferDetailPayload>
          }
          deleteMany: {
            args: Prisma.TransferDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransferDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransferDetailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferDetailPayload>[]
          }
          upsert: {
            args: Prisma.TransferDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferDetailPayload>
          }
          aggregate: {
            args: Prisma.TransferDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransferDetail>
          }
          groupBy: {
            args: Prisma.TransferDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransferDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransferDetailCountArgs<ExtArgs>
            result: $Utils.Optional<TransferDetailCountAggregateOutputType> | number
          }
        }
      }
      CardDetail: {
        payload: Prisma.$CardDetailPayload<ExtArgs>
        fields: Prisma.CardDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CardDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CardDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardDetailPayload>
          }
          findFirst: {
            args: Prisma.CardDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CardDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardDetailPayload>
          }
          findMany: {
            args: Prisma.CardDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardDetailPayload>[]
          }
          create: {
            args: Prisma.CardDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardDetailPayload>
          }
          createMany: {
            args: Prisma.CardDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CardDetailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardDetailPayload>[]
          }
          delete: {
            args: Prisma.CardDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardDetailPayload>
          }
          update: {
            args: Prisma.CardDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardDetailPayload>
          }
          deleteMany: {
            args: Prisma.CardDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CardDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CardDetailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardDetailPayload>[]
          }
          upsert: {
            args: Prisma.CardDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardDetailPayload>
          }
          aggregate: {
            args: Prisma.CardDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCardDetail>
          }
          groupBy: {
            args: Prisma.CardDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<CardDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.CardDetailCountArgs<ExtArgs>
            result: $Utils.Optional<CardDetailCountAggregateOutputType> | number
          }
        }
      }
      Event: {
        payload: Prisma.$EventPayload<ExtArgs>
        fields: Prisma.EventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findFirst: {
            args: Prisma.EventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findMany: {
            args: Prisma.EventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          create: {
            args: Prisma.EventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          createMany: {
            args: Prisma.EventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          delete: {
            args: Prisma.EventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          update: {
            args: Prisma.EventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          deleteMany: {
            args: Prisma.EventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          upsert: {
            args: Prisma.EventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.EventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventCountArgs<ExtArgs>
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
      EventImage: {
        payload: Prisma.$EventImagePayload<ExtArgs>
        fields: Prisma.EventImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventImagePayload>
          }
          findFirst: {
            args: Prisma.EventImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventImagePayload>
          }
          findMany: {
            args: Prisma.EventImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventImagePayload>[]
          }
          create: {
            args: Prisma.EventImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventImagePayload>
          }
          createMany: {
            args: Prisma.EventImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventImagePayload>[]
          }
          delete: {
            args: Prisma.EventImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventImagePayload>
          }
          update: {
            args: Prisma.EventImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventImagePayload>
          }
          deleteMany: {
            args: Prisma.EventImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventImagePayload>[]
          }
          upsert: {
            args: Prisma.EventImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventImagePayload>
          }
          aggregate: {
            args: Prisma.EventImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventImage>
          }
          groupBy: {
            args: Prisma.EventImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventImageCountArgs<ExtArgs>
            result: $Utils.Optional<EventImageCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    notification?: NotificationOmit
    message?: MessageOmit
    apartment?: ApartmentOmit
    review?: ReviewOmit
    amenity?: AmenityOmit
    apartmentAmenity?: ApartmentAmenityOmit
    apartmentImage?: ApartmentImageOmit
    bedType?: BedTypeOmit
    apartmentBed?: ApartmentBedOmit
    bookingVariant?: BookingVariantOmit
    reservation?: ReservationOmit
    booking?: BookingOmit
    additionalOption?: AdditionalOptionOmit
    bookingAdditionalOption?: BookingAdditionalOptionOmit
    bookingEvent?: BookingEventOmit
    transaction?: TransactionOmit
    transferDetail?: TransferDetailOmit
    cardDetail?: CardDetailOmit
    event?: EventOmit
    eventImage?: EventImageOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    reservations: number
    events: number
    bookings: number
    transactions: number
    card_details: number
    transfer_details: number
    reviews: number
    sent_messages: number
    notifications: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reservations?: boolean | UserCountOutputTypeCountReservationsArgs
    events?: boolean | UserCountOutputTypeCountEventsArgs
    bookings?: boolean | UserCountOutputTypeCountBookingsArgs
    transactions?: boolean | UserCountOutputTypeCountTransactionsArgs
    card_details?: boolean | UserCountOutputTypeCountCard_detailsArgs
    transfer_details?: boolean | UserCountOutputTypeCountTransfer_detailsArgs
    reviews?: boolean | UserCountOutputTypeCountReviewsArgs
    sent_messages?: boolean | UserCountOutputTypeCountSent_messagesArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCard_detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CardDetailWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransfer_detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferDetailWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSent_messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type MessageCountOutputType
   */

  export type MessageCountOutputType = {
    replaced_by: number
  }

  export type MessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replaced_by?: boolean | MessageCountOutputTypeCountReplaced_byArgs
  }

  // Custom InputTypes
  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCountOutputType
     */
    select?: MessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountReplaced_byArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Count Type ApartmentCountOutputType
   */

  export type ApartmentCountOutputType = {
    images: number
    apartment_beds: number
    apartment_amenities: number
    reservations: number
    booking_variants: number
    reviews: number
  }

  export type ApartmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | ApartmentCountOutputTypeCountImagesArgs
    apartment_beds?: boolean | ApartmentCountOutputTypeCountApartment_bedsArgs
    apartment_amenities?: boolean | ApartmentCountOutputTypeCountApartment_amenitiesArgs
    reservations?: boolean | ApartmentCountOutputTypeCountReservationsArgs
    booking_variants?: boolean | ApartmentCountOutputTypeCountBooking_variantsArgs
    reviews?: boolean | ApartmentCountOutputTypeCountReviewsArgs
  }

  // Custom InputTypes
  /**
   * ApartmentCountOutputType without action
   */
  export type ApartmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApartmentCountOutputType
     */
    select?: ApartmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ApartmentCountOutputType without action
   */
  export type ApartmentCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApartmentImageWhereInput
  }

  /**
   * ApartmentCountOutputType without action
   */
  export type ApartmentCountOutputTypeCountApartment_bedsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApartmentBedWhereInput
  }

  /**
   * ApartmentCountOutputType without action
   */
  export type ApartmentCountOutputTypeCountApartment_amenitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApartmentAmenityWhereInput
  }

  /**
   * ApartmentCountOutputType without action
   */
  export type ApartmentCountOutputTypeCountReservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
  }

  /**
   * ApartmentCountOutputType without action
   */
  export type ApartmentCountOutputTypeCountBooking_variantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingVariantWhereInput
  }

  /**
   * ApartmentCountOutputType without action
   */
  export type ApartmentCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }


  /**
   * Count Type AmenityCountOutputType
   */

  export type AmenityCountOutputType = {
    apartment_amenities: number
  }

  export type AmenityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apartment_amenities?: boolean | AmenityCountOutputTypeCountApartment_amenitiesArgs
  }

  // Custom InputTypes
  /**
   * AmenityCountOutputType without action
   */
  export type AmenityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenityCountOutputType
     */
    select?: AmenityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AmenityCountOutputType without action
   */
  export type AmenityCountOutputTypeCountApartment_amenitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApartmentAmenityWhereInput
  }


  /**
   * Count Type BedTypeCountOutputType
   */

  export type BedTypeCountOutputType = {
    apartment_beds: number
  }

  export type BedTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apartment_beds?: boolean | BedTypeCountOutputTypeCountApartment_bedsArgs
  }

  // Custom InputTypes
  /**
   * BedTypeCountOutputType without action
   */
  export type BedTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedTypeCountOutputType
     */
    select?: BedTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BedTypeCountOutputType without action
   */
  export type BedTypeCountOutputTypeCountApartment_bedsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApartmentBedWhereInput
  }


  /**
   * Count Type BookingVariantCountOutputType
   */

  export type BookingVariantCountOutputType = {
    bookings: number
  }

  export type BookingVariantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | BookingVariantCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes
  /**
   * BookingVariantCountOutputType without action
   */
  export type BookingVariantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingVariantCountOutputType
     */
    select?: BookingVariantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BookingVariantCountOutputType without action
   */
  export type BookingVariantCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }


  /**
   * Count Type BookingCountOutputType
   */

  export type BookingCountOutputType = {
    booking_events: number
    booking_additional_options: number
    reviews: number
    messages: number
  }

  export type BookingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking_events?: boolean | BookingCountOutputTypeCountBooking_eventsArgs
    booking_additional_options?: boolean | BookingCountOutputTypeCountBooking_additional_optionsArgs
    reviews?: boolean | BookingCountOutputTypeCountReviewsArgs
    messages?: boolean | BookingCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCountOutputType
     */
    select?: BookingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountBooking_eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingEventWhereInput
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountBooking_additional_optionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingAdditionalOptionWhereInput
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Count Type AdditionalOptionCountOutputType
   */

  export type AdditionalOptionCountOutputType = {
    booking_additional_options: number
  }

  export type AdditionalOptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking_additional_options?: boolean | AdditionalOptionCountOutputTypeCountBooking_additional_optionsArgs
  }

  // Custom InputTypes
  /**
   * AdditionalOptionCountOutputType without action
   */
  export type AdditionalOptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalOptionCountOutputType
     */
    select?: AdditionalOptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdditionalOptionCountOutputType without action
   */
  export type AdditionalOptionCountOutputTypeCountBooking_additional_optionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingAdditionalOptionWhereInput
  }


  /**
   * Count Type TransferDetailCountOutputType
   */

  export type TransferDetailCountOutputType = {
    transactions: number
  }

  export type TransferDetailCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | TransferDetailCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * TransferDetailCountOutputType without action
   */
  export type TransferDetailCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferDetailCountOutputType
     */
    select?: TransferDetailCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TransferDetailCountOutputType without action
   */
  export type TransferDetailCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type CardDetailCountOutputType
   */

  export type CardDetailCountOutputType = {
    transactions: number
  }

  export type CardDetailCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | CardDetailCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * CardDetailCountOutputType without action
   */
  export type CardDetailCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardDetailCountOutputType
     */
    select?: CardDetailCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CardDetailCountOutputType without action
   */
  export type CardDetailCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type EventCountOutputType
   */

  export type EventCountOutputType = {
    images: number
    booking_events: number
  }

  export type EventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | EventCountOutputTypeCountImagesArgs
    booking_events?: boolean | EventCountOutputTypeCountBooking_eventsArgs
  }

  // Custom InputTypes
  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCountOutputType
     */
    select?: EventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventImageWhereInput
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountBooking_eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingEventWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password_hash: string | null
    image: string | null
    first_name: string | null
    last_name: string | null
    phone_number: string | null
    date_of_birth: Date | null
    is_active: boolean | null
    email_verified: boolean | null
    phone_verified: boolean | null
    role: $Enums.Role | null
    created: Date | null
    updated: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password_hash: string | null
    image: string | null
    first_name: string | null
    last_name: string | null
    phone_number: string | null
    date_of_birth: Date | null
    is_active: boolean | null
    email_verified: boolean | null
    phone_verified: boolean | null
    role: $Enums.Role | null
    created: Date | null
    updated: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password_hash: number
    image: number
    first_name: number
    last_name: number
    phone_number: number
    date_of_birth: number
    is_active: number
    email_verified: number
    phone_verified: number
    role: number
    created: number
    updated: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password_hash?: true
    image?: true
    first_name?: true
    last_name?: true
    phone_number?: true
    date_of_birth?: true
    is_active?: true
    email_verified?: true
    phone_verified?: true
    role?: true
    created?: true
    updated?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password_hash?: true
    image?: true
    first_name?: true
    last_name?: true
    phone_number?: true
    date_of_birth?: true
    is_active?: true
    email_verified?: true
    phone_verified?: true
    role?: true
    created?: true
    updated?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password_hash?: true
    image?: true
    first_name?: true
    last_name?: true
    phone_number?: true
    date_of_birth?: true
    is_active?: true
    email_verified?: true
    phone_verified?: true
    role?: true
    created?: true
    updated?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password_hash: string
    image: string | null
    first_name: string
    last_name: string
    phone_number: string | null
    date_of_birth: Date | null
    is_active: boolean
    email_verified: boolean
    phone_verified: boolean
    role: $Enums.Role
    created: Date
    updated: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password_hash?: boolean
    image?: boolean
    first_name?: boolean
    last_name?: boolean
    phone_number?: boolean
    date_of_birth?: boolean
    is_active?: boolean
    email_verified?: boolean
    phone_verified?: boolean
    role?: boolean
    created?: boolean
    updated?: boolean
    reservations?: boolean | User$reservationsArgs<ExtArgs>
    events?: boolean | User$eventsArgs<ExtArgs>
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    card_details?: boolean | User$card_detailsArgs<ExtArgs>
    transfer_details?: boolean | User$transfer_detailsArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    sent_messages?: boolean | User$sent_messagesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password_hash?: boolean
    image?: boolean
    first_name?: boolean
    last_name?: boolean
    phone_number?: boolean
    date_of_birth?: boolean
    is_active?: boolean
    email_verified?: boolean
    phone_verified?: boolean
    role?: boolean
    created?: boolean
    updated?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password_hash?: boolean
    image?: boolean
    first_name?: boolean
    last_name?: boolean
    phone_number?: boolean
    date_of_birth?: boolean
    is_active?: boolean
    email_verified?: boolean
    phone_verified?: boolean
    role?: boolean
    created?: boolean
    updated?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password_hash?: boolean
    image?: boolean
    first_name?: boolean
    last_name?: boolean
    phone_number?: boolean
    date_of_birth?: boolean
    is_active?: boolean
    email_verified?: boolean
    phone_verified?: boolean
    role?: boolean
    created?: boolean
    updated?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password_hash" | "image" | "first_name" | "last_name" | "phone_number" | "date_of_birth" | "is_active" | "email_verified" | "phone_verified" | "role" | "created" | "updated", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reservations?: boolean | User$reservationsArgs<ExtArgs>
    events?: boolean | User$eventsArgs<ExtArgs>
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    card_details?: boolean | User$card_detailsArgs<ExtArgs>
    transfer_details?: boolean | User$transfer_detailsArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    sent_messages?: boolean | User$sent_messagesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      reservations: Prisma.$ReservationPayload<ExtArgs>[]
      events: Prisma.$EventPayload<ExtArgs>[]
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      card_details: Prisma.$CardDetailPayload<ExtArgs>[]
      transfer_details: Prisma.$TransferDetailPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      sent_messages: Prisma.$MessagePayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password_hash: string
      image: string | null
      first_name: string
      last_name: string
      phone_number: string | null
      date_of_birth: Date | null
      is_active: boolean
      email_verified: boolean
      phone_verified: boolean
      role: $Enums.Role
      created: Date
      updated: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reservations<T extends User$reservationsArgs<ExtArgs> = {}>(args?: Subset<T, User$reservationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    events<T extends User$eventsArgs<ExtArgs> = {}>(args?: Subset<T, User$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookings<T extends User$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, User$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends User$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    card_details<T extends User$card_detailsArgs<ExtArgs> = {}>(args?: Subset<T, User$card_detailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transfer_details<T extends User$transfer_detailsArgs<ExtArgs> = {}>(args?: Subset<T, User$transfer_detailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends User$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sent_messages<T extends User$sent_messagesArgs<ExtArgs> = {}>(args?: Subset<T, User$sent_messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password_hash: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
    readonly first_name: FieldRef<"User", 'String'>
    readonly last_name: FieldRef<"User", 'String'>
    readonly phone_number: FieldRef<"User", 'String'>
    readonly date_of_birth: FieldRef<"User", 'DateTime'>
    readonly is_active: FieldRef<"User", 'Boolean'>
    readonly email_verified: FieldRef<"User", 'Boolean'>
    readonly phone_verified: FieldRef<"User", 'Boolean'>
    readonly role: FieldRef<"User", 'Role'>
    readonly created: FieldRef<"User", 'DateTime'>
    readonly updated: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.reservations
   */
  export type User$reservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    cursor?: ReservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * User.events
   */
  export type User$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * User.bookings
   */
  export type User$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * User.transactions
   */
  export type User$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * User.card_details
   */
  export type User$card_detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardDetail
     */
    select?: CardDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardDetail
     */
    omit?: CardDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardDetailInclude<ExtArgs> | null
    where?: CardDetailWhereInput
    orderBy?: CardDetailOrderByWithRelationInput | CardDetailOrderByWithRelationInput[]
    cursor?: CardDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CardDetailScalarFieldEnum | CardDetailScalarFieldEnum[]
  }

  /**
   * User.transfer_details
   */
  export type User$transfer_detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferDetail
     */
    select?: TransferDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferDetail
     */
    omit?: TransferDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferDetailInclude<ExtArgs> | null
    where?: TransferDetailWhereInput
    orderBy?: TransferDetailOrderByWithRelationInput | TransferDetailOrderByWithRelationInput[]
    cursor?: TransferDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferDetailScalarFieldEnum | TransferDetailScalarFieldEnum[]
  }

  /**
   * User.reviews
   */
  export type User$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * User.sent_messages
   */
  export type User$sent_messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    type: $Enums.NotificationType | null
    action: $Enums.NotificationAction | null
    message: string | null
    user_id: string | null
    is_read: boolean | null
    created: Date | null
    updated: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    type: $Enums.NotificationType | null
    action: $Enums.NotificationAction | null
    message: string | null
    user_id: string | null
    is_read: boolean | null
    created: Date | null
    updated: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    type: number
    action: number
    message: number
    user_id: number
    is_read: number
    created: number
    updated: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    type?: true
    action?: true
    message?: true
    user_id?: true
    is_read?: true
    created?: true
    updated?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    type?: true
    action?: true
    message?: true
    user_id?: true
    is_read?: true
    created?: true
    updated?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    type?: true
    action?: true
    message?: true
    user_id?: true
    is_read?: true
    created?: true
    updated?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    type: $Enums.NotificationType
    action: $Enums.NotificationAction
    message: string | null
    user_id: string | null
    is_read: boolean
    created: Date
    updated: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    action?: boolean
    message?: boolean
    user_id?: boolean
    is_read?: boolean
    created?: boolean
    updated?: boolean
    user?: boolean | Notification$userArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    action?: boolean
    message?: boolean
    user_id?: boolean
    is_read?: boolean
    created?: boolean
    updated?: boolean
    user?: boolean | Notification$userArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    action?: boolean
    message?: boolean
    user_id?: boolean
    is_read?: boolean
    created?: boolean
    updated?: boolean
    user?: boolean | Notification$userArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    type?: boolean
    action?: boolean
    message?: boolean
    user_id?: boolean
    is_read?: boolean
    created?: boolean
    updated?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "action" | "message" | "user_id" | "is_read" | "created" | "updated", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Notification$userArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Notification$userArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Notification$userArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.NotificationType
      action: $Enums.NotificationAction
      message: string | null
      user_id: string | null
      is_read: boolean
      created: Date
      updated: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Notification$userArgs<ExtArgs> = {}>(args?: Subset<T, Notification$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly action: FieldRef<"Notification", 'NotificationAction'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly user_id: FieldRef<"Notification", 'String'>
    readonly is_read: FieldRef<"Notification", 'Boolean'>
    readonly created: FieldRef<"Notification", 'DateTime'>
    readonly updated: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification.user
   */
  export type Notification$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    sender_id: string | null
    receiver_id: string | null
    message: string | null
    is_read: boolean | null
    booking_id: string | null
    edited: Date | null
    replace_to: string | null
    is_excluded: boolean | null
    created: Date | null
    updated: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    sender_id: string | null
    receiver_id: string | null
    message: string | null
    is_read: boolean | null
    booking_id: string | null
    edited: Date | null
    replace_to: string | null
    is_excluded: boolean | null
    created: Date | null
    updated: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    sender_id: number
    receiver_id: number
    message: number
    is_read: number
    booking_id: number
    edited: number
    replace_to: number
    is_excluded: number
    created: number
    updated: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    sender_id?: true
    receiver_id?: true
    message?: true
    is_read?: true
    booking_id?: true
    edited?: true
    replace_to?: true
    is_excluded?: true
    created?: true
    updated?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    sender_id?: true
    receiver_id?: true
    message?: true
    is_read?: true
    booking_id?: true
    edited?: true
    replace_to?: true
    is_excluded?: true
    created?: true
    updated?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    sender_id?: true
    receiver_id?: true
    message?: true
    is_read?: true
    booking_id?: true
    edited?: true
    replace_to?: true
    is_excluded?: true
    created?: true
    updated?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    sender_id: string
    receiver_id: string
    message: string
    is_read: boolean
    booking_id: string | null
    edited: Date | null
    replace_to: string | null
    is_excluded: boolean
    created: Date
    updated: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sender_id?: boolean
    receiver_id?: boolean
    message?: boolean
    is_read?: boolean
    booking_id?: boolean
    edited?: boolean
    replace_to?: boolean
    is_excluded?: boolean
    created?: boolean
    updated?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    booking?: boolean | Message$bookingArgs<ExtArgs>
    replaces?: boolean | Message$replacesArgs<ExtArgs>
    replaced_by?: boolean | Message$replaced_byArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sender_id?: boolean
    receiver_id?: boolean
    message?: boolean
    is_read?: boolean
    booking_id?: boolean
    edited?: boolean
    replace_to?: boolean
    is_excluded?: boolean
    created?: boolean
    updated?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    booking?: boolean | Message$bookingArgs<ExtArgs>
    replaces?: boolean | Message$replacesArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sender_id?: boolean
    receiver_id?: boolean
    message?: boolean
    is_read?: boolean
    booking_id?: boolean
    edited?: boolean
    replace_to?: boolean
    is_excluded?: boolean
    created?: boolean
    updated?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    booking?: boolean | Message$bookingArgs<ExtArgs>
    replaces?: boolean | Message$replacesArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    sender_id?: boolean
    receiver_id?: boolean
    message?: boolean
    is_read?: boolean
    booking_id?: boolean
    edited?: boolean
    replace_to?: boolean
    is_excluded?: boolean
    created?: boolean
    updated?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sender_id" | "receiver_id" | "message" | "is_read" | "booking_id" | "edited" | "replace_to" | "is_excluded" | "created" | "updated", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    booking?: boolean | Message$bookingArgs<ExtArgs>
    replaces?: boolean | Message$replacesArgs<ExtArgs>
    replaced_by?: boolean | Message$replaced_byArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    booking?: boolean | Message$bookingArgs<ExtArgs>
    replaces?: boolean | Message$replacesArgs<ExtArgs>
  }
  export type MessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    booking?: boolean | Message$bookingArgs<ExtArgs>
    replaces?: boolean | Message$replacesArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      sender: Prisma.$UserPayload<ExtArgs>
      booking: Prisma.$BookingPayload<ExtArgs> | null
      replaces: Prisma.$MessagePayload<ExtArgs> | null
      replaced_by: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sender_id: string
      receiver_id: string
      message: string
      is_read: boolean
      booking_id: string | null
      edited: Date | null
      replace_to: string | null
      is_excluded: boolean
      created: Date
      updated: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    booking<T extends Message$bookingArgs<ExtArgs> = {}>(args?: Subset<T, Message$bookingArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    replaces<T extends Message$replacesArgs<ExtArgs> = {}>(args?: Subset<T, Message$replacesArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    replaced_by<T extends Message$replaced_byArgs<ExtArgs> = {}>(args?: Subset<T, Message$replaced_byArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly sender_id: FieldRef<"Message", 'String'>
    readonly receiver_id: FieldRef<"Message", 'String'>
    readonly message: FieldRef<"Message", 'String'>
    readonly is_read: FieldRef<"Message", 'Boolean'>
    readonly booking_id: FieldRef<"Message", 'String'>
    readonly edited: FieldRef<"Message", 'DateTime'>
    readonly replace_to: FieldRef<"Message", 'String'>
    readonly is_excluded: FieldRef<"Message", 'Boolean'>
    readonly created: FieldRef<"Message", 'DateTime'>
    readonly updated: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message.booking
   */
  export type Message$bookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
  }

  /**
   * Message.replaces
   */
  export type Message$replacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
  }

  /**
   * Message.replaced_by
   */
  export type Message$replaced_byArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model Apartment
   */

  export type AggregateApartment = {
    _count: ApartmentCountAggregateOutputType | null
    _avg: ApartmentAvgAggregateOutputType | null
    _sum: ApartmentSumAggregateOutputType | null
    _min: ApartmentMinAggregateOutputType | null
    _max: ApartmentMaxAggregateOutputType | null
  }

  export type ApartmentAvgAggregateOutputType = {
    number: number | null
    floor: number | null
    rooms_count: number | null
    max_capacity: number | null
    deposit: number | null
  }

  export type ApartmentSumAggregateOutputType = {
    number: number | null
    floor: number | null
    rooms_count: number | null
    max_capacity: number | null
    deposit: number | null
  }

  export type ApartmentMinAggregateOutputType = {
    id: string | null
    image: string | null
    name: string | null
    description: string | null
    rules: string | null
    number: number | null
    floor: number | null
    rooms_count: number | null
    max_capacity: number | null
    is_available: boolean | null
    is_smoking: boolean | null
    is_pet_friendly: boolean | null
    deposit: number | null
    type: $Enums.ApartmentType | null
    created: Date | null
    updated: Date | null
    is_excluded: boolean | null
  }

  export type ApartmentMaxAggregateOutputType = {
    id: string | null
    image: string | null
    name: string | null
    description: string | null
    rules: string | null
    number: number | null
    floor: number | null
    rooms_count: number | null
    max_capacity: number | null
    is_available: boolean | null
    is_smoking: boolean | null
    is_pet_friendly: boolean | null
    deposit: number | null
    type: $Enums.ApartmentType | null
    created: Date | null
    updated: Date | null
    is_excluded: boolean | null
  }

  export type ApartmentCountAggregateOutputType = {
    id: number
    image: number
    name: number
    description: number
    rules: number
    number: number
    floor: number
    rooms_count: number
    max_capacity: number
    is_available: number
    is_smoking: number
    is_pet_friendly: number
    deposit: number
    type: number
    created: number
    updated: number
    is_excluded: number
    _all: number
  }


  export type ApartmentAvgAggregateInputType = {
    number?: true
    floor?: true
    rooms_count?: true
    max_capacity?: true
    deposit?: true
  }

  export type ApartmentSumAggregateInputType = {
    number?: true
    floor?: true
    rooms_count?: true
    max_capacity?: true
    deposit?: true
  }

  export type ApartmentMinAggregateInputType = {
    id?: true
    image?: true
    name?: true
    description?: true
    rules?: true
    number?: true
    floor?: true
    rooms_count?: true
    max_capacity?: true
    is_available?: true
    is_smoking?: true
    is_pet_friendly?: true
    deposit?: true
    type?: true
    created?: true
    updated?: true
    is_excluded?: true
  }

  export type ApartmentMaxAggregateInputType = {
    id?: true
    image?: true
    name?: true
    description?: true
    rules?: true
    number?: true
    floor?: true
    rooms_count?: true
    max_capacity?: true
    is_available?: true
    is_smoking?: true
    is_pet_friendly?: true
    deposit?: true
    type?: true
    created?: true
    updated?: true
    is_excluded?: true
  }

  export type ApartmentCountAggregateInputType = {
    id?: true
    image?: true
    name?: true
    description?: true
    rules?: true
    number?: true
    floor?: true
    rooms_count?: true
    max_capacity?: true
    is_available?: true
    is_smoking?: true
    is_pet_friendly?: true
    deposit?: true
    type?: true
    created?: true
    updated?: true
    is_excluded?: true
    _all?: true
  }

  export type ApartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Apartment to aggregate.
     */
    where?: ApartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Apartments to fetch.
     */
    orderBy?: ApartmentOrderByWithRelationInput | ApartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Apartments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Apartments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Apartments
    **/
    _count?: true | ApartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApartmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApartmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApartmentMaxAggregateInputType
  }

  export type GetApartmentAggregateType<T extends ApartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateApartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApartment[P]>
      : GetScalarType<T[P], AggregateApartment[P]>
  }




  export type ApartmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApartmentWhereInput
    orderBy?: ApartmentOrderByWithAggregationInput | ApartmentOrderByWithAggregationInput[]
    by: ApartmentScalarFieldEnum[] | ApartmentScalarFieldEnum
    having?: ApartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApartmentCountAggregateInputType | true
    _avg?: ApartmentAvgAggregateInputType
    _sum?: ApartmentSumAggregateInputType
    _min?: ApartmentMinAggregateInputType
    _max?: ApartmentMaxAggregateInputType
  }

  export type ApartmentGroupByOutputType = {
    id: string
    image: string | null
    name: string | null
    description: string | null
    rules: string | null
    number: number
    floor: number
    rooms_count: number
    max_capacity: number | null
    is_available: boolean
    is_smoking: boolean
    is_pet_friendly: boolean
    deposit: number
    type: $Enums.ApartmentType
    created: Date
    updated: Date
    is_excluded: boolean
    _count: ApartmentCountAggregateOutputType | null
    _avg: ApartmentAvgAggregateOutputType | null
    _sum: ApartmentSumAggregateOutputType | null
    _min: ApartmentMinAggregateOutputType | null
    _max: ApartmentMaxAggregateOutputType | null
  }

  type GetApartmentGroupByPayload<T extends ApartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApartmentGroupByOutputType[P]>
            : GetScalarType<T[P], ApartmentGroupByOutputType[P]>
        }
      >
    >


  export type ApartmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    image?: boolean
    name?: boolean
    description?: boolean
    rules?: boolean
    number?: boolean
    floor?: boolean
    rooms_count?: boolean
    max_capacity?: boolean
    is_available?: boolean
    is_smoking?: boolean
    is_pet_friendly?: boolean
    deposit?: boolean
    type?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
    images?: boolean | Apartment$imagesArgs<ExtArgs>
    apartment_beds?: boolean | Apartment$apartment_bedsArgs<ExtArgs>
    apartment_amenities?: boolean | Apartment$apartment_amenitiesArgs<ExtArgs>
    reservations?: boolean | Apartment$reservationsArgs<ExtArgs>
    booking_variants?: boolean | Apartment$booking_variantsArgs<ExtArgs>
    reviews?: boolean | Apartment$reviewsArgs<ExtArgs>
    _count?: boolean | ApartmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apartment"]>

  export type ApartmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    image?: boolean
    name?: boolean
    description?: boolean
    rules?: boolean
    number?: boolean
    floor?: boolean
    rooms_count?: boolean
    max_capacity?: boolean
    is_available?: boolean
    is_smoking?: boolean
    is_pet_friendly?: boolean
    deposit?: boolean
    type?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
  }, ExtArgs["result"]["apartment"]>

  export type ApartmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    image?: boolean
    name?: boolean
    description?: boolean
    rules?: boolean
    number?: boolean
    floor?: boolean
    rooms_count?: boolean
    max_capacity?: boolean
    is_available?: boolean
    is_smoking?: boolean
    is_pet_friendly?: boolean
    deposit?: boolean
    type?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
  }, ExtArgs["result"]["apartment"]>

  export type ApartmentSelectScalar = {
    id?: boolean
    image?: boolean
    name?: boolean
    description?: boolean
    rules?: boolean
    number?: boolean
    floor?: boolean
    rooms_count?: boolean
    max_capacity?: boolean
    is_available?: boolean
    is_smoking?: boolean
    is_pet_friendly?: boolean
    deposit?: boolean
    type?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
  }

  export type ApartmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "image" | "name" | "description" | "rules" | "number" | "floor" | "rooms_count" | "max_capacity" | "is_available" | "is_smoking" | "is_pet_friendly" | "deposit" | "type" | "created" | "updated" | "is_excluded", ExtArgs["result"]["apartment"]>
  export type ApartmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | Apartment$imagesArgs<ExtArgs>
    apartment_beds?: boolean | Apartment$apartment_bedsArgs<ExtArgs>
    apartment_amenities?: boolean | Apartment$apartment_amenitiesArgs<ExtArgs>
    reservations?: boolean | Apartment$reservationsArgs<ExtArgs>
    booking_variants?: boolean | Apartment$booking_variantsArgs<ExtArgs>
    reviews?: boolean | Apartment$reviewsArgs<ExtArgs>
    _count?: boolean | ApartmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ApartmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ApartmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ApartmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Apartment"
    objects: {
      images: Prisma.$ApartmentImagePayload<ExtArgs>[]
      apartment_beds: Prisma.$ApartmentBedPayload<ExtArgs>[]
      apartment_amenities: Prisma.$ApartmentAmenityPayload<ExtArgs>[]
      reservations: Prisma.$ReservationPayload<ExtArgs>[]
      booking_variants: Prisma.$BookingVariantPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      image: string | null
      name: string | null
      description: string | null
      rules: string | null
      number: number
      floor: number
      rooms_count: number
      max_capacity: number | null
      is_available: boolean
      is_smoking: boolean
      is_pet_friendly: boolean
      deposit: number
      type: $Enums.ApartmentType
      created: Date
      updated: Date
      is_excluded: boolean
    }, ExtArgs["result"]["apartment"]>
    composites: {}
  }

  type ApartmentGetPayload<S extends boolean | null | undefined | ApartmentDefaultArgs> = $Result.GetResult<Prisma.$ApartmentPayload, S>

  type ApartmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApartmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApartmentCountAggregateInputType | true
    }

  export interface ApartmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Apartment'], meta: { name: 'Apartment' } }
    /**
     * Find zero or one Apartment that matches the filter.
     * @param {ApartmentFindUniqueArgs} args - Arguments to find a Apartment
     * @example
     * // Get one Apartment
     * const apartment = await prisma.apartment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApartmentFindUniqueArgs>(args: SelectSubset<T, ApartmentFindUniqueArgs<ExtArgs>>): Prisma__ApartmentClient<$Result.GetResult<Prisma.$ApartmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Apartment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApartmentFindUniqueOrThrowArgs} args - Arguments to find a Apartment
     * @example
     * // Get one Apartment
     * const apartment = await prisma.apartment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApartmentFindUniqueOrThrowArgs>(args: SelectSubset<T, ApartmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApartmentClient<$Result.GetResult<Prisma.$ApartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Apartment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApartmentFindFirstArgs} args - Arguments to find a Apartment
     * @example
     * // Get one Apartment
     * const apartment = await prisma.apartment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApartmentFindFirstArgs>(args?: SelectSubset<T, ApartmentFindFirstArgs<ExtArgs>>): Prisma__ApartmentClient<$Result.GetResult<Prisma.$ApartmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Apartment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApartmentFindFirstOrThrowArgs} args - Arguments to find a Apartment
     * @example
     * // Get one Apartment
     * const apartment = await prisma.apartment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApartmentFindFirstOrThrowArgs>(args?: SelectSubset<T, ApartmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApartmentClient<$Result.GetResult<Prisma.$ApartmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Apartments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApartmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Apartments
     * const apartments = await prisma.apartment.findMany()
     * 
     * // Get first 10 Apartments
     * const apartments = await prisma.apartment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apartmentWithIdOnly = await prisma.apartment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApartmentFindManyArgs>(args?: SelectSubset<T, ApartmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Apartment.
     * @param {ApartmentCreateArgs} args - Arguments to create a Apartment.
     * @example
     * // Create one Apartment
     * const Apartment = await prisma.apartment.create({
     *   data: {
     *     // ... data to create a Apartment
     *   }
     * })
     * 
     */
    create<T extends ApartmentCreateArgs>(args: SelectSubset<T, ApartmentCreateArgs<ExtArgs>>): Prisma__ApartmentClient<$Result.GetResult<Prisma.$ApartmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Apartments.
     * @param {ApartmentCreateManyArgs} args - Arguments to create many Apartments.
     * @example
     * // Create many Apartments
     * const apartment = await prisma.apartment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApartmentCreateManyArgs>(args?: SelectSubset<T, ApartmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Apartments and returns the data saved in the database.
     * @param {ApartmentCreateManyAndReturnArgs} args - Arguments to create many Apartments.
     * @example
     * // Create many Apartments
     * const apartment = await prisma.apartment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Apartments and only return the `id`
     * const apartmentWithIdOnly = await prisma.apartment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApartmentCreateManyAndReturnArgs>(args?: SelectSubset<T, ApartmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApartmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Apartment.
     * @param {ApartmentDeleteArgs} args - Arguments to delete one Apartment.
     * @example
     * // Delete one Apartment
     * const Apartment = await prisma.apartment.delete({
     *   where: {
     *     // ... filter to delete one Apartment
     *   }
     * })
     * 
     */
    delete<T extends ApartmentDeleteArgs>(args: SelectSubset<T, ApartmentDeleteArgs<ExtArgs>>): Prisma__ApartmentClient<$Result.GetResult<Prisma.$ApartmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Apartment.
     * @param {ApartmentUpdateArgs} args - Arguments to update one Apartment.
     * @example
     * // Update one Apartment
     * const apartment = await prisma.apartment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApartmentUpdateArgs>(args: SelectSubset<T, ApartmentUpdateArgs<ExtArgs>>): Prisma__ApartmentClient<$Result.GetResult<Prisma.$ApartmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Apartments.
     * @param {ApartmentDeleteManyArgs} args - Arguments to filter Apartments to delete.
     * @example
     * // Delete a few Apartments
     * const { count } = await prisma.apartment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApartmentDeleteManyArgs>(args?: SelectSubset<T, ApartmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Apartments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Apartments
     * const apartment = await prisma.apartment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApartmentUpdateManyArgs>(args: SelectSubset<T, ApartmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Apartments and returns the data updated in the database.
     * @param {ApartmentUpdateManyAndReturnArgs} args - Arguments to update many Apartments.
     * @example
     * // Update many Apartments
     * const apartment = await prisma.apartment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Apartments and only return the `id`
     * const apartmentWithIdOnly = await prisma.apartment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApartmentUpdateManyAndReturnArgs>(args: SelectSubset<T, ApartmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApartmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Apartment.
     * @param {ApartmentUpsertArgs} args - Arguments to update or create a Apartment.
     * @example
     * // Update or create a Apartment
     * const apartment = await prisma.apartment.upsert({
     *   create: {
     *     // ... data to create a Apartment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Apartment we want to update
     *   }
     * })
     */
    upsert<T extends ApartmentUpsertArgs>(args: SelectSubset<T, ApartmentUpsertArgs<ExtArgs>>): Prisma__ApartmentClient<$Result.GetResult<Prisma.$ApartmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Apartments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApartmentCountArgs} args - Arguments to filter Apartments to count.
     * @example
     * // Count the number of Apartments
     * const count = await prisma.apartment.count({
     *   where: {
     *     // ... the filter for the Apartments we want to count
     *   }
     * })
    **/
    count<T extends ApartmentCountArgs>(
      args?: Subset<T, ApartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Apartment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApartmentAggregateArgs>(args: Subset<T, ApartmentAggregateArgs>): Prisma.PrismaPromise<GetApartmentAggregateType<T>>

    /**
     * Group by Apartment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApartmentGroupByArgs['orderBy'] }
        : { orderBy?: ApartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Apartment model
   */
  readonly fields: ApartmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Apartment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApartmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    images<T extends Apartment$imagesArgs<ExtArgs> = {}>(args?: Subset<T, Apartment$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApartmentImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    apartment_beds<T extends Apartment$apartment_bedsArgs<ExtArgs> = {}>(args?: Subset<T, Apartment$apartment_bedsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApartmentBedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    apartment_amenities<T extends Apartment$apartment_amenitiesArgs<ExtArgs> = {}>(args?: Subset<T, Apartment$apartment_amenitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApartmentAmenityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reservations<T extends Apartment$reservationsArgs<ExtArgs> = {}>(args?: Subset<T, Apartment$reservationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    booking_variants<T extends Apartment$booking_variantsArgs<ExtArgs> = {}>(args?: Subset<T, Apartment$booking_variantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingVariantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends Apartment$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Apartment$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Apartment model
   */
  interface ApartmentFieldRefs {
    readonly id: FieldRef<"Apartment", 'String'>
    readonly image: FieldRef<"Apartment", 'String'>
    readonly name: FieldRef<"Apartment", 'String'>
    readonly description: FieldRef<"Apartment", 'String'>
    readonly rules: FieldRef<"Apartment", 'String'>
    readonly number: FieldRef<"Apartment", 'Int'>
    readonly floor: FieldRef<"Apartment", 'Int'>
    readonly rooms_count: FieldRef<"Apartment", 'Int'>
    readonly max_capacity: FieldRef<"Apartment", 'Int'>
    readonly is_available: FieldRef<"Apartment", 'Boolean'>
    readonly is_smoking: FieldRef<"Apartment", 'Boolean'>
    readonly is_pet_friendly: FieldRef<"Apartment", 'Boolean'>
    readonly deposit: FieldRef<"Apartment", 'Float'>
    readonly type: FieldRef<"Apartment", 'ApartmentType'>
    readonly created: FieldRef<"Apartment", 'DateTime'>
    readonly updated: FieldRef<"Apartment", 'DateTime'>
    readonly is_excluded: FieldRef<"Apartment", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Apartment findUnique
   */
  export type ApartmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Apartment
     */
    select?: ApartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Apartment
     */
    omit?: ApartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentInclude<ExtArgs> | null
    /**
     * Filter, which Apartment to fetch.
     */
    where: ApartmentWhereUniqueInput
  }

  /**
   * Apartment findUniqueOrThrow
   */
  export type ApartmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Apartment
     */
    select?: ApartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Apartment
     */
    omit?: ApartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentInclude<ExtArgs> | null
    /**
     * Filter, which Apartment to fetch.
     */
    where: ApartmentWhereUniqueInput
  }

  /**
   * Apartment findFirst
   */
  export type ApartmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Apartment
     */
    select?: ApartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Apartment
     */
    omit?: ApartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentInclude<ExtArgs> | null
    /**
     * Filter, which Apartment to fetch.
     */
    where?: ApartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Apartments to fetch.
     */
    orderBy?: ApartmentOrderByWithRelationInput | ApartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Apartments.
     */
    cursor?: ApartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Apartments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Apartments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Apartments.
     */
    distinct?: ApartmentScalarFieldEnum | ApartmentScalarFieldEnum[]
  }

  /**
   * Apartment findFirstOrThrow
   */
  export type ApartmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Apartment
     */
    select?: ApartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Apartment
     */
    omit?: ApartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentInclude<ExtArgs> | null
    /**
     * Filter, which Apartment to fetch.
     */
    where?: ApartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Apartments to fetch.
     */
    orderBy?: ApartmentOrderByWithRelationInput | ApartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Apartments.
     */
    cursor?: ApartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Apartments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Apartments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Apartments.
     */
    distinct?: ApartmentScalarFieldEnum | ApartmentScalarFieldEnum[]
  }

  /**
   * Apartment findMany
   */
  export type ApartmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Apartment
     */
    select?: ApartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Apartment
     */
    omit?: ApartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentInclude<ExtArgs> | null
    /**
     * Filter, which Apartments to fetch.
     */
    where?: ApartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Apartments to fetch.
     */
    orderBy?: ApartmentOrderByWithRelationInput | ApartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Apartments.
     */
    cursor?: ApartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Apartments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Apartments.
     */
    skip?: number
    distinct?: ApartmentScalarFieldEnum | ApartmentScalarFieldEnum[]
  }

  /**
   * Apartment create
   */
  export type ApartmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Apartment
     */
    select?: ApartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Apartment
     */
    omit?: ApartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Apartment.
     */
    data: XOR<ApartmentCreateInput, ApartmentUncheckedCreateInput>
  }

  /**
   * Apartment createMany
   */
  export type ApartmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Apartments.
     */
    data: ApartmentCreateManyInput | ApartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Apartment createManyAndReturn
   */
  export type ApartmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Apartment
     */
    select?: ApartmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Apartment
     */
    omit?: ApartmentOmit<ExtArgs> | null
    /**
     * The data used to create many Apartments.
     */
    data: ApartmentCreateManyInput | ApartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Apartment update
   */
  export type ApartmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Apartment
     */
    select?: ApartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Apartment
     */
    omit?: ApartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Apartment.
     */
    data: XOR<ApartmentUpdateInput, ApartmentUncheckedUpdateInput>
    /**
     * Choose, which Apartment to update.
     */
    where: ApartmentWhereUniqueInput
  }

  /**
   * Apartment updateMany
   */
  export type ApartmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Apartments.
     */
    data: XOR<ApartmentUpdateManyMutationInput, ApartmentUncheckedUpdateManyInput>
    /**
     * Filter which Apartments to update
     */
    where?: ApartmentWhereInput
    /**
     * Limit how many Apartments to update.
     */
    limit?: number
  }

  /**
   * Apartment updateManyAndReturn
   */
  export type ApartmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Apartment
     */
    select?: ApartmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Apartment
     */
    omit?: ApartmentOmit<ExtArgs> | null
    /**
     * The data used to update Apartments.
     */
    data: XOR<ApartmentUpdateManyMutationInput, ApartmentUncheckedUpdateManyInput>
    /**
     * Filter which Apartments to update
     */
    where?: ApartmentWhereInput
    /**
     * Limit how many Apartments to update.
     */
    limit?: number
  }

  /**
   * Apartment upsert
   */
  export type ApartmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Apartment
     */
    select?: ApartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Apartment
     */
    omit?: ApartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Apartment to update in case it exists.
     */
    where: ApartmentWhereUniqueInput
    /**
     * In case the Apartment found by the `where` argument doesn't exist, create a new Apartment with this data.
     */
    create: XOR<ApartmentCreateInput, ApartmentUncheckedCreateInput>
    /**
     * In case the Apartment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApartmentUpdateInput, ApartmentUncheckedUpdateInput>
  }

  /**
   * Apartment delete
   */
  export type ApartmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Apartment
     */
    select?: ApartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Apartment
     */
    omit?: ApartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentInclude<ExtArgs> | null
    /**
     * Filter which Apartment to delete.
     */
    where: ApartmentWhereUniqueInput
  }

  /**
   * Apartment deleteMany
   */
  export type ApartmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Apartments to delete
     */
    where?: ApartmentWhereInput
    /**
     * Limit how many Apartments to delete.
     */
    limit?: number
  }

  /**
   * Apartment.images
   */
  export type Apartment$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApartmentImage
     */
    select?: ApartmentImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApartmentImage
     */
    omit?: ApartmentImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentImageInclude<ExtArgs> | null
    where?: ApartmentImageWhereInput
    orderBy?: ApartmentImageOrderByWithRelationInput | ApartmentImageOrderByWithRelationInput[]
    cursor?: ApartmentImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApartmentImageScalarFieldEnum | ApartmentImageScalarFieldEnum[]
  }

  /**
   * Apartment.apartment_beds
   */
  export type Apartment$apartment_bedsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApartmentBed
     */
    select?: ApartmentBedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApartmentBed
     */
    omit?: ApartmentBedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentBedInclude<ExtArgs> | null
    where?: ApartmentBedWhereInput
    orderBy?: ApartmentBedOrderByWithRelationInput | ApartmentBedOrderByWithRelationInput[]
    cursor?: ApartmentBedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApartmentBedScalarFieldEnum | ApartmentBedScalarFieldEnum[]
  }

  /**
   * Apartment.apartment_amenities
   */
  export type Apartment$apartment_amenitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApartmentAmenity
     */
    select?: ApartmentAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApartmentAmenity
     */
    omit?: ApartmentAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentAmenityInclude<ExtArgs> | null
    where?: ApartmentAmenityWhereInput
    orderBy?: ApartmentAmenityOrderByWithRelationInput | ApartmentAmenityOrderByWithRelationInput[]
    cursor?: ApartmentAmenityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApartmentAmenityScalarFieldEnum | ApartmentAmenityScalarFieldEnum[]
  }

  /**
   * Apartment.reservations
   */
  export type Apartment$reservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    cursor?: ReservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Apartment.booking_variants
   */
  export type Apartment$booking_variantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingVariant
     */
    select?: BookingVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingVariant
     */
    omit?: BookingVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingVariantInclude<ExtArgs> | null
    where?: BookingVariantWhereInput
    orderBy?: BookingVariantOrderByWithRelationInput | BookingVariantOrderByWithRelationInput[]
    cursor?: BookingVariantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingVariantScalarFieldEnum | BookingVariantScalarFieldEnum[]
  }

  /**
   * Apartment.reviews
   */
  export type Apartment$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Apartment without action
   */
  export type ApartmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Apartment
     */
    select?: ApartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Apartment
     */
    omit?: ApartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentInclude<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    rating: number | null
  }

  export type ReviewSumAggregateOutputType = {
    rating: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    apartment_id: string | null
    booking_id: string | null
    rating: number | null
    comment: string | null
    created: Date | null
    updated: Date | null
    is_excluded: boolean | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    apartment_id: string | null
    booking_id: string | null
    rating: number | null
    comment: string | null
    created: Date | null
    updated: Date | null
    is_excluded: boolean | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    user_id: number
    apartment_id: number
    booking_id: number
    rating: number
    comment: number
    created: number
    updated: number
    is_excluded: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    rating?: true
  }

  export type ReviewSumAggregateInputType = {
    rating?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    user_id?: true
    apartment_id?: true
    booking_id?: true
    rating?: true
    comment?: true
    created?: true
    updated?: true
    is_excluded?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    user_id?: true
    apartment_id?: true
    booking_id?: true
    rating?: true
    comment?: true
    created?: true
    updated?: true
    is_excluded?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    user_id?: true
    apartment_id?: true
    booking_id?: true
    rating?: true
    comment?: true
    created?: true
    updated?: true
    is_excluded?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: string
    user_id: string
    apartment_id: string | null
    booking_id: string | null
    rating: number
    comment: string | null
    created: Date
    updated: Date
    is_excluded: boolean
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    apartment_id?: boolean
    booking_id?: boolean
    rating?: boolean
    comment?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    apartment?: boolean | Review$apartmentArgs<ExtArgs>
    booking?: boolean | Review$bookingArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    apartment_id?: boolean
    booking_id?: boolean
    rating?: boolean
    comment?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    apartment?: boolean | Review$apartmentArgs<ExtArgs>
    booking?: boolean | Review$bookingArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    apartment_id?: boolean
    booking_id?: boolean
    rating?: boolean
    comment?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    apartment?: boolean | Review$apartmentArgs<ExtArgs>
    booking?: boolean | Review$bookingArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectScalar = {
    id?: boolean
    user_id?: boolean
    apartment_id?: boolean
    booking_id?: boolean
    rating?: boolean
    comment?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
  }

  export type ReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "apartment_id" | "booking_id" | "rating" | "comment" | "created" | "updated" | "is_excluded", ExtArgs["result"]["review"]>
  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    apartment?: boolean | Review$apartmentArgs<ExtArgs>
    booking?: boolean | Review$bookingArgs<ExtArgs>
  }
  export type ReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    apartment?: boolean | Review$apartmentArgs<ExtArgs>
    booking?: boolean | Review$bookingArgs<ExtArgs>
  }
  export type ReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    apartment?: boolean | Review$apartmentArgs<ExtArgs>
    booking?: boolean | Review$bookingArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      apartment: Prisma.$ApartmentPayload<ExtArgs> | null
      booking: Prisma.$BookingPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      apartment_id: string | null
      booking_id: string | null
      rating: number
      comment: string | null
      created: Date
      updated: Date
      is_excluded: boolean
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews and returns the data updated in the database.
     * @param {ReviewUpdateManyAndReturnArgs} args - Arguments to update many Reviews.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    apartment<T extends Review$apartmentArgs<ExtArgs> = {}>(args?: Subset<T, Review$apartmentArgs<ExtArgs>>): Prisma__ApartmentClient<$Result.GetResult<Prisma.$ApartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    booking<T extends Review$bookingArgs<ExtArgs> = {}>(args?: Subset<T, Review$bookingArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'String'>
    readonly user_id: FieldRef<"Review", 'String'>
    readonly apartment_id: FieldRef<"Review", 'String'>
    readonly booking_id: FieldRef<"Review", 'String'>
    readonly rating: FieldRef<"Review", 'Int'>
    readonly comment: FieldRef<"Review", 'String'>
    readonly created: FieldRef<"Review", 'DateTime'>
    readonly updated: FieldRef<"Review", 'DateTime'>
    readonly is_excluded: FieldRef<"Review", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Review createManyAndReturn
   */
  export type ReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
  }

  /**
   * Review updateManyAndReturn
   */
  export type ReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to delete.
     */
    limit?: number
  }

  /**
   * Review.apartment
   */
  export type Review$apartmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Apartment
     */
    select?: ApartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Apartment
     */
    omit?: ApartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentInclude<ExtArgs> | null
    where?: ApartmentWhereInput
  }

  /**
   * Review.booking
   */
  export type Review$bookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Model Amenity
   */

  export type AggregateAmenity = {
    _count: AmenityCountAggregateOutputType | null
    _min: AmenityMinAggregateOutputType | null
    _max: AmenityMaxAggregateOutputType | null
  }

  export type AmenityMinAggregateOutputType = {
    id: string | null
    name: string | null
    image: string | null
    description: string | null
    created: Date | null
    updated: Date | null
    is_excluded: boolean | null
  }

  export type AmenityMaxAggregateOutputType = {
    id: string | null
    name: string | null
    image: string | null
    description: string | null
    created: Date | null
    updated: Date | null
    is_excluded: boolean | null
  }

  export type AmenityCountAggregateOutputType = {
    id: number
    name: number
    image: number
    description: number
    created: number
    updated: number
    is_excluded: number
    _all: number
  }


  export type AmenityMinAggregateInputType = {
    id?: true
    name?: true
    image?: true
    description?: true
    created?: true
    updated?: true
    is_excluded?: true
  }

  export type AmenityMaxAggregateInputType = {
    id?: true
    name?: true
    image?: true
    description?: true
    created?: true
    updated?: true
    is_excluded?: true
  }

  export type AmenityCountAggregateInputType = {
    id?: true
    name?: true
    image?: true
    description?: true
    created?: true
    updated?: true
    is_excluded?: true
    _all?: true
  }

  export type AmenityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Amenity to aggregate.
     */
    where?: AmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenityOrderByWithRelationInput | AmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Amenities
    **/
    _count?: true | AmenityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AmenityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AmenityMaxAggregateInputType
  }

  export type GetAmenityAggregateType<T extends AmenityAggregateArgs> = {
        [P in keyof T & keyof AggregateAmenity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAmenity[P]>
      : GetScalarType<T[P], AggregateAmenity[P]>
  }




  export type AmenityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AmenityWhereInput
    orderBy?: AmenityOrderByWithAggregationInput | AmenityOrderByWithAggregationInput[]
    by: AmenityScalarFieldEnum[] | AmenityScalarFieldEnum
    having?: AmenityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AmenityCountAggregateInputType | true
    _min?: AmenityMinAggregateInputType
    _max?: AmenityMaxAggregateInputType
  }

  export type AmenityGroupByOutputType = {
    id: string
    name: string
    image: string
    description: string | null
    created: Date
    updated: Date
    is_excluded: boolean
    _count: AmenityCountAggregateOutputType | null
    _min: AmenityMinAggregateOutputType | null
    _max: AmenityMaxAggregateOutputType | null
  }

  type GetAmenityGroupByPayload<T extends AmenityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AmenityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AmenityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AmenityGroupByOutputType[P]>
            : GetScalarType<T[P], AmenityGroupByOutputType[P]>
        }
      >
    >


  export type AmenitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    image?: boolean
    description?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
    apartment_amenities?: boolean | Amenity$apartment_amenitiesArgs<ExtArgs>
    _count?: boolean | AmenityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["amenity"]>

  export type AmenitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    image?: boolean
    description?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
  }, ExtArgs["result"]["amenity"]>

  export type AmenitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    image?: boolean
    description?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
  }, ExtArgs["result"]["amenity"]>

  export type AmenitySelectScalar = {
    id?: boolean
    name?: boolean
    image?: boolean
    description?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
  }

  export type AmenityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "image" | "description" | "created" | "updated" | "is_excluded", ExtArgs["result"]["amenity"]>
  export type AmenityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apartment_amenities?: boolean | Amenity$apartment_amenitiesArgs<ExtArgs>
    _count?: boolean | AmenityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AmenityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AmenityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AmenityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Amenity"
    objects: {
      apartment_amenities: Prisma.$ApartmentAmenityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      image: string
      description: string | null
      created: Date
      updated: Date
      is_excluded: boolean
    }, ExtArgs["result"]["amenity"]>
    composites: {}
  }

  type AmenityGetPayload<S extends boolean | null | undefined | AmenityDefaultArgs> = $Result.GetResult<Prisma.$AmenityPayload, S>

  type AmenityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AmenityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AmenityCountAggregateInputType | true
    }

  export interface AmenityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Amenity'], meta: { name: 'Amenity' } }
    /**
     * Find zero or one Amenity that matches the filter.
     * @param {AmenityFindUniqueArgs} args - Arguments to find a Amenity
     * @example
     * // Get one Amenity
     * const amenity = await prisma.amenity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AmenityFindUniqueArgs>(args: SelectSubset<T, AmenityFindUniqueArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Amenity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AmenityFindUniqueOrThrowArgs} args - Arguments to find a Amenity
     * @example
     * // Get one Amenity
     * const amenity = await prisma.amenity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AmenityFindUniqueOrThrowArgs>(args: SelectSubset<T, AmenityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Amenity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityFindFirstArgs} args - Arguments to find a Amenity
     * @example
     * // Get one Amenity
     * const amenity = await prisma.amenity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AmenityFindFirstArgs>(args?: SelectSubset<T, AmenityFindFirstArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Amenity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityFindFirstOrThrowArgs} args - Arguments to find a Amenity
     * @example
     * // Get one Amenity
     * const amenity = await prisma.amenity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AmenityFindFirstOrThrowArgs>(args?: SelectSubset<T, AmenityFindFirstOrThrowArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Amenities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Amenities
     * const amenities = await prisma.amenity.findMany()
     * 
     * // Get first 10 Amenities
     * const amenities = await prisma.amenity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const amenityWithIdOnly = await prisma.amenity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AmenityFindManyArgs>(args?: SelectSubset<T, AmenityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Amenity.
     * @param {AmenityCreateArgs} args - Arguments to create a Amenity.
     * @example
     * // Create one Amenity
     * const Amenity = await prisma.amenity.create({
     *   data: {
     *     // ... data to create a Amenity
     *   }
     * })
     * 
     */
    create<T extends AmenityCreateArgs>(args: SelectSubset<T, AmenityCreateArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Amenities.
     * @param {AmenityCreateManyArgs} args - Arguments to create many Amenities.
     * @example
     * // Create many Amenities
     * const amenity = await prisma.amenity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AmenityCreateManyArgs>(args?: SelectSubset<T, AmenityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Amenities and returns the data saved in the database.
     * @param {AmenityCreateManyAndReturnArgs} args - Arguments to create many Amenities.
     * @example
     * // Create many Amenities
     * const amenity = await prisma.amenity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Amenities and only return the `id`
     * const amenityWithIdOnly = await prisma.amenity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AmenityCreateManyAndReturnArgs>(args?: SelectSubset<T, AmenityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Amenity.
     * @param {AmenityDeleteArgs} args - Arguments to delete one Amenity.
     * @example
     * // Delete one Amenity
     * const Amenity = await prisma.amenity.delete({
     *   where: {
     *     // ... filter to delete one Amenity
     *   }
     * })
     * 
     */
    delete<T extends AmenityDeleteArgs>(args: SelectSubset<T, AmenityDeleteArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Amenity.
     * @param {AmenityUpdateArgs} args - Arguments to update one Amenity.
     * @example
     * // Update one Amenity
     * const amenity = await prisma.amenity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AmenityUpdateArgs>(args: SelectSubset<T, AmenityUpdateArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Amenities.
     * @param {AmenityDeleteManyArgs} args - Arguments to filter Amenities to delete.
     * @example
     * // Delete a few Amenities
     * const { count } = await prisma.amenity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AmenityDeleteManyArgs>(args?: SelectSubset<T, AmenityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Amenities
     * const amenity = await prisma.amenity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AmenityUpdateManyArgs>(args: SelectSubset<T, AmenityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Amenities and returns the data updated in the database.
     * @param {AmenityUpdateManyAndReturnArgs} args - Arguments to update many Amenities.
     * @example
     * // Update many Amenities
     * const amenity = await prisma.amenity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Amenities and only return the `id`
     * const amenityWithIdOnly = await prisma.amenity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AmenityUpdateManyAndReturnArgs>(args: SelectSubset<T, AmenityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Amenity.
     * @param {AmenityUpsertArgs} args - Arguments to update or create a Amenity.
     * @example
     * // Update or create a Amenity
     * const amenity = await prisma.amenity.upsert({
     *   create: {
     *     // ... data to create a Amenity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Amenity we want to update
     *   }
     * })
     */
    upsert<T extends AmenityUpsertArgs>(args: SelectSubset<T, AmenityUpsertArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityCountArgs} args - Arguments to filter Amenities to count.
     * @example
     * // Count the number of Amenities
     * const count = await prisma.amenity.count({
     *   where: {
     *     // ... the filter for the Amenities we want to count
     *   }
     * })
    **/
    count<T extends AmenityCountArgs>(
      args?: Subset<T, AmenityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AmenityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Amenity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AmenityAggregateArgs>(args: Subset<T, AmenityAggregateArgs>): Prisma.PrismaPromise<GetAmenityAggregateType<T>>

    /**
     * Group by Amenity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AmenityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AmenityGroupByArgs['orderBy'] }
        : { orderBy?: AmenityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AmenityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAmenityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Amenity model
   */
  readonly fields: AmenityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Amenity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AmenityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    apartment_amenities<T extends Amenity$apartment_amenitiesArgs<ExtArgs> = {}>(args?: Subset<T, Amenity$apartment_amenitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApartmentAmenityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Amenity model
   */
  interface AmenityFieldRefs {
    readonly id: FieldRef<"Amenity", 'String'>
    readonly name: FieldRef<"Amenity", 'String'>
    readonly image: FieldRef<"Amenity", 'String'>
    readonly description: FieldRef<"Amenity", 'String'>
    readonly created: FieldRef<"Amenity", 'DateTime'>
    readonly updated: FieldRef<"Amenity", 'DateTime'>
    readonly is_excluded: FieldRef<"Amenity", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Amenity findUnique
   */
  export type AmenityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter, which Amenity to fetch.
     */
    where: AmenityWhereUniqueInput
  }

  /**
   * Amenity findUniqueOrThrow
   */
  export type AmenityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter, which Amenity to fetch.
     */
    where: AmenityWhereUniqueInput
  }

  /**
   * Amenity findFirst
   */
  export type AmenityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter, which Amenity to fetch.
     */
    where?: AmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenityOrderByWithRelationInput | AmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Amenities.
     */
    cursor?: AmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Amenities.
     */
    distinct?: AmenityScalarFieldEnum | AmenityScalarFieldEnum[]
  }

  /**
   * Amenity findFirstOrThrow
   */
  export type AmenityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter, which Amenity to fetch.
     */
    where?: AmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenityOrderByWithRelationInput | AmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Amenities.
     */
    cursor?: AmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Amenities.
     */
    distinct?: AmenityScalarFieldEnum | AmenityScalarFieldEnum[]
  }

  /**
   * Amenity findMany
   */
  export type AmenityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter, which Amenities to fetch.
     */
    where?: AmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenityOrderByWithRelationInput | AmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Amenities.
     */
    cursor?: AmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    distinct?: AmenityScalarFieldEnum | AmenityScalarFieldEnum[]
  }

  /**
   * Amenity create
   */
  export type AmenityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * The data needed to create a Amenity.
     */
    data: XOR<AmenityCreateInput, AmenityUncheckedCreateInput>
  }

  /**
   * Amenity createMany
   */
  export type AmenityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Amenities.
     */
    data: AmenityCreateManyInput | AmenityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Amenity createManyAndReturn
   */
  export type AmenityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * The data used to create many Amenities.
     */
    data: AmenityCreateManyInput | AmenityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Amenity update
   */
  export type AmenityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * The data needed to update a Amenity.
     */
    data: XOR<AmenityUpdateInput, AmenityUncheckedUpdateInput>
    /**
     * Choose, which Amenity to update.
     */
    where: AmenityWhereUniqueInput
  }

  /**
   * Amenity updateMany
   */
  export type AmenityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Amenities.
     */
    data: XOR<AmenityUpdateManyMutationInput, AmenityUncheckedUpdateManyInput>
    /**
     * Filter which Amenities to update
     */
    where?: AmenityWhereInput
    /**
     * Limit how many Amenities to update.
     */
    limit?: number
  }

  /**
   * Amenity updateManyAndReturn
   */
  export type AmenityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * The data used to update Amenities.
     */
    data: XOR<AmenityUpdateManyMutationInput, AmenityUncheckedUpdateManyInput>
    /**
     * Filter which Amenities to update
     */
    where?: AmenityWhereInput
    /**
     * Limit how many Amenities to update.
     */
    limit?: number
  }

  /**
   * Amenity upsert
   */
  export type AmenityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * The filter to search for the Amenity to update in case it exists.
     */
    where: AmenityWhereUniqueInput
    /**
     * In case the Amenity found by the `where` argument doesn't exist, create a new Amenity with this data.
     */
    create: XOR<AmenityCreateInput, AmenityUncheckedCreateInput>
    /**
     * In case the Amenity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AmenityUpdateInput, AmenityUncheckedUpdateInput>
  }

  /**
   * Amenity delete
   */
  export type AmenityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter which Amenity to delete.
     */
    where: AmenityWhereUniqueInput
  }

  /**
   * Amenity deleteMany
   */
  export type AmenityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Amenities to delete
     */
    where?: AmenityWhereInput
    /**
     * Limit how many Amenities to delete.
     */
    limit?: number
  }

  /**
   * Amenity.apartment_amenities
   */
  export type Amenity$apartment_amenitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApartmentAmenity
     */
    select?: ApartmentAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApartmentAmenity
     */
    omit?: ApartmentAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentAmenityInclude<ExtArgs> | null
    where?: ApartmentAmenityWhereInput
    orderBy?: ApartmentAmenityOrderByWithRelationInput | ApartmentAmenityOrderByWithRelationInput[]
    cursor?: ApartmentAmenityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApartmentAmenityScalarFieldEnum | ApartmentAmenityScalarFieldEnum[]
  }

  /**
   * Amenity without action
   */
  export type AmenityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
  }


  /**
   * Model ApartmentAmenity
   */

  export type AggregateApartmentAmenity = {
    _count: ApartmentAmenityCountAggregateOutputType | null
    _min: ApartmentAmenityMinAggregateOutputType | null
    _max: ApartmentAmenityMaxAggregateOutputType | null
  }

  export type ApartmentAmenityMinAggregateOutputType = {
    id: string | null
    amenity_id: string | null
    apartment_id: string | null
    created: Date | null
    updated: Date | null
    is_excluded: boolean | null
  }

  export type ApartmentAmenityMaxAggregateOutputType = {
    id: string | null
    amenity_id: string | null
    apartment_id: string | null
    created: Date | null
    updated: Date | null
    is_excluded: boolean | null
  }

  export type ApartmentAmenityCountAggregateOutputType = {
    id: number
    amenity_id: number
    apartment_id: number
    created: number
    updated: number
    is_excluded: number
    _all: number
  }


  export type ApartmentAmenityMinAggregateInputType = {
    id?: true
    amenity_id?: true
    apartment_id?: true
    created?: true
    updated?: true
    is_excluded?: true
  }

  export type ApartmentAmenityMaxAggregateInputType = {
    id?: true
    amenity_id?: true
    apartment_id?: true
    created?: true
    updated?: true
    is_excluded?: true
  }

  export type ApartmentAmenityCountAggregateInputType = {
    id?: true
    amenity_id?: true
    apartment_id?: true
    created?: true
    updated?: true
    is_excluded?: true
    _all?: true
  }

  export type ApartmentAmenityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApartmentAmenity to aggregate.
     */
    where?: ApartmentAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApartmentAmenities to fetch.
     */
    orderBy?: ApartmentAmenityOrderByWithRelationInput | ApartmentAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApartmentAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApartmentAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApartmentAmenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApartmentAmenities
    **/
    _count?: true | ApartmentAmenityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApartmentAmenityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApartmentAmenityMaxAggregateInputType
  }

  export type GetApartmentAmenityAggregateType<T extends ApartmentAmenityAggregateArgs> = {
        [P in keyof T & keyof AggregateApartmentAmenity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApartmentAmenity[P]>
      : GetScalarType<T[P], AggregateApartmentAmenity[P]>
  }




  export type ApartmentAmenityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApartmentAmenityWhereInput
    orderBy?: ApartmentAmenityOrderByWithAggregationInput | ApartmentAmenityOrderByWithAggregationInput[]
    by: ApartmentAmenityScalarFieldEnum[] | ApartmentAmenityScalarFieldEnum
    having?: ApartmentAmenityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApartmentAmenityCountAggregateInputType | true
    _min?: ApartmentAmenityMinAggregateInputType
    _max?: ApartmentAmenityMaxAggregateInputType
  }

  export type ApartmentAmenityGroupByOutputType = {
    id: string
    amenity_id: string
    apartment_id: string
    created: Date
    updated: Date
    is_excluded: boolean
    _count: ApartmentAmenityCountAggregateOutputType | null
    _min: ApartmentAmenityMinAggregateOutputType | null
    _max: ApartmentAmenityMaxAggregateOutputType | null
  }

  type GetApartmentAmenityGroupByPayload<T extends ApartmentAmenityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApartmentAmenityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApartmentAmenityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApartmentAmenityGroupByOutputType[P]>
            : GetScalarType<T[P], ApartmentAmenityGroupByOutputType[P]>
        }
      >
    >


  export type ApartmentAmenitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amenity_id?: boolean
    apartment_id?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
    apartment?: boolean | ApartmentDefaultArgs<ExtArgs>
    amenity?: boolean | AmenityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apartmentAmenity"]>

  export type ApartmentAmenitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amenity_id?: boolean
    apartment_id?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
    apartment?: boolean | ApartmentDefaultArgs<ExtArgs>
    amenity?: boolean | AmenityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apartmentAmenity"]>

  export type ApartmentAmenitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amenity_id?: boolean
    apartment_id?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
    apartment?: boolean | ApartmentDefaultArgs<ExtArgs>
    amenity?: boolean | AmenityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apartmentAmenity"]>

  export type ApartmentAmenitySelectScalar = {
    id?: boolean
    amenity_id?: boolean
    apartment_id?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
  }

  export type ApartmentAmenityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amenity_id" | "apartment_id" | "created" | "updated" | "is_excluded", ExtArgs["result"]["apartmentAmenity"]>
  export type ApartmentAmenityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apartment?: boolean | ApartmentDefaultArgs<ExtArgs>
    amenity?: boolean | AmenityDefaultArgs<ExtArgs>
  }
  export type ApartmentAmenityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apartment?: boolean | ApartmentDefaultArgs<ExtArgs>
    amenity?: boolean | AmenityDefaultArgs<ExtArgs>
  }
  export type ApartmentAmenityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apartment?: boolean | ApartmentDefaultArgs<ExtArgs>
    amenity?: boolean | AmenityDefaultArgs<ExtArgs>
  }

  export type $ApartmentAmenityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApartmentAmenity"
    objects: {
      apartment: Prisma.$ApartmentPayload<ExtArgs>
      amenity: Prisma.$AmenityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      amenity_id: string
      apartment_id: string
      created: Date
      updated: Date
      is_excluded: boolean
    }, ExtArgs["result"]["apartmentAmenity"]>
    composites: {}
  }

  type ApartmentAmenityGetPayload<S extends boolean | null | undefined | ApartmentAmenityDefaultArgs> = $Result.GetResult<Prisma.$ApartmentAmenityPayload, S>

  type ApartmentAmenityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApartmentAmenityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApartmentAmenityCountAggregateInputType | true
    }

  export interface ApartmentAmenityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApartmentAmenity'], meta: { name: 'ApartmentAmenity' } }
    /**
     * Find zero or one ApartmentAmenity that matches the filter.
     * @param {ApartmentAmenityFindUniqueArgs} args - Arguments to find a ApartmentAmenity
     * @example
     * // Get one ApartmentAmenity
     * const apartmentAmenity = await prisma.apartmentAmenity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApartmentAmenityFindUniqueArgs>(args: SelectSubset<T, ApartmentAmenityFindUniqueArgs<ExtArgs>>): Prisma__ApartmentAmenityClient<$Result.GetResult<Prisma.$ApartmentAmenityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ApartmentAmenity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApartmentAmenityFindUniqueOrThrowArgs} args - Arguments to find a ApartmentAmenity
     * @example
     * // Get one ApartmentAmenity
     * const apartmentAmenity = await prisma.apartmentAmenity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApartmentAmenityFindUniqueOrThrowArgs>(args: SelectSubset<T, ApartmentAmenityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApartmentAmenityClient<$Result.GetResult<Prisma.$ApartmentAmenityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApartmentAmenity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApartmentAmenityFindFirstArgs} args - Arguments to find a ApartmentAmenity
     * @example
     * // Get one ApartmentAmenity
     * const apartmentAmenity = await prisma.apartmentAmenity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApartmentAmenityFindFirstArgs>(args?: SelectSubset<T, ApartmentAmenityFindFirstArgs<ExtArgs>>): Prisma__ApartmentAmenityClient<$Result.GetResult<Prisma.$ApartmentAmenityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApartmentAmenity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApartmentAmenityFindFirstOrThrowArgs} args - Arguments to find a ApartmentAmenity
     * @example
     * // Get one ApartmentAmenity
     * const apartmentAmenity = await prisma.apartmentAmenity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApartmentAmenityFindFirstOrThrowArgs>(args?: SelectSubset<T, ApartmentAmenityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApartmentAmenityClient<$Result.GetResult<Prisma.$ApartmentAmenityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ApartmentAmenities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApartmentAmenityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApartmentAmenities
     * const apartmentAmenities = await prisma.apartmentAmenity.findMany()
     * 
     * // Get first 10 ApartmentAmenities
     * const apartmentAmenities = await prisma.apartmentAmenity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apartmentAmenityWithIdOnly = await prisma.apartmentAmenity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApartmentAmenityFindManyArgs>(args?: SelectSubset<T, ApartmentAmenityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApartmentAmenityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ApartmentAmenity.
     * @param {ApartmentAmenityCreateArgs} args - Arguments to create a ApartmentAmenity.
     * @example
     * // Create one ApartmentAmenity
     * const ApartmentAmenity = await prisma.apartmentAmenity.create({
     *   data: {
     *     // ... data to create a ApartmentAmenity
     *   }
     * })
     * 
     */
    create<T extends ApartmentAmenityCreateArgs>(args: SelectSubset<T, ApartmentAmenityCreateArgs<ExtArgs>>): Prisma__ApartmentAmenityClient<$Result.GetResult<Prisma.$ApartmentAmenityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ApartmentAmenities.
     * @param {ApartmentAmenityCreateManyArgs} args - Arguments to create many ApartmentAmenities.
     * @example
     * // Create many ApartmentAmenities
     * const apartmentAmenity = await prisma.apartmentAmenity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApartmentAmenityCreateManyArgs>(args?: SelectSubset<T, ApartmentAmenityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApartmentAmenities and returns the data saved in the database.
     * @param {ApartmentAmenityCreateManyAndReturnArgs} args - Arguments to create many ApartmentAmenities.
     * @example
     * // Create many ApartmentAmenities
     * const apartmentAmenity = await prisma.apartmentAmenity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApartmentAmenities and only return the `id`
     * const apartmentAmenityWithIdOnly = await prisma.apartmentAmenity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApartmentAmenityCreateManyAndReturnArgs>(args?: SelectSubset<T, ApartmentAmenityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApartmentAmenityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ApartmentAmenity.
     * @param {ApartmentAmenityDeleteArgs} args - Arguments to delete one ApartmentAmenity.
     * @example
     * // Delete one ApartmentAmenity
     * const ApartmentAmenity = await prisma.apartmentAmenity.delete({
     *   where: {
     *     // ... filter to delete one ApartmentAmenity
     *   }
     * })
     * 
     */
    delete<T extends ApartmentAmenityDeleteArgs>(args: SelectSubset<T, ApartmentAmenityDeleteArgs<ExtArgs>>): Prisma__ApartmentAmenityClient<$Result.GetResult<Prisma.$ApartmentAmenityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ApartmentAmenity.
     * @param {ApartmentAmenityUpdateArgs} args - Arguments to update one ApartmentAmenity.
     * @example
     * // Update one ApartmentAmenity
     * const apartmentAmenity = await prisma.apartmentAmenity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApartmentAmenityUpdateArgs>(args: SelectSubset<T, ApartmentAmenityUpdateArgs<ExtArgs>>): Prisma__ApartmentAmenityClient<$Result.GetResult<Prisma.$ApartmentAmenityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ApartmentAmenities.
     * @param {ApartmentAmenityDeleteManyArgs} args - Arguments to filter ApartmentAmenities to delete.
     * @example
     * // Delete a few ApartmentAmenities
     * const { count } = await prisma.apartmentAmenity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApartmentAmenityDeleteManyArgs>(args?: SelectSubset<T, ApartmentAmenityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApartmentAmenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApartmentAmenityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApartmentAmenities
     * const apartmentAmenity = await prisma.apartmentAmenity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApartmentAmenityUpdateManyArgs>(args: SelectSubset<T, ApartmentAmenityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApartmentAmenities and returns the data updated in the database.
     * @param {ApartmentAmenityUpdateManyAndReturnArgs} args - Arguments to update many ApartmentAmenities.
     * @example
     * // Update many ApartmentAmenities
     * const apartmentAmenity = await prisma.apartmentAmenity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ApartmentAmenities and only return the `id`
     * const apartmentAmenityWithIdOnly = await prisma.apartmentAmenity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApartmentAmenityUpdateManyAndReturnArgs>(args: SelectSubset<T, ApartmentAmenityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApartmentAmenityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ApartmentAmenity.
     * @param {ApartmentAmenityUpsertArgs} args - Arguments to update or create a ApartmentAmenity.
     * @example
     * // Update or create a ApartmentAmenity
     * const apartmentAmenity = await prisma.apartmentAmenity.upsert({
     *   create: {
     *     // ... data to create a ApartmentAmenity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApartmentAmenity we want to update
     *   }
     * })
     */
    upsert<T extends ApartmentAmenityUpsertArgs>(args: SelectSubset<T, ApartmentAmenityUpsertArgs<ExtArgs>>): Prisma__ApartmentAmenityClient<$Result.GetResult<Prisma.$ApartmentAmenityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ApartmentAmenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApartmentAmenityCountArgs} args - Arguments to filter ApartmentAmenities to count.
     * @example
     * // Count the number of ApartmentAmenities
     * const count = await prisma.apartmentAmenity.count({
     *   where: {
     *     // ... the filter for the ApartmentAmenities we want to count
     *   }
     * })
    **/
    count<T extends ApartmentAmenityCountArgs>(
      args?: Subset<T, ApartmentAmenityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApartmentAmenityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApartmentAmenity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApartmentAmenityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApartmentAmenityAggregateArgs>(args: Subset<T, ApartmentAmenityAggregateArgs>): Prisma.PrismaPromise<GetApartmentAmenityAggregateType<T>>

    /**
     * Group by ApartmentAmenity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApartmentAmenityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApartmentAmenityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApartmentAmenityGroupByArgs['orderBy'] }
        : { orderBy?: ApartmentAmenityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApartmentAmenityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApartmentAmenityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApartmentAmenity model
   */
  readonly fields: ApartmentAmenityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApartmentAmenity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApartmentAmenityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    apartment<T extends ApartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApartmentDefaultArgs<ExtArgs>>): Prisma__ApartmentClient<$Result.GetResult<Prisma.$ApartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    amenity<T extends AmenityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AmenityDefaultArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApartmentAmenity model
   */
  interface ApartmentAmenityFieldRefs {
    readonly id: FieldRef<"ApartmentAmenity", 'String'>
    readonly amenity_id: FieldRef<"ApartmentAmenity", 'String'>
    readonly apartment_id: FieldRef<"ApartmentAmenity", 'String'>
    readonly created: FieldRef<"ApartmentAmenity", 'DateTime'>
    readonly updated: FieldRef<"ApartmentAmenity", 'DateTime'>
    readonly is_excluded: FieldRef<"ApartmentAmenity", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ApartmentAmenity findUnique
   */
  export type ApartmentAmenityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApartmentAmenity
     */
    select?: ApartmentAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApartmentAmenity
     */
    omit?: ApartmentAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentAmenityInclude<ExtArgs> | null
    /**
     * Filter, which ApartmentAmenity to fetch.
     */
    where: ApartmentAmenityWhereUniqueInput
  }

  /**
   * ApartmentAmenity findUniqueOrThrow
   */
  export type ApartmentAmenityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApartmentAmenity
     */
    select?: ApartmentAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApartmentAmenity
     */
    omit?: ApartmentAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentAmenityInclude<ExtArgs> | null
    /**
     * Filter, which ApartmentAmenity to fetch.
     */
    where: ApartmentAmenityWhereUniqueInput
  }

  /**
   * ApartmentAmenity findFirst
   */
  export type ApartmentAmenityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApartmentAmenity
     */
    select?: ApartmentAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApartmentAmenity
     */
    omit?: ApartmentAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentAmenityInclude<ExtArgs> | null
    /**
     * Filter, which ApartmentAmenity to fetch.
     */
    where?: ApartmentAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApartmentAmenities to fetch.
     */
    orderBy?: ApartmentAmenityOrderByWithRelationInput | ApartmentAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApartmentAmenities.
     */
    cursor?: ApartmentAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApartmentAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApartmentAmenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApartmentAmenities.
     */
    distinct?: ApartmentAmenityScalarFieldEnum | ApartmentAmenityScalarFieldEnum[]
  }

  /**
   * ApartmentAmenity findFirstOrThrow
   */
  export type ApartmentAmenityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApartmentAmenity
     */
    select?: ApartmentAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApartmentAmenity
     */
    omit?: ApartmentAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentAmenityInclude<ExtArgs> | null
    /**
     * Filter, which ApartmentAmenity to fetch.
     */
    where?: ApartmentAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApartmentAmenities to fetch.
     */
    orderBy?: ApartmentAmenityOrderByWithRelationInput | ApartmentAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApartmentAmenities.
     */
    cursor?: ApartmentAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApartmentAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApartmentAmenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApartmentAmenities.
     */
    distinct?: ApartmentAmenityScalarFieldEnum | ApartmentAmenityScalarFieldEnum[]
  }

  /**
   * ApartmentAmenity findMany
   */
  export type ApartmentAmenityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApartmentAmenity
     */
    select?: ApartmentAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApartmentAmenity
     */
    omit?: ApartmentAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentAmenityInclude<ExtArgs> | null
    /**
     * Filter, which ApartmentAmenities to fetch.
     */
    where?: ApartmentAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApartmentAmenities to fetch.
     */
    orderBy?: ApartmentAmenityOrderByWithRelationInput | ApartmentAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApartmentAmenities.
     */
    cursor?: ApartmentAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApartmentAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApartmentAmenities.
     */
    skip?: number
    distinct?: ApartmentAmenityScalarFieldEnum | ApartmentAmenityScalarFieldEnum[]
  }

  /**
   * ApartmentAmenity create
   */
  export type ApartmentAmenityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApartmentAmenity
     */
    select?: ApartmentAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApartmentAmenity
     */
    omit?: ApartmentAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentAmenityInclude<ExtArgs> | null
    /**
     * The data needed to create a ApartmentAmenity.
     */
    data: XOR<ApartmentAmenityCreateInput, ApartmentAmenityUncheckedCreateInput>
  }

  /**
   * ApartmentAmenity createMany
   */
  export type ApartmentAmenityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApartmentAmenities.
     */
    data: ApartmentAmenityCreateManyInput | ApartmentAmenityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApartmentAmenity createManyAndReturn
   */
  export type ApartmentAmenityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApartmentAmenity
     */
    select?: ApartmentAmenitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApartmentAmenity
     */
    omit?: ApartmentAmenityOmit<ExtArgs> | null
    /**
     * The data used to create many ApartmentAmenities.
     */
    data: ApartmentAmenityCreateManyInput | ApartmentAmenityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentAmenityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApartmentAmenity update
   */
  export type ApartmentAmenityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApartmentAmenity
     */
    select?: ApartmentAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApartmentAmenity
     */
    omit?: ApartmentAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentAmenityInclude<ExtArgs> | null
    /**
     * The data needed to update a ApartmentAmenity.
     */
    data: XOR<ApartmentAmenityUpdateInput, ApartmentAmenityUncheckedUpdateInput>
    /**
     * Choose, which ApartmentAmenity to update.
     */
    where: ApartmentAmenityWhereUniqueInput
  }

  /**
   * ApartmentAmenity updateMany
   */
  export type ApartmentAmenityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApartmentAmenities.
     */
    data: XOR<ApartmentAmenityUpdateManyMutationInput, ApartmentAmenityUncheckedUpdateManyInput>
    /**
     * Filter which ApartmentAmenities to update
     */
    where?: ApartmentAmenityWhereInput
    /**
     * Limit how many ApartmentAmenities to update.
     */
    limit?: number
  }

  /**
   * ApartmentAmenity updateManyAndReturn
   */
  export type ApartmentAmenityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApartmentAmenity
     */
    select?: ApartmentAmenitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApartmentAmenity
     */
    omit?: ApartmentAmenityOmit<ExtArgs> | null
    /**
     * The data used to update ApartmentAmenities.
     */
    data: XOR<ApartmentAmenityUpdateManyMutationInput, ApartmentAmenityUncheckedUpdateManyInput>
    /**
     * Filter which ApartmentAmenities to update
     */
    where?: ApartmentAmenityWhereInput
    /**
     * Limit how many ApartmentAmenities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentAmenityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApartmentAmenity upsert
   */
  export type ApartmentAmenityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApartmentAmenity
     */
    select?: ApartmentAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApartmentAmenity
     */
    omit?: ApartmentAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentAmenityInclude<ExtArgs> | null
    /**
     * The filter to search for the ApartmentAmenity to update in case it exists.
     */
    where: ApartmentAmenityWhereUniqueInput
    /**
     * In case the ApartmentAmenity found by the `where` argument doesn't exist, create a new ApartmentAmenity with this data.
     */
    create: XOR<ApartmentAmenityCreateInput, ApartmentAmenityUncheckedCreateInput>
    /**
     * In case the ApartmentAmenity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApartmentAmenityUpdateInput, ApartmentAmenityUncheckedUpdateInput>
  }

  /**
   * ApartmentAmenity delete
   */
  export type ApartmentAmenityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApartmentAmenity
     */
    select?: ApartmentAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApartmentAmenity
     */
    omit?: ApartmentAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentAmenityInclude<ExtArgs> | null
    /**
     * Filter which ApartmentAmenity to delete.
     */
    where: ApartmentAmenityWhereUniqueInput
  }

  /**
   * ApartmentAmenity deleteMany
   */
  export type ApartmentAmenityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApartmentAmenities to delete
     */
    where?: ApartmentAmenityWhereInput
    /**
     * Limit how many ApartmentAmenities to delete.
     */
    limit?: number
  }

  /**
   * ApartmentAmenity without action
   */
  export type ApartmentAmenityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApartmentAmenity
     */
    select?: ApartmentAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApartmentAmenity
     */
    omit?: ApartmentAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentAmenityInclude<ExtArgs> | null
  }


  /**
   * Model ApartmentImage
   */

  export type AggregateApartmentImage = {
    _count: ApartmentImageCountAggregateOutputType | null
    _min: ApartmentImageMinAggregateOutputType | null
    _max: ApartmentImageMaxAggregateOutputType | null
  }

  export type ApartmentImageMinAggregateOutputType = {
    id: string | null
    image: string | null
    name: string | null
    description: string | null
    apartment_id: string | null
    created: Date | null
    updated: Date | null
    is_excluded: boolean | null
  }

  export type ApartmentImageMaxAggregateOutputType = {
    id: string | null
    image: string | null
    name: string | null
    description: string | null
    apartment_id: string | null
    created: Date | null
    updated: Date | null
    is_excluded: boolean | null
  }

  export type ApartmentImageCountAggregateOutputType = {
    id: number
    image: number
    name: number
    description: number
    apartment_id: number
    created: number
    updated: number
    is_excluded: number
    _all: number
  }


  export type ApartmentImageMinAggregateInputType = {
    id?: true
    image?: true
    name?: true
    description?: true
    apartment_id?: true
    created?: true
    updated?: true
    is_excluded?: true
  }

  export type ApartmentImageMaxAggregateInputType = {
    id?: true
    image?: true
    name?: true
    description?: true
    apartment_id?: true
    created?: true
    updated?: true
    is_excluded?: true
  }

  export type ApartmentImageCountAggregateInputType = {
    id?: true
    image?: true
    name?: true
    description?: true
    apartment_id?: true
    created?: true
    updated?: true
    is_excluded?: true
    _all?: true
  }

  export type ApartmentImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApartmentImage to aggregate.
     */
    where?: ApartmentImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApartmentImages to fetch.
     */
    orderBy?: ApartmentImageOrderByWithRelationInput | ApartmentImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApartmentImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApartmentImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApartmentImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApartmentImages
    **/
    _count?: true | ApartmentImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApartmentImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApartmentImageMaxAggregateInputType
  }

  export type GetApartmentImageAggregateType<T extends ApartmentImageAggregateArgs> = {
        [P in keyof T & keyof AggregateApartmentImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApartmentImage[P]>
      : GetScalarType<T[P], AggregateApartmentImage[P]>
  }




  export type ApartmentImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApartmentImageWhereInput
    orderBy?: ApartmentImageOrderByWithAggregationInput | ApartmentImageOrderByWithAggregationInput[]
    by: ApartmentImageScalarFieldEnum[] | ApartmentImageScalarFieldEnum
    having?: ApartmentImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApartmentImageCountAggregateInputType | true
    _min?: ApartmentImageMinAggregateInputType
    _max?: ApartmentImageMaxAggregateInputType
  }

  export type ApartmentImageGroupByOutputType = {
    id: string
    image: string
    name: string | null
    description: string | null
    apartment_id: string
    created: Date
    updated: Date
    is_excluded: boolean
    _count: ApartmentImageCountAggregateOutputType | null
    _min: ApartmentImageMinAggregateOutputType | null
    _max: ApartmentImageMaxAggregateOutputType | null
  }

  type GetApartmentImageGroupByPayload<T extends ApartmentImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApartmentImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApartmentImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApartmentImageGroupByOutputType[P]>
            : GetScalarType<T[P], ApartmentImageGroupByOutputType[P]>
        }
      >
    >


  export type ApartmentImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    image?: boolean
    name?: boolean
    description?: boolean
    apartment_id?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
    apartment?: boolean | ApartmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apartmentImage"]>

  export type ApartmentImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    image?: boolean
    name?: boolean
    description?: boolean
    apartment_id?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
    apartment?: boolean | ApartmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apartmentImage"]>

  export type ApartmentImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    image?: boolean
    name?: boolean
    description?: boolean
    apartment_id?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
    apartment?: boolean | ApartmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apartmentImage"]>

  export type ApartmentImageSelectScalar = {
    id?: boolean
    image?: boolean
    name?: boolean
    description?: boolean
    apartment_id?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
  }

  export type ApartmentImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "image" | "name" | "description" | "apartment_id" | "created" | "updated" | "is_excluded", ExtArgs["result"]["apartmentImage"]>
  export type ApartmentImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apartment?: boolean | ApartmentDefaultArgs<ExtArgs>
  }
  export type ApartmentImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apartment?: boolean | ApartmentDefaultArgs<ExtArgs>
  }
  export type ApartmentImageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apartment?: boolean | ApartmentDefaultArgs<ExtArgs>
  }

  export type $ApartmentImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApartmentImage"
    objects: {
      apartment: Prisma.$ApartmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      image: string
      name: string | null
      description: string | null
      apartment_id: string
      created: Date
      updated: Date
      is_excluded: boolean
    }, ExtArgs["result"]["apartmentImage"]>
    composites: {}
  }

  type ApartmentImageGetPayload<S extends boolean | null | undefined | ApartmentImageDefaultArgs> = $Result.GetResult<Prisma.$ApartmentImagePayload, S>

  type ApartmentImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApartmentImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApartmentImageCountAggregateInputType | true
    }

  export interface ApartmentImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApartmentImage'], meta: { name: 'ApartmentImage' } }
    /**
     * Find zero or one ApartmentImage that matches the filter.
     * @param {ApartmentImageFindUniqueArgs} args - Arguments to find a ApartmentImage
     * @example
     * // Get one ApartmentImage
     * const apartmentImage = await prisma.apartmentImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApartmentImageFindUniqueArgs>(args: SelectSubset<T, ApartmentImageFindUniqueArgs<ExtArgs>>): Prisma__ApartmentImageClient<$Result.GetResult<Prisma.$ApartmentImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ApartmentImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApartmentImageFindUniqueOrThrowArgs} args - Arguments to find a ApartmentImage
     * @example
     * // Get one ApartmentImage
     * const apartmentImage = await prisma.apartmentImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApartmentImageFindUniqueOrThrowArgs>(args: SelectSubset<T, ApartmentImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApartmentImageClient<$Result.GetResult<Prisma.$ApartmentImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApartmentImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApartmentImageFindFirstArgs} args - Arguments to find a ApartmentImage
     * @example
     * // Get one ApartmentImage
     * const apartmentImage = await prisma.apartmentImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApartmentImageFindFirstArgs>(args?: SelectSubset<T, ApartmentImageFindFirstArgs<ExtArgs>>): Prisma__ApartmentImageClient<$Result.GetResult<Prisma.$ApartmentImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApartmentImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApartmentImageFindFirstOrThrowArgs} args - Arguments to find a ApartmentImage
     * @example
     * // Get one ApartmentImage
     * const apartmentImage = await prisma.apartmentImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApartmentImageFindFirstOrThrowArgs>(args?: SelectSubset<T, ApartmentImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApartmentImageClient<$Result.GetResult<Prisma.$ApartmentImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ApartmentImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApartmentImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApartmentImages
     * const apartmentImages = await prisma.apartmentImage.findMany()
     * 
     * // Get first 10 ApartmentImages
     * const apartmentImages = await prisma.apartmentImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apartmentImageWithIdOnly = await prisma.apartmentImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApartmentImageFindManyArgs>(args?: SelectSubset<T, ApartmentImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApartmentImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ApartmentImage.
     * @param {ApartmentImageCreateArgs} args - Arguments to create a ApartmentImage.
     * @example
     * // Create one ApartmentImage
     * const ApartmentImage = await prisma.apartmentImage.create({
     *   data: {
     *     // ... data to create a ApartmentImage
     *   }
     * })
     * 
     */
    create<T extends ApartmentImageCreateArgs>(args: SelectSubset<T, ApartmentImageCreateArgs<ExtArgs>>): Prisma__ApartmentImageClient<$Result.GetResult<Prisma.$ApartmentImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ApartmentImages.
     * @param {ApartmentImageCreateManyArgs} args - Arguments to create many ApartmentImages.
     * @example
     * // Create many ApartmentImages
     * const apartmentImage = await prisma.apartmentImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApartmentImageCreateManyArgs>(args?: SelectSubset<T, ApartmentImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApartmentImages and returns the data saved in the database.
     * @param {ApartmentImageCreateManyAndReturnArgs} args - Arguments to create many ApartmentImages.
     * @example
     * // Create many ApartmentImages
     * const apartmentImage = await prisma.apartmentImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApartmentImages and only return the `id`
     * const apartmentImageWithIdOnly = await prisma.apartmentImage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApartmentImageCreateManyAndReturnArgs>(args?: SelectSubset<T, ApartmentImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApartmentImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ApartmentImage.
     * @param {ApartmentImageDeleteArgs} args - Arguments to delete one ApartmentImage.
     * @example
     * // Delete one ApartmentImage
     * const ApartmentImage = await prisma.apartmentImage.delete({
     *   where: {
     *     // ... filter to delete one ApartmentImage
     *   }
     * })
     * 
     */
    delete<T extends ApartmentImageDeleteArgs>(args: SelectSubset<T, ApartmentImageDeleteArgs<ExtArgs>>): Prisma__ApartmentImageClient<$Result.GetResult<Prisma.$ApartmentImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ApartmentImage.
     * @param {ApartmentImageUpdateArgs} args - Arguments to update one ApartmentImage.
     * @example
     * // Update one ApartmentImage
     * const apartmentImage = await prisma.apartmentImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApartmentImageUpdateArgs>(args: SelectSubset<T, ApartmentImageUpdateArgs<ExtArgs>>): Prisma__ApartmentImageClient<$Result.GetResult<Prisma.$ApartmentImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ApartmentImages.
     * @param {ApartmentImageDeleteManyArgs} args - Arguments to filter ApartmentImages to delete.
     * @example
     * // Delete a few ApartmentImages
     * const { count } = await prisma.apartmentImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApartmentImageDeleteManyArgs>(args?: SelectSubset<T, ApartmentImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApartmentImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApartmentImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApartmentImages
     * const apartmentImage = await prisma.apartmentImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApartmentImageUpdateManyArgs>(args: SelectSubset<T, ApartmentImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApartmentImages and returns the data updated in the database.
     * @param {ApartmentImageUpdateManyAndReturnArgs} args - Arguments to update many ApartmentImages.
     * @example
     * // Update many ApartmentImages
     * const apartmentImage = await prisma.apartmentImage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ApartmentImages and only return the `id`
     * const apartmentImageWithIdOnly = await prisma.apartmentImage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApartmentImageUpdateManyAndReturnArgs>(args: SelectSubset<T, ApartmentImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApartmentImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ApartmentImage.
     * @param {ApartmentImageUpsertArgs} args - Arguments to update or create a ApartmentImage.
     * @example
     * // Update or create a ApartmentImage
     * const apartmentImage = await prisma.apartmentImage.upsert({
     *   create: {
     *     // ... data to create a ApartmentImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApartmentImage we want to update
     *   }
     * })
     */
    upsert<T extends ApartmentImageUpsertArgs>(args: SelectSubset<T, ApartmentImageUpsertArgs<ExtArgs>>): Prisma__ApartmentImageClient<$Result.GetResult<Prisma.$ApartmentImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ApartmentImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApartmentImageCountArgs} args - Arguments to filter ApartmentImages to count.
     * @example
     * // Count the number of ApartmentImages
     * const count = await prisma.apartmentImage.count({
     *   where: {
     *     // ... the filter for the ApartmentImages we want to count
     *   }
     * })
    **/
    count<T extends ApartmentImageCountArgs>(
      args?: Subset<T, ApartmentImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApartmentImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApartmentImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApartmentImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApartmentImageAggregateArgs>(args: Subset<T, ApartmentImageAggregateArgs>): Prisma.PrismaPromise<GetApartmentImageAggregateType<T>>

    /**
     * Group by ApartmentImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApartmentImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApartmentImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApartmentImageGroupByArgs['orderBy'] }
        : { orderBy?: ApartmentImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApartmentImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApartmentImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApartmentImage model
   */
  readonly fields: ApartmentImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApartmentImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApartmentImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    apartment<T extends ApartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApartmentDefaultArgs<ExtArgs>>): Prisma__ApartmentClient<$Result.GetResult<Prisma.$ApartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApartmentImage model
   */
  interface ApartmentImageFieldRefs {
    readonly id: FieldRef<"ApartmentImage", 'String'>
    readonly image: FieldRef<"ApartmentImage", 'String'>
    readonly name: FieldRef<"ApartmentImage", 'String'>
    readonly description: FieldRef<"ApartmentImage", 'String'>
    readonly apartment_id: FieldRef<"ApartmentImage", 'String'>
    readonly created: FieldRef<"ApartmentImage", 'DateTime'>
    readonly updated: FieldRef<"ApartmentImage", 'DateTime'>
    readonly is_excluded: FieldRef<"ApartmentImage", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ApartmentImage findUnique
   */
  export type ApartmentImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApartmentImage
     */
    select?: ApartmentImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApartmentImage
     */
    omit?: ApartmentImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentImageInclude<ExtArgs> | null
    /**
     * Filter, which ApartmentImage to fetch.
     */
    where: ApartmentImageWhereUniqueInput
  }

  /**
   * ApartmentImage findUniqueOrThrow
   */
  export type ApartmentImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApartmentImage
     */
    select?: ApartmentImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApartmentImage
     */
    omit?: ApartmentImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentImageInclude<ExtArgs> | null
    /**
     * Filter, which ApartmentImage to fetch.
     */
    where: ApartmentImageWhereUniqueInput
  }

  /**
   * ApartmentImage findFirst
   */
  export type ApartmentImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApartmentImage
     */
    select?: ApartmentImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApartmentImage
     */
    omit?: ApartmentImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentImageInclude<ExtArgs> | null
    /**
     * Filter, which ApartmentImage to fetch.
     */
    where?: ApartmentImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApartmentImages to fetch.
     */
    orderBy?: ApartmentImageOrderByWithRelationInput | ApartmentImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApartmentImages.
     */
    cursor?: ApartmentImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApartmentImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApartmentImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApartmentImages.
     */
    distinct?: ApartmentImageScalarFieldEnum | ApartmentImageScalarFieldEnum[]
  }

  /**
   * ApartmentImage findFirstOrThrow
   */
  export type ApartmentImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApartmentImage
     */
    select?: ApartmentImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApartmentImage
     */
    omit?: ApartmentImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentImageInclude<ExtArgs> | null
    /**
     * Filter, which ApartmentImage to fetch.
     */
    where?: ApartmentImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApartmentImages to fetch.
     */
    orderBy?: ApartmentImageOrderByWithRelationInput | ApartmentImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApartmentImages.
     */
    cursor?: ApartmentImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApartmentImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApartmentImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApartmentImages.
     */
    distinct?: ApartmentImageScalarFieldEnum | ApartmentImageScalarFieldEnum[]
  }

  /**
   * ApartmentImage findMany
   */
  export type ApartmentImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApartmentImage
     */
    select?: ApartmentImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApartmentImage
     */
    omit?: ApartmentImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentImageInclude<ExtArgs> | null
    /**
     * Filter, which ApartmentImages to fetch.
     */
    where?: ApartmentImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApartmentImages to fetch.
     */
    orderBy?: ApartmentImageOrderByWithRelationInput | ApartmentImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApartmentImages.
     */
    cursor?: ApartmentImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApartmentImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApartmentImages.
     */
    skip?: number
    distinct?: ApartmentImageScalarFieldEnum | ApartmentImageScalarFieldEnum[]
  }

  /**
   * ApartmentImage create
   */
  export type ApartmentImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApartmentImage
     */
    select?: ApartmentImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApartmentImage
     */
    omit?: ApartmentImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentImageInclude<ExtArgs> | null
    /**
     * The data needed to create a ApartmentImage.
     */
    data: XOR<ApartmentImageCreateInput, ApartmentImageUncheckedCreateInput>
  }

  /**
   * ApartmentImage createMany
   */
  export type ApartmentImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApartmentImages.
     */
    data: ApartmentImageCreateManyInput | ApartmentImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApartmentImage createManyAndReturn
   */
  export type ApartmentImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApartmentImage
     */
    select?: ApartmentImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApartmentImage
     */
    omit?: ApartmentImageOmit<ExtArgs> | null
    /**
     * The data used to create many ApartmentImages.
     */
    data: ApartmentImageCreateManyInput | ApartmentImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApartmentImage update
   */
  export type ApartmentImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApartmentImage
     */
    select?: ApartmentImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApartmentImage
     */
    omit?: ApartmentImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentImageInclude<ExtArgs> | null
    /**
     * The data needed to update a ApartmentImage.
     */
    data: XOR<ApartmentImageUpdateInput, ApartmentImageUncheckedUpdateInput>
    /**
     * Choose, which ApartmentImage to update.
     */
    where: ApartmentImageWhereUniqueInput
  }

  /**
   * ApartmentImage updateMany
   */
  export type ApartmentImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApartmentImages.
     */
    data: XOR<ApartmentImageUpdateManyMutationInput, ApartmentImageUncheckedUpdateManyInput>
    /**
     * Filter which ApartmentImages to update
     */
    where?: ApartmentImageWhereInput
    /**
     * Limit how many ApartmentImages to update.
     */
    limit?: number
  }

  /**
   * ApartmentImage updateManyAndReturn
   */
  export type ApartmentImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApartmentImage
     */
    select?: ApartmentImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApartmentImage
     */
    omit?: ApartmentImageOmit<ExtArgs> | null
    /**
     * The data used to update ApartmentImages.
     */
    data: XOR<ApartmentImageUpdateManyMutationInput, ApartmentImageUncheckedUpdateManyInput>
    /**
     * Filter which ApartmentImages to update
     */
    where?: ApartmentImageWhereInput
    /**
     * Limit how many ApartmentImages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentImageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApartmentImage upsert
   */
  export type ApartmentImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApartmentImage
     */
    select?: ApartmentImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApartmentImage
     */
    omit?: ApartmentImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentImageInclude<ExtArgs> | null
    /**
     * The filter to search for the ApartmentImage to update in case it exists.
     */
    where: ApartmentImageWhereUniqueInput
    /**
     * In case the ApartmentImage found by the `where` argument doesn't exist, create a new ApartmentImage with this data.
     */
    create: XOR<ApartmentImageCreateInput, ApartmentImageUncheckedCreateInput>
    /**
     * In case the ApartmentImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApartmentImageUpdateInput, ApartmentImageUncheckedUpdateInput>
  }

  /**
   * ApartmentImage delete
   */
  export type ApartmentImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApartmentImage
     */
    select?: ApartmentImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApartmentImage
     */
    omit?: ApartmentImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentImageInclude<ExtArgs> | null
    /**
     * Filter which ApartmentImage to delete.
     */
    where: ApartmentImageWhereUniqueInput
  }

  /**
   * ApartmentImage deleteMany
   */
  export type ApartmentImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApartmentImages to delete
     */
    where?: ApartmentImageWhereInput
    /**
     * Limit how many ApartmentImages to delete.
     */
    limit?: number
  }

  /**
   * ApartmentImage without action
   */
  export type ApartmentImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApartmentImage
     */
    select?: ApartmentImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApartmentImage
     */
    omit?: ApartmentImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentImageInclude<ExtArgs> | null
  }


  /**
   * Model BedType
   */

  export type AggregateBedType = {
    _count: BedTypeCountAggregateOutputType | null
    _min: BedTypeMinAggregateOutputType | null
    _max: BedTypeMaxAggregateOutputType | null
  }

  export type BedTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    image: string | null
    created: Date | null
    updated: Date | null
    is_excluded: boolean | null
  }

  export type BedTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    image: string | null
    created: Date | null
    updated: Date | null
    is_excluded: boolean | null
  }

  export type BedTypeCountAggregateOutputType = {
    id: number
    name: number
    image: number
    created: number
    updated: number
    is_excluded: number
    _all: number
  }


  export type BedTypeMinAggregateInputType = {
    id?: true
    name?: true
    image?: true
    created?: true
    updated?: true
    is_excluded?: true
  }

  export type BedTypeMaxAggregateInputType = {
    id?: true
    name?: true
    image?: true
    created?: true
    updated?: true
    is_excluded?: true
  }

  export type BedTypeCountAggregateInputType = {
    id?: true
    name?: true
    image?: true
    created?: true
    updated?: true
    is_excluded?: true
    _all?: true
  }

  export type BedTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BedType to aggregate.
     */
    where?: BedTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BedTypes to fetch.
     */
    orderBy?: BedTypeOrderByWithRelationInput | BedTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BedTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BedTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BedTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BedTypes
    **/
    _count?: true | BedTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BedTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BedTypeMaxAggregateInputType
  }

  export type GetBedTypeAggregateType<T extends BedTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateBedType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBedType[P]>
      : GetScalarType<T[P], AggregateBedType[P]>
  }




  export type BedTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BedTypeWhereInput
    orderBy?: BedTypeOrderByWithAggregationInput | BedTypeOrderByWithAggregationInput[]
    by: BedTypeScalarFieldEnum[] | BedTypeScalarFieldEnum
    having?: BedTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BedTypeCountAggregateInputType | true
    _min?: BedTypeMinAggregateInputType
    _max?: BedTypeMaxAggregateInputType
  }

  export type BedTypeGroupByOutputType = {
    id: string
    name: string
    image: string
    created: Date
    updated: Date
    is_excluded: boolean
    _count: BedTypeCountAggregateOutputType | null
    _min: BedTypeMinAggregateOutputType | null
    _max: BedTypeMaxAggregateOutputType | null
  }

  type GetBedTypeGroupByPayload<T extends BedTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BedTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BedTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BedTypeGroupByOutputType[P]>
            : GetScalarType<T[P], BedTypeGroupByOutputType[P]>
        }
      >
    >


  export type BedTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    image?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
    apartment_beds?: boolean | BedType$apartment_bedsArgs<ExtArgs>
    _count?: boolean | BedTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bedType"]>

  export type BedTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    image?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
  }, ExtArgs["result"]["bedType"]>

  export type BedTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    image?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
  }, ExtArgs["result"]["bedType"]>

  export type BedTypeSelectScalar = {
    id?: boolean
    name?: boolean
    image?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
  }

  export type BedTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "image" | "created" | "updated" | "is_excluded", ExtArgs["result"]["bedType"]>
  export type BedTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apartment_beds?: boolean | BedType$apartment_bedsArgs<ExtArgs>
    _count?: boolean | BedTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BedTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BedTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BedTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BedType"
    objects: {
      apartment_beds: Prisma.$ApartmentBedPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      image: string
      created: Date
      updated: Date
      is_excluded: boolean
    }, ExtArgs["result"]["bedType"]>
    composites: {}
  }

  type BedTypeGetPayload<S extends boolean | null | undefined | BedTypeDefaultArgs> = $Result.GetResult<Prisma.$BedTypePayload, S>

  type BedTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BedTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BedTypeCountAggregateInputType | true
    }

  export interface BedTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BedType'], meta: { name: 'BedType' } }
    /**
     * Find zero or one BedType that matches the filter.
     * @param {BedTypeFindUniqueArgs} args - Arguments to find a BedType
     * @example
     * // Get one BedType
     * const bedType = await prisma.bedType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BedTypeFindUniqueArgs>(args: SelectSubset<T, BedTypeFindUniqueArgs<ExtArgs>>): Prisma__BedTypeClient<$Result.GetResult<Prisma.$BedTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BedType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BedTypeFindUniqueOrThrowArgs} args - Arguments to find a BedType
     * @example
     * // Get one BedType
     * const bedType = await prisma.bedType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BedTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, BedTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BedTypeClient<$Result.GetResult<Prisma.$BedTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BedType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedTypeFindFirstArgs} args - Arguments to find a BedType
     * @example
     * // Get one BedType
     * const bedType = await prisma.bedType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BedTypeFindFirstArgs>(args?: SelectSubset<T, BedTypeFindFirstArgs<ExtArgs>>): Prisma__BedTypeClient<$Result.GetResult<Prisma.$BedTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BedType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedTypeFindFirstOrThrowArgs} args - Arguments to find a BedType
     * @example
     * // Get one BedType
     * const bedType = await prisma.bedType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BedTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, BedTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__BedTypeClient<$Result.GetResult<Prisma.$BedTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BedTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BedTypes
     * const bedTypes = await prisma.bedType.findMany()
     * 
     * // Get first 10 BedTypes
     * const bedTypes = await prisma.bedType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bedTypeWithIdOnly = await prisma.bedType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BedTypeFindManyArgs>(args?: SelectSubset<T, BedTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BedTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BedType.
     * @param {BedTypeCreateArgs} args - Arguments to create a BedType.
     * @example
     * // Create one BedType
     * const BedType = await prisma.bedType.create({
     *   data: {
     *     // ... data to create a BedType
     *   }
     * })
     * 
     */
    create<T extends BedTypeCreateArgs>(args: SelectSubset<T, BedTypeCreateArgs<ExtArgs>>): Prisma__BedTypeClient<$Result.GetResult<Prisma.$BedTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BedTypes.
     * @param {BedTypeCreateManyArgs} args - Arguments to create many BedTypes.
     * @example
     * // Create many BedTypes
     * const bedType = await prisma.bedType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BedTypeCreateManyArgs>(args?: SelectSubset<T, BedTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BedTypes and returns the data saved in the database.
     * @param {BedTypeCreateManyAndReturnArgs} args - Arguments to create many BedTypes.
     * @example
     * // Create many BedTypes
     * const bedType = await prisma.bedType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BedTypes and only return the `id`
     * const bedTypeWithIdOnly = await prisma.bedType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BedTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, BedTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BedTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BedType.
     * @param {BedTypeDeleteArgs} args - Arguments to delete one BedType.
     * @example
     * // Delete one BedType
     * const BedType = await prisma.bedType.delete({
     *   where: {
     *     // ... filter to delete one BedType
     *   }
     * })
     * 
     */
    delete<T extends BedTypeDeleteArgs>(args: SelectSubset<T, BedTypeDeleteArgs<ExtArgs>>): Prisma__BedTypeClient<$Result.GetResult<Prisma.$BedTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BedType.
     * @param {BedTypeUpdateArgs} args - Arguments to update one BedType.
     * @example
     * // Update one BedType
     * const bedType = await prisma.bedType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BedTypeUpdateArgs>(args: SelectSubset<T, BedTypeUpdateArgs<ExtArgs>>): Prisma__BedTypeClient<$Result.GetResult<Prisma.$BedTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BedTypes.
     * @param {BedTypeDeleteManyArgs} args - Arguments to filter BedTypes to delete.
     * @example
     * // Delete a few BedTypes
     * const { count } = await prisma.bedType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BedTypeDeleteManyArgs>(args?: SelectSubset<T, BedTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BedTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BedTypes
     * const bedType = await prisma.bedType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BedTypeUpdateManyArgs>(args: SelectSubset<T, BedTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BedTypes and returns the data updated in the database.
     * @param {BedTypeUpdateManyAndReturnArgs} args - Arguments to update many BedTypes.
     * @example
     * // Update many BedTypes
     * const bedType = await prisma.bedType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BedTypes and only return the `id`
     * const bedTypeWithIdOnly = await prisma.bedType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BedTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, BedTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BedTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BedType.
     * @param {BedTypeUpsertArgs} args - Arguments to update or create a BedType.
     * @example
     * // Update or create a BedType
     * const bedType = await prisma.bedType.upsert({
     *   create: {
     *     // ... data to create a BedType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BedType we want to update
     *   }
     * })
     */
    upsert<T extends BedTypeUpsertArgs>(args: SelectSubset<T, BedTypeUpsertArgs<ExtArgs>>): Prisma__BedTypeClient<$Result.GetResult<Prisma.$BedTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BedTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedTypeCountArgs} args - Arguments to filter BedTypes to count.
     * @example
     * // Count the number of BedTypes
     * const count = await prisma.bedType.count({
     *   where: {
     *     // ... the filter for the BedTypes we want to count
     *   }
     * })
    **/
    count<T extends BedTypeCountArgs>(
      args?: Subset<T, BedTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BedTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BedType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BedTypeAggregateArgs>(args: Subset<T, BedTypeAggregateArgs>): Prisma.PrismaPromise<GetBedTypeAggregateType<T>>

    /**
     * Group by BedType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BedTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BedTypeGroupByArgs['orderBy'] }
        : { orderBy?: BedTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BedTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBedTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BedType model
   */
  readonly fields: BedTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BedType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BedTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    apartment_beds<T extends BedType$apartment_bedsArgs<ExtArgs> = {}>(args?: Subset<T, BedType$apartment_bedsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApartmentBedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BedType model
   */
  interface BedTypeFieldRefs {
    readonly id: FieldRef<"BedType", 'String'>
    readonly name: FieldRef<"BedType", 'String'>
    readonly image: FieldRef<"BedType", 'String'>
    readonly created: FieldRef<"BedType", 'DateTime'>
    readonly updated: FieldRef<"BedType", 'DateTime'>
    readonly is_excluded: FieldRef<"BedType", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * BedType findUnique
   */
  export type BedTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedType
     */
    select?: BedTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedType
     */
    omit?: BedTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedTypeInclude<ExtArgs> | null
    /**
     * Filter, which BedType to fetch.
     */
    where: BedTypeWhereUniqueInput
  }

  /**
   * BedType findUniqueOrThrow
   */
  export type BedTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedType
     */
    select?: BedTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedType
     */
    omit?: BedTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedTypeInclude<ExtArgs> | null
    /**
     * Filter, which BedType to fetch.
     */
    where: BedTypeWhereUniqueInput
  }

  /**
   * BedType findFirst
   */
  export type BedTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedType
     */
    select?: BedTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedType
     */
    omit?: BedTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedTypeInclude<ExtArgs> | null
    /**
     * Filter, which BedType to fetch.
     */
    where?: BedTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BedTypes to fetch.
     */
    orderBy?: BedTypeOrderByWithRelationInput | BedTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BedTypes.
     */
    cursor?: BedTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BedTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BedTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BedTypes.
     */
    distinct?: BedTypeScalarFieldEnum | BedTypeScalarFieldEnum[]
  }

  /**
   * BedType findFirstOrThrow
   */
  export type BedTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedType
     */
    select?: BedTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedType
     */
    omit?: BedTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedTypeInclude<ExtArgs> | null
    /**
     * Filter, which BedType to fetch.
     */
    where?: BedTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BedTypes to fetch.
     */
    orderBy?: BedTypeOrderByWithRelationInput | BedTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BedTypes.
     */
    cursor?: BedTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BedTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BedTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BedTypes.
     */
    distinct?: BedTypeScalarFieldEnum | BedTypeScalarFieldEnum[]
  }

  /**
   * BedType findMany
   */
  export type BedTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedType
     */
    select?: BedTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedType
     */
    omit?: BedTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedTypeInclude<ExtArgs> | null
    /**
     * Filter, which BedTypes to fetch.
     */
    where?: BedTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BedTypes to fetch.
     */
    orderBy?: BedTypeOrderByWithRelationInput | BedTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BedTypes.
     */
    cursor?: BedTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BedTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BedTypes.
     */
    skip?: number
    distinct?: BedTypeScalarFieldEnum | BedTypeScalarFieldEnum[]
  }

  /**
   * BedType create
   */
  export type BedTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedType
     */
    select?: BedTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedType
     */
    omit?: BedTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a BedType.
     */
    data: XOR<BedTypeCreateInput, BedTypeUncheckedCreateInput>
  }

  /**
   * BedType createMany
   */
  export type BedTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BedTypes.
     */
    data: BedTypeCreateManyInput | BedTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BedType createManyAndReturn
   */
  export type BedTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedType
     */
    select?: BedTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BedType
     */
    omit?: BedTypeOmit<ExtArgs> | null
    /**
     * The data used to create many BedTypes.
     */
    data: BedTypeCreateManyInput | BedTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BedType update
   */
  export type BedTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedType
     */
    select?: BedTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedType
     */
    omit?: BedTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a BedType.
     */
    data: XOR<BedTypeUpdateInput, BedTypeUncheckedUpdateInput>
    /**
     * Choose, which BedType to update.
     */
    where: BedTypeWhereUniqueInput
  }

  /**
   * BedType updateMany
   */
  export type BedTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BedTypes.
     */
    data: XOR<BedTypeUpdateManyMutationInput, BedTypeUncheckedUpdateManyInput>
    /**
     * Filter which BedTypes to update
     */
    where?: BedTypeWhereInput
    /**
     * Limit how many BedTypes to update.
     */
    limit?: number
  }

  /**
   * BedType updateManyAndReturn
   */
  export type BedTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedType
     */
    select?: BedTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BedType
     */
    omit?: BedTypeOmit<ExtArgs> | null
    /**
     * The data used to update BedTypes.
     */
    data: XOR<BedTypeUpdateManyMutationInput, BedTypeUncheckedUpdateManyInput>
    /**
     * Filter which BedTypes to update
     */
    where?: BedTypeWhereInput
    /**
     * Limit how many BedTypes to update.
     */
    limit?: number
  }

  /**
   * BedType upsert
   */
  export type BedTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedType
     */
    select?: BedTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedType
     */
    omit?: BedTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the BedType to update in case it exists.
     */
    where: BedTypeWhereUniqueInput
    /**
     * In case the BedType found by the `where` argument doesn't exist, create a new BedType with this data.
     */
    create: XOR<BedTypeCreateInput, BedTypeUncheckedCreateInput>
    /**
     * In case the BedType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BedTypeUpdateInput, BedTypeUncheckedUpdateInput>
  }

  /**
   * BedType delete
   */
  export type BedTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedType
     */
    select?: BedTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedType
     */
    omit?: BedTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedTypeInclude<ExtArgs> | null
    /**
     * Filter which BedType to delete.
     */
    where: BedTypeWhereUniqueInput
  }

  /**
   * BedType deleteMany
   */
  export type BedTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BedTypes to delete
     */
    where?: BedTypeWhereInput
    /**
     * Limit how many BedTypes to delete.
     */
    limit?: number
  }

  /**
   * BedType.apartment_beds
   */
  export type BedType$apartment_bedsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApartmentBed
     */
    select?: ApartmentBedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApartmentBed
     */
    omit?: ApartmentBedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentBedInclude<ExtArgs> | null
    where?: ApartmentBedWhereInput
    orderBy?: ApartmentBedOrderByWithRelationInput | ApartmentBedOrderByWithRelationInput[]
    cursor?: ApartmentBedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApartmentBedScalarFieldEnum | ApartmentBedScalarFieldEnum[]
  }

  /**
   * BedType without action
   */
  export type BedTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedType
     */
    select?: BedTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedType
     */
    omit?: BedTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedTypeInclude<ExtArgs> | null
  }


  /**
   * Model ApartmentBed
   */

  export type AggregateApartmentBed = {
    _count: ApartmentBedCountAggregateOutputType | null
    _avg: ApartmentBedAvgAggregateOutputType | null
    _sum: ApartmentBedSumAggregateOutputType | null
    _min: ApartmentBedMinAggregateOutputType | null
    _max: ApartmentBedMaxAggregateOutputType | null
  }

  export type ApartmentBedAvgAggregateOutputType = {
    count: number | null
  }

  export type ApartmentBedSumAggregateOutputType = {
    count: number | null
  }

  export type ApartmentBedMinAggregateOutputType = {
    id: string | null
    apartment_id: string | null
    bed_type_id: string | null
    count: number | null
    created: Date | null
    updated: Date | null
    is_excluded: boolean | null
  }

  export type ApartmentBedMaxAggregateOutputType = {
    id: string | null
    apartment_id: string | null
    bed_type_id: string | null
    count: number | null
    created: Date | null
    updated: Date | null
    is_excluded: boolean | null
  }

  export type ApartmentBedCountAggregateOutputType = {
    id: number
    apartment_id: number
    bed_type_id: number
    count: number
    created: number
    updated: number
    is_excluded: number
    _all: number
  }


  export type ApartmentBedAvgAggregateInputType = {
    count?: true
  }

  export type ApartmentBedSumAggregateInputType = {
    count?: true
  }

  export type ApartmentBedMinAggregateInputType = {
    id?: true
    apartment_id?: true
    bed_type_id?: true
    count?: true
    created?: true
    updated?: true
    is_excluded?: true
  }

  export type ApartmentBedMaxAggregateInputType = {
    id?: true
    apartment_id?: true
    bed_type_id?: true
    count?: true
    created?: true
    updated?: true
    is_excluded?: true
  }

  export type ApartmentBedCountAggregateInputType = {
    id?: true
    apartment_id?: true
    bed_type_id?: true
    count?: true
    created?: true
    updated?: true
    is_excluded?: true
    _all?: true
  }

  export type ApartmentBedAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApartmentBed to aggregate.
     */
    where?: ApartmentBedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApartmentBeds to fetch.
     */
    orderBy?: ApartmentBedOrderByWithRelationInput | ApartmentBedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApartmentBedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApartmentBeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApartmentBeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApartmentBeds
    **/
    _count?: true | ApartmentBedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApartmentBedAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApartmentBedSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApartmentBedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApartmentBedMaxAggregateInputType
  }

  export type GetApartmentBedAggregateType<T extends ApartmentBedAggregateArgs> = {
        [P in keyof T & keyof AggregateApartmentBed]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApartmentBed[P]>
      : GetScalarType<T[P], AggregateApartmentBed[P]>
  }




  export type ApartmentBedGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApartmentBedWhereInput
    orderBy?: ApartmentBedOrderByWithAggregationInput | ApartmentBedOrderByWithAggregationInput[]
    by: ApartmentBedScalarFieldEnum[] | ApartmentBedScalarFieldEnum
    having?: ApartmentBedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApartmentBedCountAggregateInputType | true
    _avg?: ApartmentBedAvgAggregateInputType
    _sum?: ApartmentBedSumAggregateInputType
    _min?: ApartmentBedMinAggregateInputType
    _max?: ApartmentBedMaxAggregateInputType
  }

  export type ApartmentBedGroupByOutputType = {
    id: string
    apartment_id: string
    bed_type_id: string
    count: number
    created: Date
    updated: Date
    is_excluded: boolean
    _count: ApartmentBedCountAggregateOutputType | null
    _avg: ApartmentBedAvgAggregateOutputType | null
    _sum: ApartmentBedSumAggregateOutputType | null
    _min: ApartmentBedMinAggregateOutputType | null
    _max: ApartmentBedMaxAggregateOutputType | null
  }

  type GetApartmentBedGroupByPayload<T extends ApartmentBedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApartmentBedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApartmentBedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApartmentBedGroupByOutputType[P]>
            : GetScalarType<T[P], ApartmentBedGroupByOutputType[P]>
        }
      >
    >


  export type ApartmentBedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    apartment_id?: boolean
    bed_type_id?: boolean
    count?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
    apartment?: boolean | ApartmentDefaultArgs<ExtArgs>
    bed_type?: boolean | BedTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apartmentBed"]>

  export type ApartmentBedSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    apartment_id?: boolean
    bed_type_id?: boolean
    count?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
    apartment?: boolean | ApartmentDefaultArgs<ExtArgs>
    bed_type?: boolean | BedTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apartmentBed"]>

  export type ApartmentBedSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    apartment_id?: boolean
    bed_type_id?: boolean
    count?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
    apartment?: boolean | ApartmentDefaultArgs<ExtArgs>
    bed_type?: boolean | BedTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apartmentBed"]>

  export type ApartmentBedSelectScalar = {
    id?: boolean
    apartment_id?: boolean
    bed_type_id?: boolean
    count?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
  }

  export type ApartmentBedOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "apartment_id" | "bed_type_id" | "count" | "created" | "updated" | "is_excluded", ExtArgs["result"]["apartmentBed"]>
  export type ApartmentBedInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apartment?: boolean | ApartmentDefaultArgs<ExtArgs>
    bed_type?: boolean | BedTypeDefaultArgs<ExtArgs>
  }
  export type ApartmentBedIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apartment?: boolean | ApartmentDefaultArgs<ExtArgs>
    bed_type?: boolean | BedTypeDefaultArgs<ExtArgs>
  }
  export type ApartmentBedIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apartment?: boolean | ApartmentDefaultArgs<ExtArgs>
    bed_type?: boolean | BedTypeDefaultArgs<ExtArgs>
  }

  export type $ApartmentBedPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApartmentBed"
    objects: {
      apartment: Prisma.$ApartmentPayload<ExtArgs>
      bed_type: Prisma.$BedTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      apartment_id: string
      bed_type_id: string
      count: number
      created: Date
      updated: Date
      is_excluded: boolean
    }, ExtArgs["result"]["apartmentBed"]>
    composites: {}
  }

  type ApartmentBedGetPayload<S extends boolean | null | undefined | ApartmentBedDefaultArgs> = $Result.GetResult<Prisma.$ApartmentBedPayload, S>

  type ApartmentBedCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApartmentBedFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApartmentBedCountAggregateInputType | true
    }

  export interface ApartmentBedDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApartmentBed'], meta: { name: 'ApartmentBed' } }
    /**
     * Find zero or one ApartmentBed that matches the filter.
     * @param {ApartmentBedFindUniqueArgs} args - Arguments to find a ApartmentBed
     * @example
     * // Get one ApartmentBed
     * const apartmentBed = await prisma.apartmentBed.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApartmentBedFindUniqueArgs>(args: SelectSubset<T, ApartmentBedFindUniqueArgs<ExtArgs>>): Prisma__ApartmentBedClient<$Result.GetResult<Prisma.$ApartmentBedPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ApartmentBed that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApartmentBedFindUniqueOrThrowArgs} args - Arguments to find a ApartmentBed
     * @example
     * // Get one ApartmentBed
     * const apartmentBed = await prisma.apartmentBed.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApartmentBedFindUniqueOrThrowArgs>(args: SelectSubset<T, ApartmentBedFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApartmentBedClient<$Result.GetResult<Prisma.$ApartmentBedPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApartmentBed that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApartmentBedFindFirstArgs} args - Arguments to find a ApartmentBed
     * @example
     * // Get one ApartmentBed
     * const apartmentBed = await prisma.apartmentBed.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApartmentBedFindFirstArgs>(args?: SelectSubset<T, ApartmentBedFindFirstArgs<ExtArgs>>): Prisma__ApartmentBedClient<$Result.GetResult<Prisma.$ApartmentBedPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApartmentBed that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApartmentBedFindFirstOrThrowArgs} args - Arguments to find a ApartmentBed
     * @example
     * // Get one ApartmentBed
     * const apartmentBed = await prisma.apartmentBed.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApartmentBedFindFirstOrThrowArgs>(args?: SelectSubset<T, ApartmentBedFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApartmentBedClient<$Result.GetResult<Prisma.$ApartmentBedPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ApartmentBeds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApartmentBedFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApartmentBeds
     * const apartmentBeds = await prisma.apartmentBed.findMany()
     * 
     * // Get first 10 ApartmentBeds
     * const apartmentBeds = await prisma.apartmentBed.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apartmentBedWithIdOnly = await prisma.apartmentBed.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApartmentBedFindManyArgs>(args?: SelectSubset<T, ApartmentBedFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApartmentBedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ApartmentBed.
     * @param {ApartmentBedCreateArgs} args - Arguments to create a ApartmentBed.
     * @example
     * // Create one ApartmentBed
     * const ApartmentBed = await prisma.apartmentBed.create({
     *   data: {
     *     // ... data to create a ApartmentBed
     *   }
     * })
     * 
     */
    create<T extends ApartmentBedCreateArgs>(args: SelectSubset<T, ApartmentBedCreateArgs<ExtArgs>>): Prisma__ApartmentBedClient<$Result.GetResult<Prisma.$ApartmentBedPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ApartmentBeds.
     * @param {ApartmentBedCreateManyArgs} args - Arguments to create many ApartmentBeds.
     * @example
     * // Create many ApartmentBeds
     * const apartmentBed = await prisma.apartmentBed.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApartmentBedCreateManyArgs>(args?: SelectSubset<T, ApartmentBedCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApartmentBeds and returns the data saved in the database.
     * @param {ApartmentBedCreateManyAndReturnArgs} args - Arguments to create many ApartmentBeds.
     * @example
     * // Create many ApartmentBeds
     * const apartmentBed = await prisma.apartmentBed.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApartmentBeds and only return the `id`
     * const apartmentBedWithIdOnly = await prisma.apartmentBed.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApartmentBedCreateManyAndReturnArgs>(args?: SelectSubset<T, ApartmentBedCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApartmentBedPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ApartmentBed.
     * @param {ApartmentBedDeleteArgs} args - Arguments to delete one ApartmentBed.
     * @example
     * // Delete one ApartmentBed
     * const ApartmentBed = await prisma.apartmentBed.delete({
     *   where: {
     *     // ... filter to delete one ApartmentBed
     *   }
     * })
     * 
     */
    delete<T extends ApartmentBedDeleteArgs>(args: SelectSubset<T, ApartmentBedDeleteArgs<ExtArgs>>): Prisma__ApartmentBedClient<$Result.GetResult<Prisma.$ApartmentBedPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ApartmentBed.
     * @param {ApartmentBedUpdateArgs} args - Arguments to update one ApartmentBed.
     * @example
     * // Update one ApartmentBed
     * const apartmentBed = await prisma.apartmentBed.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApartmentBedUpdateArgs>(args: SelectSubset<T, ApartmentBedUpdateArgs<ExtArgs>>): Prisma__ApartmentBedClient<$Result.GetResult<Prisma.$ApartmentBedPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ApartmentBeds.
     * @param {ApartmentBedDeleteManyArgs} args - Arguments to filter ApartmentBeds to delete.
     * @example
     * // Delete a few ApartmentBeds
     * const { count } = await prisma.apartmentBed.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApartmentBedDeleteManyArgs>(args?: SelectSubset<T, ApartmentBedDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApartmentBeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApartmentBedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApartmentBeds
     * const apartmentBed = await prisma.apartmentBed.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApartmentBedUpdateManyArgs>(args: SelectSubset<T, ApartmentBedUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApartmentBeds and returns the data updated in the database.
     * @param {ApartmentBedUpdateManyAndReturnArgs} args - Arguments to update many ApartmentBeds.
     * @example
     * // Update many ApartmentBeds
     * const apartmentBed = await prisma.apartmentBed.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ApartmentBeds and only return the `id`
     * const apartmentBedWithIdOnly = await prisma.apartmentBed.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApartmentBedUpdateManyAndReturnArgs>(args: SelectSubset<T, ApartmentBedUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApartmentBedPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ApartmentBed.
     * @param {ApartmentBedUpsertArgs} args - Arguments to update or create a ApartmentBed.
     * @example
     * // Update or create a ApartmentBed
     * const apartmentBed = await prisma.apartmentBed.upsert({
     *   create: {
     *     // ... data to create a ApartmentBed
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApartmentBed we want to update
     *   }
     * })
     */
    upsert<T extends ApartmentBedUpsertArgs>(args: SelectSubset<T, ApartmentBedUpsertArgs<ExtArgs>>): Prisma__ApartmentBedClient<$Result.GetResult<Prisma.$ApartmentBedPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ApartmentBeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApartmentBedCountArgs} args - Arguments to filter ApartmentBeds to count.
     * @example
     * // Count the number of ApartmentBeds
     * const count = await prisma.apartmentBed.count({
     *   where: {
     *     // ... the filter for the ApartmentBeds we want to count
     *   }
     * })
    **/
    count<T extends ApartmentBedCountArgs>(
      args?: Subset<T, ApartmentBedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApartmentBedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApartmentBed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApartmentBedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApartmentBedAggregateArgs>(args: Subset<T, ApartmentBedAggregateArgs>): Prisma.PrismaPromise<GetApartmentBedAggregateType<T>>

    /**
     * Group by ApartmentBed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApartmentBedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApartmentBedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApartmentBedGroupByArgs['orderBy'] }
        : { orderBy?: ApartmentBedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApartmentBedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApartmentBedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApartmentBed model
   */
  readonly fields: ApartmentBedFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApartmentBed.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApartmentBedClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    apartment<T extends ApartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApartmentDefaultArgs<ExtArgs>>): Prisma__ApartmentClient<$Result.GetResult<Prisma.$ApartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bed_type<T extends BedTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BedTypeDefaultArgs<ExtArgs>>): Prisma__BedTypeClient<$Result.GetResult<Prisma.$BedTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApartmentBed model
   */
  interface ApartmentBedFieldRefs {
    readonly id: FieldRef<"ApartmentBed", 'String'>
    readonly apartment_id: FieldRef<"ApartmentBed", 'String'>
    readonly bed_type_id: FieldRef<"ApartmentBed", 'String'>
    readonly count: FieldRef<"ApartmentBed", 'Int'>
    readonly created: FieldRef<"ApartmentBed", 'DateTime'>
    readonly updated: FieldRef<"ApartmentBed", 'DateTime'>
    readonly is_excluded: FieldRef<"ApartmentBed", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ApartmentBed findUnique
   */
  export type ApartmentBedFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApartmentBed
     */
    select?: ApartmentBedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApartmentBed
     */
    omit?: ApartmentBedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentBedInclude<ExtArgs> | null
    /**
     * Filter, which ApartmentBed to fetch.
     */
    where: ApartmentBedWhereUniqueInput
  }

  /**
   * ApartmentBed findUniqueOrThrow
   */
  export type ApartmentBedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApartmentBed
     */
    select?: ApartmentBedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApartmentBed
     */
    omit?: ApartmentBedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentBedInclude<ExtArgs> | null
    /**
     * Filter, which ApartmentBed to fetch.
     */
    where: ApartmentBedWhereUniqueInput
  }

  /**
   * ApartmentBed findFirst
   */
  export type ApartmentBedFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApartmentBed
     */
    select?: ApartmentBedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApartmentBed
     */
    omit?: ApartmentBedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentBedInclude<ExtArgs> | null
    /**
     * Filter, which ApartmentBed to fetch.
     */
    where?: ApartmentBedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApartmentBeds to fetch.
     */
    orderBy?: ApartmentBedOrderByWithRelationInput | ApartmentBedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApartmentBeds.
     */
    cursor?: ApartmentBedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApartmentBeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApartmentBeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApartmentBeds.
     */
    distinct?: ApartmentBedScalarFieldEnum | ApartmentBedScalarFieldEnum[]
  }

  /**
   * ApartmentBed findFirstOrThrow
   */
  export type ApartmentBedFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApartmentBed
     */
    select?: ApartmentBedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApartmentBed
     */
    omit?: ApartmentBedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentBedInclude<ExtArgs> | null
    /**
     * Filter, which ApartmentBed to fetch.
     */
    where?: ApartmentBedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApartmentBeds to fetch.
     */
    orderBy?: ApartmentBedOrderByWithRelationInput | ApartmentBedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApartmentBeds.
     */
    cursor?: ApartmentBedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApartmentBeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApartmentBeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApartmentBeds.
     */
    distinct?: ApartmentBedScalarFieldEnum | ApartmentBedScalarFieldEnum[]
  }

  /**
   * ApartmentBed findMany
   */
  export type ApartmentBedFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApartmentBed
     */
    select?: ApartmentBedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApartmentBed
     */
    omit?: ApartmentBedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentBedInclude<ExtArgs> | null
    /**
     * Filter, which ApartmentBeds to fetch.
     */
    where?: ApartmentBedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApartmentBeds to fetch.
     */
    orderBy?: ApartmentBedOrderByWithRelationInput | ApartmentBedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApartmentBeds.
     */
    cursor?: ApartmentBedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApartmentBeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApartmentBeds.
     */
    skip?: number
    distinct?: ApartmentBedScalarFieldEnum | ApartmentBedScalarFieldEnum[]
  }

  /**
   * ApartmentBed create
   */
  export type ApartmentBedCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApartmentBed
     */
    select?: ApartmentBedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApartmentBed
     */
    omit?: ApartmentBedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentBedInclude<ExtArgs> | null
    /**
     * The data needed to create a ApartmentBed.
     */
    data: XOR<ApartmentBedCreateInput, ApartmentBedUncheckedCreateInput>
  }

  /**
   * ApartmentBed createMany
   */
  export type ApartmentBedCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApartmentBeds.
     */
    data: ApartmentBedCreateManyInput | ApartmentBedCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApartmentBed createManyAndReturn
   */
  export type ApartmentBedCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApartmentBed
     */
    select?: ApartmentBedSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApartmentBed
     */
    omit?: ApartmentBedOmit<ExtArgs> | null
    /**
     * The data used to create many ApartmentBeds.
     */
    data: ApartmentBedCreateManyInput | ApartmentBedCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentBedIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApartmentBed update
   */
  export type ApartmentBedUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApartmentBed
     */
    select?: ApartmentBedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApartmentBed
     */
    omit?: ApartmentBedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentBedInclude<ExtArgs> | null
    /**
     * The data needed to update a ApartmentBed.
     */
    data: XOR<ApartmentBedUpdateInput, ApartmentBedUncheckedUpdateInput>
    /**
     * Choose, which ApartmentBed to update.
     */
    where: ApartmentBedWhereUniqueInput
  }

  /**
   * ApartmentBed updateMany
   */
  export type ApartmentBedUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApartmentBeds.
     */
    data: XOR<ApartmentBedUpdateManyMutationInput, ApartmentBedUncheckedUpdateManyInput>
    /**
     * Filter which ApartmentBeds to update
     */
    where?: ApartmentBedWhereInput
    /**
     * Limit how many ApartmentBeds to update.
     */
    limit?: number
  }

  /**
   * ApartmentBed updateManyAndReturn
   */
  export type ApartmentBedUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApartmentBed
     */
    select?: ApartmentBedSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApartmentBed
     */
    omit?: ApartmentBedOmit<ExtArgs> | null
    /**
     * The data used to update ApartmentBeds.
     */
    data: XOR<ApartmentBedUpdateManyMutationInput, ApartmentBedUncheckedUpdateManyInput>
    /**
     * Filter which ApartmentBeds to update
     */
    where?: ApartmentBedWhereInput
    /**
     * Limit how many ApartmentBeds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentBedIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApartmentBed upsert
   */
  export type ApartmentBedUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApartmentBed
     */
    select?: ApartmentBedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApartmentBed
     */
    omit?: ApartmentBedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentBedInclude<ExtArgs> | null
    /**
     * The filter to search for the ApartmentBed to update in case it exists.
     */
    where: ApartmentBedWhereUniqueInput
    /**
     * In case the ApartmentBed found by the `where` argument doesn't exist, create a new ApartmentBed with this data.
     */
    create: XOR<ApartmentBedCreateInput, ApartmentBedUncheckedCreateInput>
    /**
     * In case the ApartmentBed was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApartmentBedUpdateInput, ApartmentBedUncheckedUpdateInput>
  }

  /**
   * ApartmentBed delete
   */
  export type ApartmentBedDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApartmentBed
     */
    select?: ApartmentBedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApartmentBed
     */
    omit?: ApartmentBedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentBedInclude<ExtArgs> | null
    /**
     * Filter which ApartmentBed to delete.
     */
    where: ApartmentBedWhereUniqueInput
  }

  /**
   * ApartmentBed deleteMany
   */
  export type ApartmentBedDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApartmentBeds to delete
     */
    where?: ApartmentBedWhereInput
    /**
     * Limit how many ApartmentBeds to delete.
     */
    limit?: number
  }

  /**
   * ApartmentBed without action
   */
  export type ApartmentBedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApartmentBed
     */
    select?: ApartmentBedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApartmentBed
     */
    omit?: ApartmentBedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApartmentBedInclude<ExtArgs> | null
  }


  /**
   * Model BookingVariant
   */

  export type AggregateBookingVariant = {
    _count: BookingVariantCountAggregateOutputType | null
    _avg: BookingVariantAvgAggregateOutputType | null
    _sum: BookingVariantSumAggregateOutputType | null
    _min: BookingVariantMinAggregateOutputType | null
    _max: BookingVariantMaxAggregateOutputType | null
  }

  export type BookingVariantAvgAggregateOutputType = {
    price: number | null
    capacity: number | null
  }

  export type BookingVariantSumAggregateOutputType = {
    price: number | null
    capacity: number | null
  }

  export type BookingVariantMinAggregateOutputType = {
    id: string | null
    apartment_id: string | null
    price: number | null
    capacity: number | null
    is_available: boolean | null
    created: Date | null
    updated: Date | null
    is_excluded: boolean | null
  }

  export type BookingVariantMaxAggregateOutputType = {
    id: string | null
    apartment_id: string | null
    price: number | null
    capacity: number | null
    is_available: boolean | null
    created: Date | null
    updated: Date | null
    is_excluded: boolean | null
  }

  export type BookingVariantCountAggregateOutputType = {
    id: number
    apartment_id: number
    price: number
    capacity: number
    is_available: number
    created: number
    updated: number
    is_excluded: number
    _all: number
  }


  export type BookingVariantAvgAggregateInputType = {
    price?: true
    capacity?: true
  }

  export type BookingVariantSumAggregateInputType = {
    price?: true
    capacity?: true
  }

  export type BookingVariantMinAggregateInputType = {
    id?: true
    apartment_id?: true
    price?: true
    capacity?: true
    is_available?: true
    created?: true
    updated?: true
    is_excluded?: true
  }

  export type BookingVariantMaxAggregateInputType = {
    id?: true
    apartment_id?: true
    price?: true
    capacity?: true
    is_available?: true
    created?: true
    updated?: true
    is_excluded?: true
  }

  export type BookingVariantCountAggregateInputType = {
    id?: true
    apartment_id?: true
    price?: true
    capacity?: true
    is_available?: true
    created?: true
    updated?: true
    is_excluded?: true
    _all?: true
  }

  export type BookingVariantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingVariant to aggregate.
     */
    where?: BookingVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingVariants to fetch.
     */
    orderBy?: BookingVariantOrderByWithRelationInput | BookingVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookingVariants
    **/
    _count?: true | BookingVariantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingVariantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingVariantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingVariantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingVariantMaxAggregateInputType
  }

  export type GetBookingVariantAggregateType<T extends BookingVariantAggregateArgs> = {
        [P in keyof T & keyof AggregateBookingVariant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookingVariant[P]>
      : GetScalarType<T[P], AggregateBookingVariant[P]>
  }




  export type BookingVariantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingVariantWhereInput
    orderBy?: BookingVariantOrderByWithAggregationInput | BookingVariantOrderByWithAggregationInput[]
    by: BookingVariantScalarFieldEnum[] | BookingVariantScalarFieldEnum
    having?: BookingVariantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingVariantCountAggregateInputType | true
    _avg?: BookingVariantAvgAggregateInputType
    _sum?: BookingVariantSumAggregateInputType
    _min?: BookingVariantMinAggregateInputType
    _max?: BookingVariantMaxAggregateInputType
  }

  export type BookingVariantGroupByOutputType = {
    id: string
    apartment_id: string
    price: number
    capacity: number
    is_available: boolean
    created: Date
    updated: Date
    is_excluded: boolean
    _count: BookingVariantCountAggregateOutputType | null
    _avg: BookingVariantAvgAggregateOutputType | null
    _sum: BookingVariantSumAggregateOutputType | null
    _min: BookingVariantMinAggregateOutputType | null
    _max: BookingVariantMaxAggregateOutputType | null
  }

  type GetBookingVariantGroupByPayload<T extends BookingVariantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingVariantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingVariantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingVariantGroupByOutputType[P]>
            : GetScalarType<T[P], BookingVariantGroupByOutputType[P]>
        }
      >
    >


  export type BookingVariantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    apartment_id?: boolean
    price?: boolean
    capacity?: boolean
    is_available?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
    apartment?: boolean | ApartmentDefaultArgs<ExtArgs>
    bookings?: boolean | BookingVariant$bookingsArgs<ExtArgs>
    _count?: boolean | BookingVariantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingVariant"]>

  export type BookingVariantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    apartment_id?: boolean
    price?: boolean
    capacity?: boolean
    is_available?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
    apartment?: boolean | ApartmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingVariant"]>

  export type BookingVariantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    apartment_id?: boolean
    price?: boolean
    capacity?: boolean
    is_available?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
    apartment?: boolean | ApartmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingVariant"]>

  export type BookingVariantSelectScalar = {
    id?: boolean
    apartment_id?: boolean
    price?: boolean
    capacity?: boolean
    is_available?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
  }

  export type BookingVariantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "apartment_id" | "price" | "capacity" | "is_available" | "created" | "updated" | "is_excluded", ExtArgs["result"]["bookingVariant"]>
  export type BookingVariantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apartment?: boolean | ApartmentDefaultArgs<ExtArgs>
    bookings?: boolean | BookingVariant$bookingsArgs<ExtArgs>
    _count?: boolean | BookingVariantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BookingVariantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apartment?: boolean | ApartmentDefaultArgs<ExtArgs>
  }
  export type BookingVariantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apartment?: boolean | ApartmentDefaultArgs<ExtArgs>
  }

  export type $BookingVariantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookingVariant"
    objects: {
      apartment: Prisma.$ApartmentPayload<ExtArgs>
      bookings: Prisma.$BookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      apartment_id: string
      price: number
      capacity: number
      is_available: boolean
      created: Date
      updated: Date
      is_excluded: boolean
    }, ExtArgs["result"]["bookingVariant"]>
    composites: {}
  }

  type BookingVariantGetPayload<S extends boolean | null | undefined | BookingVariantDefaultArgs> = $Result.GetResult<Prisma.$BookingVariantPayload, S>

  type BookingVariantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingVariantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingVariantCountAggregateInputType | true
    }

  export interface BookingVariantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookingVariant'], meta: { name: 'BookingVariant' } }
    /**
     * Find zero or one BookingVariant that matches the filter.
     * @param {BookingVariantFindUniqueArgs} args - Arguments to find a BookingVariant
     * @example
     * // Get one BookingVariant
     * const bookingVariant = await prisma.bookingVariant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingVariantFindUniqueArgs>(args: SelectSubset<T, BookingVariantFindUniqueArgs<ExtArgs>>): Prisma__BookingVariantClient<$Result.GetResult<Prisma.$BookingVariantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BookingVariant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingVariantFindUniqueOrThrowArgs} args - Arguments to find a BookingVariant
     * @example
     * // Get one BookingVariant
     * const bookingVariant = await prisma.bookingVariant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingVariantFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingVariantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingVariantClient<$Result.GetResult<Prisma.$BookingVariantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingVariant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingVariantFindFirstArgs} args - Arguments to find a BookingVariant
     * @example
     * // Get one BookingVariant
     * const bookingVariant = await prisma.bookingVariant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingVariantFindFirstArgs>(args?: SelectSubset<T, BookingVariantFindFirstArgs<ExtArgs>>): Prisma__BookingVariantClient<$Result.GetResult<Prisma.$BookingVariantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingVariant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingVariantFindFirstOrThrowArgs} args - Arguments to find a BookingVariant
     * @example
     * // Get one BookingVariant
     * const bookingVariant = await prisma.bookingVariant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingVariantFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingVariantFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingVariantClient<$Result.GetResult<Prisma.$BookingVariantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BookingVariants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingVariantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookingVariants
     * const bookingVariants = await prisma.bookingVariant.findMany()
     * 
     * // Get first 10 BookingVariants
     * const bookingVariants = await prisma.bookingVariant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingVariantWithIdOnly = await prisma.bookingVariant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingVariantFindManyArgs>(args?: SelectSubset<T, BookingVariantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingVariantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BookingVariant.
     * @param {BookingVariantCreateArgs} args - Arguments to create a BookingVariant.
     * @example
     * // Create one BookingVariant
     * const BookingVariant = await prisma.bookingVariant.create({
     *   data: {
     *     // ... data to create a BookingVariant
     *   }
     * })
     * 
     */
    create<T extends BookingVariantCreateArgs>(args: SelectSubset<T, BookingVariantCreateArgs<ExtArgs>>): Prisma__BookingVariantClient<$Result.GetResult<Prisma.$BookingVariantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BookingVariants.
     * @param {BookingVariantCreateManyArgs} args - Arguments to create many BookingVariants.
     * @example
     * // Create many BookingVariants
     * const bookingVariant = await prisma.bookingVariant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingVariantCreateManyArgs>(args?: SelectSubset<T, BookingVariantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BookingVariants and returns the data saved in the database.
     * @param {BookingVariantCreateManyAndReturnArgs} args - Arguments to create many BookingVariants.
     * @example
     * // Create many BookingVariants
     * const bookingVariant = await prisma.bookingVariant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BookingVariants and only return the `id`
     * const bookingVariantWithIdOnly = await prisma.bookingVariant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingVariantCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingVariantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingVariantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BookingVariant.
     * @param {BookingVariantDeleteArgs} args - Arguments to delete one BookingVariant.
     * @example
     * // Delete one BookingVariant
     * const BookingVariant = await prisma.bookingVariant.delete({
     *   where: {
     *     // ... filter to delete one BookingVariant
     *   }
     * })
     * 
     */
    delete<T extends BookingVariantDeleteArgs>(args: SelectSubset<T, BookingVariantDeleteArgs<ExtArgs>>): Prisma__BookingVariantClient<$Result.GetResult<Prisma.$BookingVariantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BookingVariant.
     * @param {BookingVariantUpdateArgs} args - Arguments to update one BookingVariant.
     * @example
     * // Update one BookingVariant
     * const bookingVariant = await prisma.bookingVariant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingVariantUpdateArgs>(args: SelectSubset<T, BookingVariantUpdateArgs<ExtArgs>>): Prisma__BookingVariantClient<$Result.GetResult<Prisma.$BookingVariantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BookingVariants.
     * @param {BookingVariantDeleteManyArgs} args - Arguments to filter BookingVariants to delete.
     * @example
     * // Delete a few BookingVariants
     * const { count } = await prisma.bookingVariant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingVariantDeleteManyArgs>(args?: SelectSubset<T, BookingVariantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingVariantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookingVariants
     * const bookingVariant = await prisma.bookingVariant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingVariantUpdateManyArgs>(args: SelectSubset<T, BookingVariantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingVariants and returns the data updated in the database.
     * @param {BookingVariantUpdateManyAndReturnArgs} args - Arguments to update many BookingVariants.
     * @example
     * // Update many BookingVariants
     * const bookingVariant = await prisma.bookingVariant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BookingVariants and only return the `id`
     * const bookingVariantWithIdOnly = await prisma.bookingVariant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookingVariantUpdateManyAndReturnArgs>(args: SelectSubset<T, BookingVariantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingVariantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BookingVariant.
     * @param {BookingVariantUpsertArgs} args - Arguments to update or create a BookingVariant.
     * @example
     * // Update or create a BookingVariant
     * const bookingVariant = await prisma.bookingVariant.upsert({
     *   create: {
     *     // ... data to create a BookingVariant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookingVariant we want to update
     *   }
     * })
     */
    upsert<T extends BookingVariantUpsertArgs>(args: SelectSubset<T, BookingVariantUpsertArgs<ExtArgs>>): Prisma__BookingVariantClient<$Result.GetResult<Prisma.$BookingVariantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BookingVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingVariantCountArgs} args - Arguments to filter BookingVariants to count.
     * @example
     * // Count the number of BookingVariants
     * const count = await prisma.bookingVariant.count({
     *   where: {
     *     // ... the filter for the BookingVariants we want to count
     *   }
     * })
    **/
    count<T extends BookingVariantCountArgs>(
      args?: Subset<T, BookingVariantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingVariantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookingVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingVariantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingVariantAggregateArgs>(args: Subset<T, BookingVariantAggregateArgs>): Prisma.PrismaPromise<GetBookingVariantAggregateType<T>>

    /**
     * Group by BookingVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingVariantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingVariantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingVariantGroupByArgs['orderBy'] }
        : { orderBy?: BookingVariantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingVariantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingVariantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookingVariant model
   */
  readonly fields: BookingVariantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookingVariant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingVariantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    apartment<T extends ApartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApartmentDefaultArgs<ExtArgs>>): Prisma__ApartmentClient<$Result.GetResult<Prisma.$ApartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bookings<T extends BookingVariant$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, BookingVariant$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookingVariant model
   */
  interface BookingVariantFieldRefs {
    readonly id: FieldRef<"BookingVariant", 'String'>
    readonly apartment_id: FieldRef<"BookingVariant", 'String'>
    readonly price: FieldRef<"BookingVariant", 'Float'>
    readonly capacity: FieldRef<"BookingVariant", 'Int'>
    readonly is_available: FieldRef<"BookingVariant", 'Boolean'>
    readonly created: FieldRef<"BookingVariant", 'DateTime'>
    readonly updated: FieldRef<"BookingVariant", 'DateTime'>
    readonly is_excluded: FieldRef<"BookingVariant", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * BookingVariant findUnique
   */
  export type BookingVariantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingVariant
     */
    select?: BookingVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingVariant
     */
    omit?: BookingVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingVariantInclude<ExtArgs> | null
    /**
     * Filter, which BookingVariant to fetch.
     */
    where: BookingVariantWhereUniqueInput
  }

  /**
   * BookingVariant findUniqueOrThrow
   */
  export type BookingVariantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingVariant
     */
    select?: BookingVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingVariant
     */
    omit?: BookingVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingVariantInclude<ExtArgs> | null
    /**
     * Filter, which BookingVariant to fetch.
     */
    where: BookingVariantWhereUniqueInput
  }

  /**
   * BookingVariant findFirst
   */
  export type BookingVariantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingVariant
     */
    select?: BookingVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingVariant
     */
    omit?: BookingVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingVariantInclude<ExtArgs> | null
    /**
     * Filter, which BookingVariant to fetch.
     */
    where?: BookingVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingVariants to fetch.
     */
    orderBy?: BookingVariantOrderByWithRelationInput | BookingVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingVariants.
     */
    cursor?: BookingVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingVariants.
     */
    distinct?: BookingVariantScalarFieldEnum | BookingVariantScalarFieldEnum[]
  }

  /**
   * BookingVariant findFirstOrThrow
   */
  export type BookingVariantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingVariant
     */
    select?: BookingVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingVariant
     */
    omit?: BookingVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingVariantInclude<ExtArgs> | null
    /**
     * Filter, which BookingVariant to fetch.
     */
    where?: BookingVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingVariants to fetch.
     */
    orderBy?: BookingVariantOrderByWithRelationInput | BookingVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingVariants.
     */
    cursor?: BookingVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingVariants.
     */
    distinct?: BookingVariantScalarFieldEnum | BookingVariantScalarFieldEnum[]
  }

  /**
   * BookingVariant findMany
   */
  export type BookingVariantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingVariant
     */
    select?: BookingVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingVariant
     */
    omit?: BookingVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingVariantInclude<ExtArgs> | null
    /**
     * Filter, which BookingVariants to fetch.
     */
    where?: BookingVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingVariants to fetch.
     */
    orderBy?: BookingVariantOrderByWithRelationInput | BookingVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookingVariants.
     */
    cursor?: BookingVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingVariants.
     */
    skip?: number
    distinct?: BookingVariantScalarFieldEnum | BookingVariantScalarFieldEnum[]
  }

  /**
   * BookingVariant create
   */
  export type BookingVariantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingVariant
     */
    select?: BookingVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingVariant
     */
    omit?: BookingVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingVariantInclude<ExtArgs> | null
    /**
     * The data needed to create a BookingVariant.
     */
    data: XOR<BookingVariantCreateInput, BookingVariantUncheckedCreateInput>
  }

  /**
   * BookingVariant createMany
   */
  export type BookingVariantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookingVariants.
     */
    data: BookingVariantCreateManyInput | BookingVariantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookingVariant createManyAndReturn
   */
  export type BookingVariantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingVariant
     */
    select?: BookingVariantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingVariant
     */
    omit?: BookingVariantOmit<ExtArgs> | null
    /**
     * The data used to create many BookingVariants.
     */
    data: BookingVariantCreateManyInput | BookingVariantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingVariantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingVariant update
   */
  export type BookingVariantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingVariant
     */
    select?: BookingVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingVariant
     */
    omit?: BookingVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingVariantInclude<ExtArgs> | null
    /**
     * The data needed to update a BookingVariant.
     */
    data: XOR<BookingVariantUpdateInput, BookingVariantUncheckedUpdateInput>
    /**
     * Choose, which BookingVariant to update.
     */
    where: BookingVariantWhereUniqueInput
  }

  /**
   * BookingVariant updateMany
   */
  export type BookingVariantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookingVariants.
     */
    data: XOR<BookingVariantUpdateManyMutationInput, BookingVariantUncheckedUpdateManyInput>
    /**
     * Filter which BookingVariants to update
     */
    where?: BookingVariantWhereInput
    /**
     * Limit how many BookingVariants to update.
     */
    limit?: number
  }

  /**
   * BookingVariant updateManyAndReturn
   */
  export type BookingVariantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingVariant
     */
    select?: BookingVariantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingVariant
     */
    omit?: BookingVariantOmit<ExtArgs> | null
    /**
     * The data used to update BookingVariants.
     */
    data: XOR<BookingVariantUpdateManyMutationInput, BookingVariantUncheckedUpdateManyInput>
    /**
     * Filter which BookingVariants to update
     */
    where?: BookingVariantWhereInput
    /**
     * Limit how many BookingVariants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingVariantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingVariant upsert
   */
  export type BookingVariantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingVariant
     */
    select?: BookingVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingVariant
     */
    omit?: BookingVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingVariantInclude<ExtArgs> | null
    /**
     * The filter to search for the BookingVariant to update in case it exists.
     */
    where: BookingVariantWhereUniqueInput
    /**
     * In case the BookingVariant found by the `where` argument doesn't exist, create a new BookingVariant with this data.
     */
    create: XOR<BookingVariantCreateInput, BookingVariantUncheckedCreateInput>
    /**
     * In case the BookingVariant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingVariantUpdateInput, BookingVariantUncheckedUpdateInput>
  }

  /**
   * BookingVariant delete
   */
  export type BookingVariantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingVariant
     */
    select?: BookingVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingVariant
     */
    omit?: BookingVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingVariantInclude<ExtArgs> | null
    /**
     * Filter which BookingVariant to delete.
     */
    where: BookingVariantWhereUniqueInput
  }

  /**
   * BookingVariant deleteMany
   */
  export type BookingVariantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingVariants to delete
     */
    where?: BookingVariantWhereInput
    /**
     * Limit how many BookingVariants to delete.
     */
    limit?: number
  }

  /**
   * BookingVariant.bookings
   */
  export type BookingVariant$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * BookingVariant without action
   */
  export type BookingVariantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingVariant
     */
    select?: BookingVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingVariant
     */
    omit?: BookingVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingVariantInclude<ExtArgs> | null
  }


  /**
   * Model Reservation
   */

  export type AggregateReservation = {
    _count: ReservationCountAggregateOutputType | null
    _min: ReservationMinAggregateOutputType | null
    _max: ReservationMaxAggregateOutputType | null
  }

  export type ReservationMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    apartment_id: string | null
    start: Date | null
    end: Date | null
    created: Date | null
    updated: Date | null
  }

  export type ReservationMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    apartment_id: string | null
    start: Date | null
    end: Date | null
    created: Date | null
    updated: Date | null
  }

  export type ReservationCountAggregateOutputType = {
    id: number
    user_id: number
    apartment_id: number
    start: number
    end: number
    created: number
    updated: number
    _all: number
  }


  export type ReservationMinAggregateInputType = {
    id?: true
    user_id?: true
    apartment_id?: true
    start?: true
    end?: true
    created?: true
    updated?: true
  }

  export type ReservationMaxAggregateInputType = {
    id?: true
    user_id?: true
    apartment_id?: true
    start?: true
    end?: true
    created?: true
    updated?: true
  }

  export type ReservationCountAggregateInputType = {
    id?: true
    user_id?: true
    apartment_id?: true
    start?: true
    end?: true
    created?: true
    updated?: true
    _all?: true
  }

  export type ReservationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reservation to aggregate.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reservations
    **/
    _count?: true | ReservationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReservationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReservationMaxAggregateInputType
  }

  export type GetReservationAggregateType<T extends ReservationAggregateArgs> = {
        [P in keyof T & keyof AggregateReservation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReservation[P]>
      : GetScalarType<T[P], AggregateReservation[P]>
  }




  export type ReservationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithAggregationInput | ReservationOrderByWithAggregationInput[]
    by: ReservationScalarFieldEnum[] | ReservationScalarFieldEnum
    having?: ReservationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReservationCountAggregateInputType | true
    _min?: ReservationMinAggregateInputType
    _max?: ReservationMaxAggregateInputType
  }

  export type ReservationGroupByOutputType = {
    id: string
    user_id: string
    apartment_id: string
    start: Date
    end: Date
    created: Date
    updated: Date
    _count: ReservationCountAggregateOutputType | null
    _min: ReservationMinAggregateOutputType | null
    _max: ReservationMaxAggregateOutputType | null
  }

  type GetReservationGroupByPayload<T extends ReservationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReservationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReservationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReservationGroupByOutputType[P]>
            : GetScalarType<T[P], ReservationGroupByOutputType[P]>
        }
      >
    >


  export type ReservationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    apartment_id?: boolean
    start?: boolean
    end?: boolean
    created?: boolean
    updated?: boolean
    apartment?: boolean | ApartmentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reservation"]>

  export type ReservationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    apartment_id?: boolean
    start?: boolean
    end?: boolean
    created?: boolean
    updated?: boolean
    apartment?: boolean | ApartmentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reservation"]>

  export type ReservationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    apartment_id?: boolean
    start?: boolean
    end?: boolean
    created?: boolean
    updated?: boolean
    apartment?: boolean | ApartmentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reservation"]>

  export type ReservationSelectScalar = {
    id?: boolean
    user_id?: boolean
    apartment_id?: boolean
    start?: boolean
    end?: boolean
    created?: boolean
    updated?: boolean
  }

  export type ReservationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "apartment_id" | "start" | "end" | "created" | "updated", ExtArgs["result"]["reservation"]>
  export type ReservationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apartment?: boolean | ApartmentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReservationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apartment?: boolean | ApartmentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReservationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apartment?: boolean | ApartmentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReservationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reservation"
    objects: {
      apartment: Prisma.$ApartmentPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      apartment_id: string
      start: Date
      end: Date
      created: Date
      updated: Date
    }, ExtArgs["result"]["reservation"]>
    composites: {}
  }

  type ReservationGetPayload<S extends boolean | null | undefined | ReservationDefaultArgs> = $Result.GetResult<Prisma.$ReservationPayload, S>

  type ReservationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReservationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReservationCountAggregateInputType | true
    }

  export interface ReservationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reservation'], meta: { name: 'Reservation' } }
    /**
     * Find zero or one Reservation that matches the filter.
     * @param {ReservationFindUniqueArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReservationFindUniqueArgs>(args: SelectSubset<T, ReservationFindUniqueArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Reservation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReservationFindUniqueOrThrowArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReservationFindUniqueOrThrowArgs>(args: SelectSubset<T, ReservationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reservation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationFindFirstArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReservationFindFirstArgs>(args?: SelectSubset<T, ReservationFindFirstArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reservation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationFindFirstOrThrowArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReservationFindFirstOrThrowArgs>(args?: SelectSubset<T, ReservationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reservations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reservations
     * const reservations = await prisma.reservation.findMany()
     * 
     * // Get first 10 Reservations
     * const reservations = await prisma.reservation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reservationWithIdOnly = await prisma.reservation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReservationFindManyArgs>(args?: SelectSubset<T, ReservationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Reservation.
     * @param {ReservationCreateArgs} args - Arguments to create a Reservation.
     * @example
     * // Create one Reservation
     * const Reservation = await prisma.reservation.create({
     *   data: {
     *     // ... data to create a Reservation
     *   }
     * })
     * 
     */
    create<T extends ReservationCreateArgs>(args: SelectSubset<T, ReservationCreateArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reservations.
     * @param {ReservationCreateManyArgs} args - Arguments to create many Reservations.
     * @example
     * // Create many Reservations
     * const reservation = await prisma.reservation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReservationCreateManyArgs>(args?: SelectSubset<T, ReservationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reservations and returns the data saved in the database.
     * @param {ReservationCreateManyAndReturnArgs} args - Arguments to create many Reservations.
     * @example
     * // Create many Reservations
     * const reservation = await prisma.reservation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reservations and only return the `id`
     * const reservationWithIdOnly = await prisma.reservation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReservationCreateManyAndReturnArgs>(args?: SelectSubset<T, ReservationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Reservation.
     * @param {ReservationDeleteArgs} args - Arguments to delete one Reservation.
     * @example
     * // Delete one Reservation
     * const Reservation = await prisma.reservation.delete({
     *   where: {
     *     // ... filter to delete one Reservation
     *   }
     * })
     * 
     */
    delete<T extends ReservationDeleteArgs>(args: SelectSubset<T, ReservationDeleteArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Reservation.
     * @param {ReservationUpdateArgs} args - Arguments to update one Reservation.
     * @example
     * // Update one Reservation
     * const reservation = await prisma.reservation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReservationUpdateArgs>(args: SelectSubset<T, ReservationUpdateArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reservations.
     * @param {ReservationDeleteManyArgs} args - Arguments to filter Reservations to delete.
     * @example
     * // Delete a few Reservations
     * const { count } = await prisma.reservation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReservationDeleteManyArgs>(args?: SelectSubset<T, ReservationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reservations
     * const reservation = await prisma.reservation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReservationUpdateManyArgs>(args: SelectSubset<T, ReservationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reservations and returns the data updated in the database.
     * @param {ReservationUpdateManyAndReturnArgs} args - Arguments to update many Reservations.
     * @example
     * // Update many Reservations
     * const reservation = await prisma.reservation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reservations and only return the `id`
     * const reservationWithIdOnly = await prisma.reservation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReservationUpdateManyAndReturnArgs>(args: SelectSubset<T, ReservationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Reservation.
     * @param {ReservationUpsertArgs} args - Arguments to update or create a Reservation.
     * @example
     * // Update or create a Reservation
     * const reservation = await prisma.reservation.upsert({
     *   create: {
     *     // ... data to create a Reservation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reservation we want to update
     *   }
     * })
     */
    upsert<T extends ReservationUpsertArgs>(args: SelectSubset<T, ReservationUpsertArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationCountArgs} args - Arguments to filter Reservations to count.
     * @example
     * // Count the number of Reservations
     * const count = await prisma.reservation.count({
     *   where: {
     *     // ... the filter for the Reservations we want to count
     *   }
     * })
    **/
    count<T extends ReservationCountArgs>(
      args?: Subset<T, ReservationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReservationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reservation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReservationAggregateArgs>(args: Subset<T, ReservationAggregateArgs>): Prisma.PrismaPromise<GetReservationAggregateType<T>>

    /**
     * Group by Reservation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReservationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReservationGroupByArgs['orderBy'] }
        : { orderBy?: ReservationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReservationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReservationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reservation model
   */
  readonly fields: ReservationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reservation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReservationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    apartment<T extends ApartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApartmentDefaultArgs<ExtArgs>>): Prisma__ApartmentClient<$Result.GetResult<Prisma.$ApartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reservation model
   */
  interface ReservationFieldRefs {
    readonly id: FieldRef<"Reservation", 'String'>
    readonly user_id: FieldRef<"Reservation", 'String'>
    readonly apartment_id: FieldRef<"Reservation", 'String'>
    readonly start: FieldRef<"Reservation", 'DateTime'>
    readonly end: FieldRef<"Reservation", 'DateTime'>
    readonly created: FieldRef<"Reservation", 'DateTime'>
    readonly updated: FieldRef<"Reservation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Reservation findUnique
   */
  export type ReservationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where: ReservationWhereUniqueInput
  }

  /**
   * Reservation findUniqueOrThrow
   */
  export type ReservationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where: ReservationWhereUniqueInput
  }

  /**
   * Reservation findFirst
   */
  export type ReservationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reservations.
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reservations.
     */
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Reservation findFirstOrThrow
   */
  export type ReservationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reservations.
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reservations.
     */
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Reservation findMany
   */
  export type ReservationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservations to fetch.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reservations.
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Reservation create
   */
  export type ReservationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * The data needed to create a Reservation.
     */
    data: XOR<ReservationCreateInput, ReservationUncheckedCreateInput>
  }

  /**
   * Reservation createMany
   */
  export type ReservationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reservations.
     */
    data: ReservationCreateManyInput | ReservationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reservation createManyAndReturn
   */
  export type ReservationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * The data used to create many Reservations.
     */
    data: ReservationCreateManyInput | ReservationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reservation update
   */
  export type ReservationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * The data needed to update a Reservation.
     */
    data: XOR<ReservationUpdateInput, ReservationUncheckedUpdateInput>
    /**
     * Choose, which Reservation to update.
     */
    where: ReservationWhereUniqueInput
  }

  /**
   * Reservation updateMany
   */
  export type ReservationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reservations.
     */
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyInput>
    /**
     * Filter which Reservations to update
     */
    where?: ReservationWhereInput
    /**
     * Limit how many Reservations to update.
     */
    limit?: number
  }

  /**
   * Reservation updateManyAndReturn
   */
  export type ReservationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * The data used to update Reservations.
     */
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyInput>
    /**
     * Filter which Reservations to update
     */
    where?: ReservationWhereInput
    /**
     * Limit how many Reservations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reservation upsert
   */
  export type ReservationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * The filter to search for the Reservation to update in case it exists.
     */
    where: ReservationWhereUniqueInput
    /**
     * In case the Reservation found by the `where` argument doesn't exist, create a new Reservation with this data.
     */
    create: XOR<ReservationCreateInput, ReservationUncheckedCreateInput>
    /**
     * In case the Reservation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReservationUpdateInput, ReservationUncheckedUpdateInput>
  }

  /**
   * Reservation delete
   */
  export type ReservationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter which Reservation to delete.
     */
    where: ReservationWhereUniqueInput
  }

  /**
   * Reservation deleteMany
   */
  export type ReservationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reservations to delete
     */
    where?: ReservationWhereInput
    /**
     * Limit how many Reservations to delete.
     */
    limit?: number
  }

  /**
   * Reservation without action
   */
  export type ReservationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
  }


  /**
   * Model Booking
   */

  export type AggregateBooking = {
    _count: BookingCountAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  export type BookingMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    booking_variant_id: string | null
    transaction_id: string | null
    message: string | null
    status: $Enums.BookingStatus | null
    start: Date | null
    end: Date | null
    created: Date | null
    updated: Date | null
  }

  export type BookingMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    booking_variant_id: string | null
    transaction_id: string | null
    message: string | null
    status: $Enums.BookingStatus | null
    start: Date | null
    end: Date | null
    created: Date | null
    updated: Date | null
  }

  export type BookingCountAggregateOutputType = {
    id: number
    user_id: number
    booking_variant_id: number
    transaction_id: number
    message: number
    status: number
    start: number
    end: number
    created: number
    updated: number
    _all: number
  }


  export type BookingMinAggregateInputType = {
    id?: true
    user_id?: true
    booking_variant_id?: true
    transaction_id?: true
    message?: true
    status?: true
    start?: true
    end?: true
    created?: true
    updated?: true
  }

  export type BookingMaxAggregateInputType = {
    id?: true
    user_id?: true
    booking_variant_id?: true
    transaction_id?: true
    message?: true
    status?: true
    start?: true
    end?: true
    created?: true
    updated?: true
  }

  export type BookingCountAggregateInputType = {
    id?: true
    user_id?: true
    booking_variant_id?: true
    transaction_id?: true
    message?: true
    status?: true
    start?: true
    end?: true
    created?: true
    updated?: true
    _all?: true
  }

  export type BookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Booking to aggregate.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookings
    **/
    _count?: true | BookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingMaxAggregateInputType
  }

  export type GetBookingAggregateType<T extends BookingAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking[P]>
      : GetScalarType<T[P], AggregateBooking[P]>
  }




  export type BookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithAggregationInput | BookingOrderByWithAggregationInput[]
    by: BookingScalarFieldEnum[] | BookingScalarFieldEnum
    having?: BookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingCountAggregateInputType | true
    _min?: BookingMinAggregateInputType
    _max?: BookingMaxAggregateInputType
  }

  export type BookingGroupByOutputType = {
    id: string
    user_id: string
    booking_variant_id: string
    transaction_id: string
    message: string | null
    status: $Enums.BookingStatus
    start: Date
    end: Date
    created: Date
    updated: Date
    _count: BookingCountAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  type GetBookingGroupByPayload<T extends BookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingGroupByOutputType[P]>
            : GetScalarType<T[P], BookingGroupByOutputType[P]>
        }
      >
    >


  export type BookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    booking_variant_id?: boolean
    transaction_id?: boolean
    message?: boolean
    status?: boolean
    start?: boolean
    end?: boolean
    created?: boolean
    updated?: boolean
    booking_variant?: boolean | BookingVariantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    booking_events?: boolean | Booking$booking_eventsArgs<ExtArgs>
    booking_additional_options?: boolean | Booking$booking_additional_optionsArgs<ExtArgs>
    reviews?: boolean | Booking$reviewsArgs<ExtArgs>
    messages?: boolean | Booking$messagesArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    booking_variant_id?: boolean
    transaction_id?: boolean
    message?: boolean
    status?: boolean
    start?: boolean
    end?: boolean
    created?: boolean
    updated?: boolean
    booking_variant?: boolean | BookingVariantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    booking_variant_id?: boolean
    transaction_id?: boolean
    message?: boolean
    status?: boolean
    start?: boolean
    end?: boolean
    created?: boolean
    updated?: boolean
    booking_variant?: boolean | BookingVariantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectScalar = {
    id?: boolean
    user_id?: boolean
    booking_variant_id?: boolean
    transaction_id?: boolean
    message?: boolean
    status?: boolean
    start?: boolean
    end?: boolean
    created?: boolean
    updated?: boolean
  }

  export type BookingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "booking_variant_id" | "transaction_id" | "message" | "status" | "start" | "end" | "created" | "updated", ExtArgs["result"]["booking"]>
  export type BookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking_variant?: boolean | BookingVariantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    booking_events?: boolean | Booking$booking_eventsArgs<ExtArgs>
    booking_additional_options?: boolean | Booking$booking_additional_optionsArgs<ExtArgs>
    reviews?: boolean | Booking$reviewsArgs<ExtArgs>
    messages?: boolean | Booking$messagesArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking_variant?: boolean | BookingVariantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }
  export type BookingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking_variant?: boolean | BookingVariantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }

  export type $BookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Booking"
    objects: {
      booking_variant: Prisma.$BookingVariantPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      transaction: Prisma.$TransactionPayload<ExtArgs>
      booking_events: Prisma.$BookingEventPayload<ExtArgs>[]
      booking_additional_options: Prisma.$BookingAdditionalOptionPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      booking_variant_id: string
      transaction_id: string
      message: string | null
      status: $Enums.BookingStatus
      start: Date
      end: Date
      created: Date
      updated: Date
    }, ExtArgs["result"]["booking"]>
    composites: {}
  }

  type BookingGetPayload<S extends boolean | null | undefined | BookingDefaultArgs> = $Result.GetResult<Prisma.$BookingPayload, S>

  type BookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingCountAggregateInputType | true
    }

  export interface BookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Booking'], meta: { name: 'Booking' } }
    /**
     * Find zero or one Booking that matches the filter.
     * @param {BookingFindUniqueArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingFindUniqueArgs>(args: SelectSubset<T, BookingFindUniqueArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Booking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingFindUniqueOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingFindFirstArgs>(args?: SelectSubset<T, BookingFindFirstArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.booking.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.booking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingWithIdOnly = await prisma.booking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingFindManyArgs>(args?: SelectSubset<T, BookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Booking.
     * @param {BookingCreateArgs} args - Arguments to create a Booking.
     * @example
     * // Create one Booking
     * const Booking = await prisma.booking.create({
     *   data: {
     *     // ... data to create a Booking
     *   }
     * })
     * 
     */
    create<T extends BookingCreateArgs>(args: SelectSubset<T, BookingCreateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bookings.
     * @param {BookingCreateManyArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingCreateManyArgs>(args?: SelectSubset<T, BookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bookings and returns the data saved in the database.
     * @param {BookingCreateManyAndReturnArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Booking.
     * @param {BookingDeleteArgs} args - Arguments to delete one Booking.
     * @example
     * // Delete one Booking
     * const Booking = await prisma.booking.delete({
     *   where: {
     *     // ... filter to delete one Booking
     *   }
     * })
     * 
     */
    delete<T extends BookingDeleteArgs>(args: SelectSubset<T, BookingDeleteArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Booking.
     * @param {BookingUpdateArgs} args - Arguments to update one Booking.
     * @example
     * // Update one Booking
     * const booking = await prisma.booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingUpdateArgs>(args: SelectSubset<T, BookingUpdateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bookings.
     * @param {BookingDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingDeleteManyArgs>(args?: SelectSubset<T, BookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingUpdateManyArgs>(args: SelectSubset<T, BookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings and returns the data updated in the database.
     * @param {BookingUpdateManyAndReturnArgs} args - Arguments to update many Bookings.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookingUpdateManyAndReturnArgs>(args: SelectSubset<T, BookingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Booking.
     * @param {BookingUpsertArgs} args - Arguments to update or create a Booking.
     * @example
     * // Update or create a Booking
     * const booking = await prisma.booking.upsert({
     *   create: {
     *     // ... data to create a Booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking we want to update
     *   }
     * })
     */
    upsert<T extends BookingUpsertArgs>(args: SelectSubset<T, BookingUpsertArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.booking.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends BookingCountArgs>(
      args?: Subset<T, BookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingAggregateArgs>(args: Subset<T, BookingAggregateArgs>): Prisma.PrismaPromise<GetBookingAggregateType<T>>

    /**
     * Group by Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingGroupByArgs['orderBy'] }
        : { orderBy?: BookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Booking model
   */
  readonly fields: BookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking_variant<T extends BookingVariantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingVariantDefaultArgs<ExtArgs>>): Prisma__BookingVariantClient<$Result.GetResult<Prisma.$BookingVariantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transaction<T extends TransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransactionDefaultArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    booking_events<T extends Booking$booking_eventsArgs<ExtArgs> = {}>(args?: Subset<T, Booking$booking_eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    booking_additional_options<T extends Booking$booking_additional_optionsArgs<ExtArgs> = {}>(args?: Subset<T, Booking$booking_additional_optionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingAdditionalOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends Booking$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Booking$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends Booking$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Booking$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Booking model
   */
  interface BookingFieldRefs {
    readonly id: FieldRef<"Booking", 'String'>
    readonly user_id: FieldRef<"Booking", 'String'>
    readonly booking_variant_id: FieldRef<"Booking", 'String'>
    readonly transaction_id: FieldRef<"Booking", 'String'>
    readonly message: FieldRef<"Booking", 'String'>
    readonly status: FieldRef<"Booking", 'BookingStatus'>
    readonly start: FieldRef<"Booking", 'DateTime'>
    readonly end: FieldRef<"Booking", 'DateTime'>
    readonly created: FieldRef<"Booking", 'DateTime'>
    readonly updated: FieldRef<"Booking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Booking findUnique
   */
  export type BookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findUniqueOrThrow
   */
  export type BookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findFirst
   */
  export type BookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findFirstOrThrow
   */
  export type BookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findMany
   */
  export type BookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking create
   */
  export type BookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to create a Booking.
     */
    data: XOR<BookingCreateInput, BookingUncheckedCreateInput>
  }

  /**
   * Booking createMany
   */
  export type BookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Booking createManyAndReturn
   */
  export type BookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking update
   */
  export type BookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to update a Booking.
     */
    data: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
    /**
     * Choose, which Booking to update.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking updateMany
   */
  export type BookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to update.
     */
    limit?: number
  }

  /**
   * Booking updateManyAndReturn
   */
  export type BookingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking upsert
   */
  export type BookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The filter to search for the Booking to update in case it exists.
     */
    where: BookingWhereUniqueInput
    /**
     * In case the Booking found by the `where` argument doesn't exist, create a new Booking with this data.
     */
    create: XOR<BookingCreateInput, BookingUncheckedCreateInput>
    /**
     * In case the Booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
  }

  /**
   * Booking delete
   */
  export type BookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter which Booking to delete.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking deleteMany
   */
  export type BookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to delete
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to delete.
     */
    limit?: number
  }

  /**
   * Booking.booking_events
   */
  export type Booking$booking_eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingEvent
     */
    select?: BookingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingEvent
     */
    omit?: BookingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingEventInclude<ExtArgs> | null
    where?: BookingEventWhereInput
    orderBy?: BookingEventOrderByWithRelationInput | BookingEventOrderByWithRelationInput[]
    cursor?: BookingEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingEventScalarFieldEnum | BookingEventScalarFieldEnum[]
  }

  /**
   * Booking.booking_additional_options
   */
  export type Booking$booking_additional_optionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingAdditionalOption
     */
    select?: BookingAdditionalOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingAdditionalOption
     */
    omit?: BookingAdditionalOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingAdditionalOptionInclude<ExtArgs> | null
    where?: BookingAdditionalOptionWhereInput
    orderBy?: BookingAdditionalOptionOrderByWithRelationInput | BookingAdditionalOptionOrderByWithRelationInput[]
    cursor?: BookingAdditionalOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingAdditionalOptionScalarFieldEnum | BookingAdditionalOptionScalarFieldEnum[]
  }

  /**
   * Booking.reviews
   */
  export type Booking$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Booking.messages
   */
  export type Booking$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Booking without action
   */
  export type BookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
  }


  /**
   * Model AdditionalOption
   */

  export type AggregateAdditionalOption = {
    _count: AdditionalOptionCountAggregateOutputType | null
    _avg: AdditionalOptionAvgAggregateOutputType | null
    _sum: AdditionalOptionSumAggregateOutputType | null
    _min: AdditionalOptionMinAggregateOutputType | null
    _max: AdditionalOptionMaxAggregateOutputType | null
  }

  export type AdditionalOptionAvgAggregateOutputType = {
    price: number | null
  }

  export type AdditionalOptionSumAggregateOutputType = {
    price: number | null
  }

  export type AdditionalOptionMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    image: string | null
    price: number | null
    created: Date | null
    updated: Date | null
    is_excluded: boolean | null
  }

  export type AdditionalOptionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    image: string | null
    price: number | null
    created: Date | null
    updated: Date | null
    is_excluded: boolean | null
  }

  export type AdditionalOptionCountAggregateOutputType = {
    id: number
    name: number
    description: number
    image: number
    price: number
    created: number
    updated: number
    is_excluded: number
    _all: number
  }


  export type AdditionalOptionAvgAggregateInputType = {
    price?: true
  }

  export type AdditionalOptionSumAggregateInputType = {
    price?: true
  }

  export type AdditionalOptionMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    image?: true
    price?: true
    created?: true
    updated?: true
    is_excluded?: true
  }

  export type AdditionalOptionMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    image?: true
    price?: true
    created?: true
    updated?: true
    is_excluded?: true
  }

  export type AdditionalOptionCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    image?: true
    price?: true
    created?: true
    updated?: true
    is_excluded?: true
    _all?: true
  }

  export type AdditionalOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdditionalOption to aggregate.
     */
    where?: AdditionalOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdditionalOptions to fetch.
     */
    orderBy?: AdditionalOptionOrderByWithRelationInput | AdditionalOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdditionalOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdditionalOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdditionalOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdditionalOptions
    **/
    _count?: true | AdditionalOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdditionalOptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdditionalOptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdditionalOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdditionalOptionMaxAggregateInputType
  }

  export type GetAdditionalOptionAggregateType<T extends AdditionalOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateAdditionalOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdditionalOption[P]>
      : GetScalarType<T[P], AggregateAdditionalOption[P]>
  }




  export type AdditionalOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdditionalOptionWhereInput
    orderBy?: AdditionalOptionOrderByWithAggregationInput | AdditionalOptionOrderByWithAggregationInput[]
    by: AdditionalOptionScalarFieldEnum[] | AdditionalOptionScalarFieldEnum
    having?: AdditionalOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdditionalOptionCountAggregateInputType | true
    _avg?: AdditionalOptionAvgAggregateInputType
    _sum?: AdditionalOptionSumAggregateInputType
    _min?: AdditionalOptionMinAggregateInputType
    _max?: AdditionalOptionMaxAggregateInputType
  }

  export type AdditionalOptionGroupByOutputType = {
    id: string
    name: string
    description: string
    image: string
    price: number
    created: Date
    updated: Date
    is_excluded: boolean
    _count: AdditionalOptionCountAggregateOutputType | null
    _avg: AdditionalOptionAvgAggregateOutputType | null
    _sum: AdditionalOptionSumAggregateOutputType | null
    _min: AdditionalOptionMinAggregateOutputType | null
    _max: AdditionalOptionMaxAggregateOutputType | null
  }

  type GetAdditionalOptionGroupByPayload<T extends AdditionalOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdditionalOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdditionalOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdditionalOptionGroupByOutputType[P]>
            : GetScalarType<T[P], AdditionalOptionGroupByOutputType[P]>
        }
      >
    >


  export type AdditionalOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    image?: boolean
    price?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
    booking_additional_options?: boolean | AdditionalOption$booking_additional_optionsArgs<ExtArgs>
    _count?: boolean | AdditionalOptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["additionalOption"]>

  export type AdditionalOptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    image?: boolean
    price?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
  }, ExtArgs["result"]["additionalOption"]>

  export type AdditionalOptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    image?: boolean
    price?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
  }, ExtArgs["result"]["additionalOption"]>

  export type AdditionalOptionSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    image?: boolean
    price?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
  }

  export type AdditionalOptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "image" | "price" | "created" | "updated" | "is_excluded", ExtArgs["result"]["additionalOption"]>
  export type AdditionalOptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking_additional_options?: boolean | AdditionalOption$booking_additional_optionsArgs<ExtArgs>
    _count?: boolean | AdditionalOptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdditionalOptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AdditionalOptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AdditionalOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdditionalOption"
    objects: {
      booking_additional_options: Prisma.$BookingAdditionalOptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      image: string
      price: number
      created: Date
      updated: Date
      is_excluded: boolean
    }, ExtArgs["result"]["additionalOption"]>
    composites: {}
  }

  type AdditionalOptionGetPayload<S extends boolean | null | undefined | AdditionalOptionDefaultArgs> = $Result.GetResult<Prisma.$AdditionalOptionPayload, S>

  type AdditionalOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdditionalOptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdditionalOptionCountAggregateInputType | true
    }

  export interface AdditionalOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdditionalOption'], meta: { name: 'AdditionalOption' } }
    /**
     * Find zero or one AdditionalOption that matches the filter.
     * @param {AdditionalOptionFindUniqueArgs} args - Arguments to find a AdditionalOption
     * @example
     * // Get one AdditionalOption
     * const additionalOption = await prisma.additionalOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdditionalOptionFindUniqueArgs>(args: SelectSubset<T, AdditionalOptionFindUniqueArgs<ExtArgs>>): Prisma__AdditionalOptionClient<$Result.GetResult<Prisma.$AdditionalOptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdditionalOption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdditionalOptionFindUniqueOrThrowArgs} args - Arguments to find a AdditionalOption
     * @example
     * // Get one AdditionalOption
     * const additionalOption = await prisma.additionalOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdditionalOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, AdditionalOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdditionalOptionClient<$Result.GetResult<Prisma.$AdditionalOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdditionalOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdditionalOptionFindFirstArgs} args - Arguments to find a AdditionalOption
     * @example
     * // Get one AdditionalOption
     * const additionalOption = await prisma.additionalOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdditionalOptionFindFirstArgs>(args?: SelectSubset<T, AdditionalOptionFindFirstArgs<ExtArgs>>): Prisma__AdditionalOptionClient<$Result.GetResult<Prisma.$AdditionalOptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdditionalOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdditionalOptionFindFirstOrThrowArgs} args - Arguments to find a AdditionalOption
     * @example
     * // Get one AdditionalOption
     * const additionalOption = await prisma.additionalOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdditionalOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, AdditionalOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdditionalOptionClient<$Result.GetResult<Prisma.$AdditionalOptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdditionalOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdditionalOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdditionalOptions
     * const additionalOptions = await prisma.additionalOption.findMany()
     * 
     * // Get first 10 AdditionalOptions
     * const additionalOptions = await prisma.additionalOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const additionalOptionWithIdOnly = await prisma.additionalOption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdditionalOptionFindManyArgs>(args?: SelectSubset<T, AdditionalOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdditionalOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdditionalOption.
     * @param {AdditionalOptionCreateArgs} args - Arguments to create a AdditionalOption.
     * @example
     * // Create one AdditionalOption
     * const AdditionalOption = await prisma.additionalOption.create({
     *   data: {
     *     // ... data to create a AdditionalOption
     *   }
     * })
     * 
     */
    create<T extends AdditionalOptionCreateArgs>(args: SelectSubset<T, AdditionalOptionCreateArgs<ExtArgs>>): Prisma__AdditionalOptionClient<$Result.GetResult<Prisma.$AdditionalOptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdditionalOptions.
     * @param {AdditionalOptionCreateManyArgs} args - Arguments to create many AdditionalOptions.
     * @example
     * // Create many AdditionalOptions
     * const additionalOption = await prisma.additionalOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdditionalOptionCreateManyArgs>(args?: SelectSubset<T, AdditionalOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdditionalOptions and returns the data saved in the database.
     * @param {AdditionalOptionCreateManyAndReturnArgs} args - Arguments to create many AdditionalOptions.
     * @example
     * // Create many AdditionalOptions
     * const additionalOption = await prisma.additionalOption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdditionalOptions and only return the `id`
     * const additionalOptionWithIdOnly = await prisma.additionalOption.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdditionalOptionCreateManyAndReturnArgs>(args?: SelectSubset<T, AdditionalOptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdditionalOptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdditionalOption.
     * @param {AdditionalOptionDeleteArgs} args - Arguments to delete one AdditionalOption.
     * @example
     * // Delete one AdditionalOption
     * const AdditionalOption = await prisma.additionalOption.delete({
     *   where: {
     *     // ... filter to delete one AdditionalOption
     *   }
     * })
     * 
     */
    delete<T extends AdditionalOptionDeleteArgs>(args: SelectSubset<T, AdditionalOptionDeleteArgs<ExtArgs>>): Prisma__AdditionalOptionClient<$Result.GetResult<Prisma.$AdditionalOptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdditionalOption.
     * @param {AdditionalOptionUpdateArgs} args - Arguments to update one AdditionalOption.
     * @example
     * // Update one AdditionalOption
     * const additionalOption = await prisma.additionalOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdditionalOptionUpdateArgs>(args: SelectSubset<T, AdditionalOptionUpdateArgs<ExtArgs>>): Prisma__AdditionalOptionClient<$Result.GetResult<Prisma.$AdditionalOptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdditionalOptions.
     * @param {AdditionalOptionDeleteManyArgs} args - Arguments to filter AdditionalOptions to delete.
     * @example
     * // Delete a few AdditionalOptions
     * const { count } = await prisma.additionalOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdditionalOptionDeleteManyArgs>(args?: SelectSubset<T, AdditionalOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdditionalOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdditionalOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdditionalOptions
     * const additionalOption = await prisma.additionalOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdditionalOptionUpdateManyArgs>(args: SelectSubset<T, AdditionalOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdditionalOptions and returns the data updated in the database.
     * @param {AdditionalOptionUpdateManyAndReturnArgs} args - Arguments to update many AdditionalOptions.
     * @example
     * // Update many AdditionalOptions
     * const additionalOption = await prisma.additionalOption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdditionalOptions and only return the `id`
     * const additionalOptionWithIdOnly = await prisma.additionalOption.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdditionalOptionUpdateManyAndReturnArgs>(args: SelectSubset<T, AdditionalOptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdditionalOptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdditionalOption.
     * @param {AdditionalOptionUpsertArgs} args - Arguments to update or create a AdditionalOption.
     * @example
     * // Update or create a AdditionalOption
     * const additionalOption = await prisma.additionalOption.upsert({
     *   create: {
     *     // ... data to create a AdditionalOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdditionalOption we want to update
     *   }
     * })
     */
    upsert<T extends AdditionalOptionUpsertArgs>(args: SelectSubset<T, AdditionalOptionUpsertArgs<ExtArgs>>): Prisma__AdditionalOptionClient<$Result.GetResult<Prisma.$AdditionalOptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdditionalOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdditionalOptionCountArgs} args - Arguments to filter AdditionalOptions to count.
     * @example
     * // Count the number of AdditionalOptions
     * const count = await prisma.additionalOption.count({
     *   where: {
     *     // ... the filter for the AdditionalOptions we want to count
     *   }
     * })
    **/
    count<T extends AdditionalOptionCountArgs>(
      args?: Subset<T, AdditionalOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdditionalOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdditionalOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdditionalOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdditionalOptionAggregateArgs>(args: Subset<T, AdditionalOptionAggregateArgs>): Prisma.PrismaPromise<GetAdditionalOptionAggregateType<T>>

    /**
     * Group by AdditionalOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdditionalOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdditionalOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdditionalOptionGroupByArgs['orderBy'] }
        : { orderBy?: AdditionalOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdditionalOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdditionalOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdditionalOption model
   */
  readonly fields: AdditionalOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdditionalOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdditionalOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking_additional_options<T extends AdditionalOption$booking_additional_optionsArgs<ExtArgs> = {}>(args?: Subset<T, AdditionalOption$booking_additional_optionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingAdditionalOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdditionalOption model
   */
  interface AdditionalOptionFieldRefs {
    readonly id: FieldRef<"AdditionalOption", 'String'>
    readonly name: FieldRef<"AdditionalOption", 'String'>
    readonly description: FieldRef<"AdditionalOption", 'String'>
    readonly image: FieldRef<"AdditionalOption", 'String'>
    readonly price: FieldRef<"AdditionalOption", 'Float'>
    readonly created: FieldRef<"AdditionalOption", 'DateTime'>
    readonly updated: FieldRef<"AdditionalOption", 'DateTime'>
    readonly is_excluded: FieldRef<"AdditionalOption", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * AdditionalOption findUnique
   */
  export type AdditionalOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalOption
     */
    select?: AdditionalOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdditionalOption
     */
    omit?: AdditionalOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalOptionInclude<ExtArgs> | null
    /**
     * Filter, which AdditionalOption to fetch.
     */
    where: AdditionalOptionWhereUniqueInput
  }

  /**
   * AdditionalOption findUniqueOrThrow
   */
  export type AdditionalOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalOption
     */
    select?: AdditionalOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdditionalOption
     */
    omit?: AdditionalOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalOptionInclude<ExtArgs> | null
    /**
     * Filter, which AdditionalOption to fetch.
     */
    where: AdditionalOptionWhereUniqueInput
  }

  /**
   * AdditionalOption findFirst
   */
  export type AdditionalOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalOption
     */
    select?: AdditionalOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdditionalOption
     */
    omit?: AdditionalOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalOptionInclude<ExtArgs> | null
    /**
     * Filter, which AdditionalOption to fetch.
     */
    where?: AdditionalOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdditionalOptions to fetch.
     */
    orderBy?: AdditionalOptionOrderByWithRelationInput | AdditionalOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdditionalOptions.
     */
    cursor?: AdditionalOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdditionalOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdditionalOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdditionalOptions.
     */
    distinct?: AdditionalOptionScalarFieldEnum | AdditionalOptionScalarFieldEnum[]
  }

  /**
   * AdditionalOption findFirstOrThrow
   */
  export type AdditionalOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalOption
     */
    select?: AdditionalOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdditionalOption
     */
    omit?: AdditionalOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalOptionInclude<ExtArgs> | null
    /**
     * Filter, which AdditionalOption to fetch.
     */
    where?: AdditionalOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdditionalOptions to fetch.
     */
    orderBy?: AdditionalOptionOrderByWithRelationInput | AdditionalOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdditionalOptions.
     */
    cursor?: AdditionalOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdditionalOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdditionalOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdditionalOptions.
     */
    distinct?: AdditionalOptionScalarFieldEnum | AdditionalOptionScalarFieldEnum[]
  }

  /**
   * AdditionalOption findMany
   */
  export type AdditionalOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalOption
     */
    select?: AdditionalOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdditionalOption
     */
    omit?: AdditionalOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalOptionInclude<ExtArgs> | null
    /**
     * Filter, which AdditionalOptions to fetch.
     */
    where?: AdditionalOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdditionalOptions to fetch.
     */
    orderBy?: AdditionalOptionOrderByWithRelationInput | AdditionalOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdditionalOptions.
     */
    cursor?: AdditionalOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdditionalOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdditionalOptions.
     */
    skip?: number
    distinct?: AdditionalOptionScalarFieldEnum | AdditionalOptionScalarFieldEnum[]
  }

  /**
   * AdditionalOption create
   */
  export type AdditionalOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalOption
     */
    select?: AdditionalOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdditionalOption
     */
    omit?: AdditionalOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalOptionInclude<ExtArgs> | null
    /**
     * The data needed to create a AdditionalOption.
     */
    data: XOR<AdditionalOptionCreateInput, AdditionalOptionUncheckedCreateInput>
  }

  /**
   * AdditionalOption createMany
   */
  export type AdditionalOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdditionalOptions.
     */
    data: AdditionalOptionCreateManyInput | AdditionalOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdditionalOption createManyAndReturn
   */
  export type AdditionalOptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalOption
     */
    select?: AdditionalOptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdditionalOption
     */
    omit?: AdditionalOptionOmit<ExtArgs> | null
    /**
     * The data used to create many AdditionalOptions.
     */
    data: AdditionalOptionCreateManyInput | AdditionalOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdditionalOption update
   */
  export type AdditionalOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalOption
     */
    select?: AdditionalOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdditionalOption
     */
    omit?: AdditionalOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalOptionInclude<ExtArgs> | null
    /**
     * The data needed to update a AdditionalOption.
     */
    data: XOR<AdditionalOptionUpdateInput, AdditionalOptionUncheckedUpdateInput>
    /**
     * Choose, which AdditionalOption to update.
     */
    where: AdditionalOptionWhereUniqueInput
  }

  /**
   * AdditionalOption updateMany
   */
  export type AdditionalOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdditionalOptions.
     */
    data: XOR<AdditionalOptionUpdateManyMutationInput, AdditionalOptionUncheckedUpdateManyInput>
    /**
     * Filter which AdditionalOptions to update
     */
    where?: AdditionalOptionWhereInput
    /**
     * Limit how many AdditionalOptions to update.
     */
    limit?: number
  }

  /**
   * AdditionalOption updateManyAndReturn
   */
  export type AdditionalOptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalOption
     */
    select?: AdditionalOptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdditionalOption
     */
    omit?: AdditionalOptionOmit<ExtArgs> | null
    /**
     * The data used to update AdditionalOptions.
     */
    data: XOR<AdditionalOptionUpdateManyMutationInput, AdditionalOptionUncheckedUpdateManyInput>
    /**
     * Filter which AdditionalOptions to update
     */
    where?: AdditionalOptionWhereInput
    /**
     * Limit how many AdditionalOptions to update.
     */
    limit?: number
  }

  /**
   * AdditionalOption upsert
   */
  export type AdditionalOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalOption
     */
    select?: AdditionalOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdditionalOption
     */
    omit?: AdditionalOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalOptionInclude<ExtArgs> | null
    /**
     * The filter to search for the AdditionalOption to update in case it exists.
     */
    where: AdditionalOptionWhereUniqueInput
    /**
     * In case the AdditionalOption found by the `where` argument doesn't exist, create a new AdditionalOption with this data.
     */
    create: XOR<AdditionalOptionCreateInput, AdditionalOptionUncheckedCreateInput>
    /**
     * In case the AdditionalOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdditionalOptionUpdateInput, AdditionalOptionUncheckedUpdateInput>
  }

  /**
   * AdditionalOption delete
   */
  export type AdditionalOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalOption
     */
    select?: AdditionalOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdditionalOption
     */
    omit?: AdditionalOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalOptionInclude<ExtArgs> | null
    /**
     * Filter which AdditionalOption to delete.
     */
    where: AdditionalOptionWhereUniqueInput
  }

  /**
   * AdditionalOption deleteMany
   */
  export type AdditionalOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdditionalOptions to delete
     */
    where?: AdditionalOptionWhereInput
    /**
     * Limit how many AdditionalOptions to delete.
     */
    limit?: number
  }

  /**
   * AdditionalOption.booking_additional_options
   */
  export type AdditionalOption$booking_additional_optionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingAdditionalOption
     */
    select?: BookingAdditionalOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingAdditionalOption
     */
    omit?: BookingAdditionalOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingAdditionalOptionInclude<ExtArgs> | null
    where?: BookingAdditionalOptionWhereInput
    orderBy?: BookingAdditionalOptionOrderByWithRelationInput | BookingAdditionalOptionOrderByWithRelationInput[]
    cursor?: BookingAdditionalOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingAdditionalOptionScalarFieldEnum | BookingAdditionalOptionScalarFieldEnum[]
  }

  /**
   * AdditionalOption without action
   */
  export type AdditionalOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalOption
     */
    select?: AdditionalOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdditionalOption
     */
    omit?: AdditionalOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalOptionInclude<ExtArgs> | null
  }


  /**
   * Model BookingAdditionalOption
   */

  export type AggregateBookingAdditionalOption = {
    _count: BookingAdditionalOptionCountAggregateOutputType | null
    _avg: BookingAdditionalOptionAvgAggregateOutputType | null
    _sum: BookingAdditionalOptionSumAggregateOutputType | null
    _min: BookingAdditionalOptionMinAggregateOutputType | null
    _max: BookingAdditionalOptionMaxAggregateOutputType | null
  }

  export type BookingAdditionalOptionAvgAggregateOutputType = {
    amount: number | null
  }

  export type BookingAdditionalOptionSumAggregateOutputType = {
    amount: number | null
  }

  export type BookingAdditionalOptionMinAggregateOutputType = {
    id: string | null
    amount: number | null
    option_id: string | null
    booking_id: string | null
    created: Date | null
    updated: Date | null
  }

  export type BookingAdditionalOptionMaxAggregateOutputType = {
    id: string | null
    amount: number | null
    option_id: string | null
    booking_id: string | null
    created: Date | null
    updated: Date | null
  }

  export type BookingAdditionalOptionCountAggregateOutputType = {
    id: number
    amount: number
    option_id: number
    booking_id: number
    created: number
    updated: number
    _all: number
  }


  export type BookingAdditionalOptionAvgAggregateInputType = {
    amount?: true
  }

  export type BookingAdditionalOptionSumAggregateInputType = {
    amount?: true
  }

  export type BookingAdditionalOptionMinAggregateInputType = {
    id?: true
    amount?: true
    option_id?: true
    booking_id?: true
    created?: true
    updated?: true
  }

  export type BookingAdditionalOptionMaxAggregateInputType = {
    id?: true
    amount?: true
    option_id?: true
    booking_id?: true
    created?: true
    updated?: true
  }

  export type BookingAdditionalOptionCountAggregateInputType = {
    id?: true
    amount?: true
    option_id?: true
    booking_id?: true
    created?: true
    updated?: true
    _all?: true
  }

  export type BookingAdditionalOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingAdditionalOption to aggregate.
     */
    where?: BookingAdditionalOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingAdditionalOptions to fetch.
     */
    orderBy?: BookingAdditionalOptionOrderByWithRelationInput | BookingAdditionalOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingAdditionalOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingAdditionalOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingAdditionalOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookingAdditionalOptions
    **/
    _count?: true | BookingAdditionalOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingAdditionalOptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingAdditionalOptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingAdditionalOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingAdditionalOptionMaxAggregateInputType
  }

  export type GetBookingAdditionalOptionAggregateType<T extends BookingAdditionalOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateBookingAdditionalOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookingAdditionalOption[P]>
      : GetScalarType<T[P], AggregateBookingAdditionalOption[P]>
  }




  export type BookingAdditionalOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingAdditionalOptionWhereInput
    orderBy?: BookingAdditionalOptionOrderByWithAggregationInput | BookingAdditionalOptionOrderByWithAggregationInput[]
    by: BookingAdditionalOptionScalarFieldEnum[] | BookingAdditionalOptionScalarFieldEnum
    having?: BookingAdditionalOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingAdditionalOptionCountAggregateInputType | true
    _avg?: BookingAdditionalOptionAvgAggregateInputType
    _sum?: BookingAdditionalOptionSumAggregateInputType
    _min?: BookingAdditionalOptionMinAggregateInputType
    _max?: BookingAdditionalOptionMaxAggregateInputType
  }

  export type BookingAdditionalOptionGroupByOutputType = {
    id: string
    amount: number
    option_id: string
    booking_id: string
    created: Date
    updated: Date
    _count: BookingAdditionalOptionCountAggregateOutputType | null
    _avg: BookingAdditionalOptionAvgAggregateOutputType | null
    _sum: BookingAdditionalOptionSumAggregateOutputType | null
    _min: BookingAdditionalOptionMinAggregateOutputType | null
    _max: BookingAdditionalOptionMaxAggregateOutputType | null
  }

  type GetBookingAdditionalOptionGroupByPayload<T extends BookingAdditionalOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingAdditionalOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingAdditionalOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingAdditionalOptionGroupByOutputType[P]>
            : GetScalarType<T[P], BookingAdditionalOptionGroupByOutputType[P]>
        }
      >
    >


  export type BookingAdditionalOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    option_id?: boolean
    booking_id?: boolean
    created?: boolean
    updated?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    additional_option?: boolean | AdditionalOptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingAdditionalOption"]>

  export type BookingAdditionalOptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    option_id?: boolean
    booking_id?: boolean
    created?: boolean
    updated?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    additional_option?: boolean | AdditionalOptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingAdditionalOption"]>

  export type BookingAdditionalOptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    option_id?: boolean
    booking_id?: boolean
    created?: boolean
    updated?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    additional_option?: boolean | AdditionalOptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingAdditionalOption"]>

  export type BookingAdditionalOptionSelectScalar = {
    id?: boolean
    amount?: boolean
    option_id?: boolean
    booking_id?: boolean
    created?: boolean
    updated?: boolean
  }

  export type BookingAdditionalOptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amount" | "option_id" | "booking_id" | "created" | "updated", ExtArgs["result"]["bookingAdditionalOption"]>
  export type BookingAdditionalOptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    additional_option?: boolean | AdditionalOptionDefaultArgs<ExtArgs>
  }
  export type BookingAdditionalOptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    additional_option?: boolean | AdditionalOptionDefaultArgs<ExtArgs>
  }
  export type BookingAdditionalOptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    additional_option?: boolean | AdditionalOptionDefaultArgs<ExtArgs>
  }

  export type $BookingAdditionalOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookingAdditionalOption"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
      additional_option: Prisma.$AdditionalOptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      amount: number
      option_id: string
      booking_id: string
      created: Date
      updated: Date
    }, ExtArgs["result"]["bookingAdditionalOption"]>
    composites: {}
  }

  type BookingAdditionalOptionGetPayload<S extends boolean | null | undefined | BookingAdditionalOptionDefaultArgs> = $Result.GetResult<Prisma.$BookingAdditionalOptionPayload, S>

  type BookingAdditionalOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingAdditionalOptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingAdditionalOptionCountAggregateInputType | true
    }

  export interface BookingAdditionalOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookingAdditionalOption'], meta: { name: 'BookingAdditionalOption' } }
    /**
     * Find zero or one BookingAdditionalOption that matches the filter.
     * @param {BookingAdditionalOptionFindUniqueArgs} args - Arguments to find a BookingAdditionalOption
     * @example
     * // Get one BookingAdditionalOption
     * const bookingAdditionalOption = await prisma.bookingAdditionalOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingAdditionalOptionFindUniqueArgs>(args: SelectSubset<T, BookingAdditionalOptionFindUniqueArgs<ExtArgs>>): Prisma__BookingAdditionalOptionClient<$Result.GetResult<Prisma.$BookingAdditionalOptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BookingAdditionalOption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingAdditionalOptionFindUniqueOrThrowArgs} args - Arguments to find a BookingAdditionalOption
     * @example
     * // Get one BookingAdditionalOption
     * const bookingAdditionalOption = await prisma.bookingAdditionalOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingAdditionalOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingAdditionalOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingAdditionalOptionClient<$Result.GetResult<Prisma.$BookingAdditionalOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingAdditionalOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAdditionalOptionFindFirstArgs} args - Arguments to find a BookingAdditionalOption
     * @example
     * // Get one BookingAdditionalOption
     * const bookingAdditionalOption = await prisma.bookingAdditionalOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingAdditionalOptionFindFirstArgs>(args?: SelectSubset<T, BookingAdditionalOptionFindFirstArgs<ExtArgs>>): Prisma__BookingAdditionalOptionClient<$Result.GetResult<Prisma.$BookingAdditionalOptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingAdditionalOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAdditionalOptionFindFirstOrThrowArgs} args - Arguments to find a BookingAdditionalOption
     * @example
     * // Get one BookingAdditionalOption
     * const bookingAdditionalOption = await prisma.bookingAdditionalOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingAdditionalOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingAdditionalOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingAdditionalOptionClient<$Result.GetResult<Prisma.$BookingAdditionalOptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BookingAdditionalOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAdditionalOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookingAdditionalOptions
     * const bookingAdditionalOptions = await prisma.bookingAdditionalOption.findMany()
     * 
     * // Get first 10 BookingAdditionalOptions
     * const bookingAdditionalOptions = await prisma.bookingAdditionalOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingAdditionalOptionWithIdOnly = await prisma.bookingAdditionalOption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingAdditionalOptionFindManyArgs>(args?: SelectSubset<T, BookingAdditionalOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingAdditionalOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BookingAdditionalOption.
     * @param {BookingAdditionalOptionCreateArgs} args - Arguments to create a BookingAdditionalOption.
     * @example
     * // Create one BookingAdditionalOption
     * const BookingAdditionalOption = await prisma.bookingAdditionalOption.create({
     *   data: {
     *     // ... data to create a BookingAdditionalOption
     *   }
     * })
     * 
     */
    create<T extends BookingAdditionalOptionCreateArgs>(args: SelectSubset<T, BookingAdditionalOptionCreateArgs<ExtArgs>>): Prisma__BookingAdditionalOptionClient<$Result.GetResult<Prisma.$BookingAdditionalOptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BookingAdditionalOptions.
     * @param {BookingAdditionalOptionCreateManyArgs} args - Arguments to create many BookingAdditionalOptions.
     * @example
     * // Create many BookingAdditionalOptions
     * const bookingAdditionalOption = await prisma.bookingAdditionalOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingAdditionalOptionCreateManyArgs>(args?: SelectSubset<T, BookingAdditionalOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BookingAdditionalOptions and returns the data saved in the database.
     * @param {BookingAdditionalOptionCreateManyAndReturnArgs} args - Arguments to create many BookingAdditionalOptions.
     * @example
     * // Create many BookingAdditionalOptions
     * const bookingAdditionalOption = await prisma.bookingAdditionalOption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BookingAdditionalOptions and only return the `id`
     * const bookingAdditionalOptionWithIdOnly = await prisma.bookingAdditionalOption.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingAdditionalOptionCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingAdditionalOptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingAdditionalOptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BookingAdditionalOption.
     * @param {BookingAdditionalOptionDeleteArgs} args - Arguments to delete one BookingAdditionalOption.
     * @example
     * // Delete one BookingAdditionalOption
     * const BookingAdditionalOption = await prisma.bookingAdditionalOption.delete({
     *   where: {
     *     // ... filter to delete one BookingAdditionalOption
     *   }
     * })
     * 
     */
    delete<T extends BookingAdditionalOptionDeleteArgs>(args: SelectSubset<T, BookingAdditionalOptionDeleteArgs<ExtArgs>>): Prisma__BookingAdditionalOptionClient<$Result.GetResult<Prisma.$BookingAdditionalOptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BookingAdditionalOption.
     * @param {BookingAdditionalOptionUpdateArgs} args - Arguments to update one BookingAdditionalOption.
     * @example
     * // Update one BookingAdditionalOption
     * const bookingAdditionalOption = await prisma.bookingAdditionalOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingAdditionalOptionUpdateArgs>(args: SelectSubset<T, BookingAdditionalOptionUpdateArgs<ExtArgs>>): Prisma__BookingAdditionalOptionClient<$Result.GetResult<Prisma.$BookingAdditionalOptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BookingAdditionalOptions.
     * @param {BookingAdditionalOptionDeleteManyArgs} args - Arguments to filter BookingAdditionalOptions to delete.
     * @example
     * // Delete a few BookingAdditionalOptions
     * const { count } = await prisma.bookingAdditionalOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingAdditionalOptionDeleteManyArgs>(args?: SelectSubset<T, BookingAdditionalOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingAdditionalOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAdditionalOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookingAdditionalOptions
     * const bookingAdditionalOption = await prisma.bookingAdditionalOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingAdditionalOptionUpdateManyArgs>(args: SelectSubset<T, BookingAdditionalOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingAdditionalOptions and returns the data updated in the database.
     * @param {BookingAdditionalOptionUpdateManyAndReturnArgs} args - Arguments to update many BookingAdditionalOptions.
     * @example
     * // Update many BookingAdditionalOptions
     * const bookingAdditionalOption = await prisma.bookingAdditionalOption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BookingAdditionalOptions and only return the `id`
     * const bookingAdditionalOptionWithIdOnly = await prisma.bookingAdditionalOption.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookingAdditionalOptionUpdateManyAndReturnArgs>(args: SelectSubset<T, BookingAdditionalOptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingAdditionalOptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BookingAdditionalOption.
     * @param {BookingAdditionalOptionUpsertArgs} args - Arguments to update or create a BookingAdditionalOption.
     * @example
     * // Update or create a BookingAdditionalOption
     * const bookingAdditionalOption = await prisma.bookingAdditionalOption.upsert({
     *   create: {
     *     // ... data to create a BookingAdditionalOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookingAdditionalOption we want to update
     *   }
     * })
     */
    upsert<T extends BookingAdditionalOptionUpsertArgs>(args: SelectSubset<T, BookingAdditionalOptionUpsertArgs<ExtArgs>>): Prisma__BookingAdditionalOptionClient<$Result.GetResult<Prisma.$BookingAdditionalOptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BookingAdditionalOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAdditionalOptionCountArgs} args - Arguments to filter BookingAdditionalOptions to count.
     * @example
     * // Count the number of BookingAdditionalOptions
     * const count = await prisma.bookingAdditionalOption.count({
     *   where: {
     *     // ... the filter for the BookingAdditionalOptions we want to count
     *   }
     * })
    **/
    count<T extends BookingAdditionalOptionCountArgs>(
      args?: Subset<T, BookingAdditionalOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingAdditionalOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookingAdditionalOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAdditionalOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingAdditionalOptionAggregateArgs>(args: Subset<T, BookingAdditionalOptionAggregateArgs>): Prisma.PrismaPromise<GetBookingAdditionalOptionAggregateType<T>>

    /**
     * Group by BookingAdditionalOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAdditionalOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingAdditionalOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingAdditionalOptionGroupByArgs['orderBy'] }
        : { orderBy?: BookingAdditionalOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingAdditionalOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingAdditionalOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookingAdditionalOption model
   */
  readonly fields: BookingAdditionalOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookingAdditionalOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingAdditionalOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    additional_option<T extends AdditionalOptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdditionalOptionDefaultArgs<ExtArgs>>): Prisma__AdditionalOptionClient<$Result.GetResult<Prisma.$AdditionalOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookingAdditionalOption model
   */
  interface BookingAdditionalOptionFieldRefs {
    readonly id: FieldRef<"BookingAdditionalOption", 'String'>
    readonly amount: FieldRef<"BookingAdditionalOption", 'Int'>
    readonly option_id: FieldRef<"BookingAdditionalOption", 'String'>
    readonly booking_id: FieldRef<"BookingAdditionalOption", 'String'>
    readonly created: FieldRef<"BookingAdditionalOption", 'DateTime'>
    readonly updated: FieldRef<"BookingAdditionalOption", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BookingAdditionalOption findUnique
   */
  export type BookingAdditionalOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingAdditionalOption
     */
    select?: BookingAdditionalOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingAdditionalOption
     */
    omit?: BookingAdditionalOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingAdditionalOptionInclude<ExtArgs> | null
    /**
     * Filter, which BookingAdditionalOption to fetch.
     */
    where: BookingAdditionalOptionWhereUniqueInput
  }

  /**
   * BookingAdditionalOption findUniqueOrThrow
   */
  export type BookingAdditionalOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingAdditionalOption
     */
    select?: BookingAdditionalOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingAdditionalOption
     */
    omit?: BookingAdditionalOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingAdditionalOptionInclude<ExtArgs> | null
    /**
     * Filter, which BookingAdditionalOption to fetch.
     */
    where: BookingAdditionalOptionWhereUniqueInput
  }

  /**
   * BookingAdditionalOption findFirst
   */
  export type BookingAdditionalOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingAdditionalOption
     */
    select?: BookingAdditionalOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingAdditionalOption
     */
    omit?: BookingAdditionalOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingAdditionalOptionInclude<ExtArgs> | null
    /**
     * Filter, which BookingAdditionalOption to fetch.
     */
    where?: BookingAdditionalOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingAdditionalOptions to fetch.
     */
    orderBy?: BookingAdditionalOptionOrderByWithRelationInput | BookingAdditionalOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingAdditionalOptions.
     */
    cursor?: BookingAdditionalOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingAdditionalOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingAdditionalOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingAdditionalOptions.
     */
    distinct?: BookingAdditionalOptionScalarFieldEnum | BookingAdditionalOptionScalarFieldEnum[]
  }

  /**
   * BookingAdditionalOption findFirstOrThrow
   */
  export type BookingAdditionalOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingAdditionalOption
     */
    select?: BookingAdditionalOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingAdditionalOption
     */
    omit?: BookingAdditionalOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingAdditionalOptionInclude<ExtArgs> | null
    /**
     * Filter, which BookingAdditionalOption to fetch.
     */
    where?: BookingAdditionalOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingAdditionalOptions to fetch.
     */
    orderBy?: BookingAdditionalOptionOrderByWithRelationInput | BookingAdditionalOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingAdditionalOptions.
     */
    cursor?: BookingAdditionalOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingAdditionalOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingAdditionalOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingAdditionalOptions.
     */
    distinct?: BookingAdditionalOptionScalarFieldEnum | BookingAdditionalOptionScalarFieldEnum[]
  }

  /**
   * BookingAdditionalOption findMany
   */
  export type BookingAdditionalOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingAdditionalOption
     */
    select?: BookingAdditionalOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingAdditionalOption
     */
    omit?: BookingAdditionalOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingAdditionalOptionInclude<ExtArgs> | null
    /**
     * Filter, which BookingAdditionalOptions to fetch.
     */
    where?: BookingAdditionalOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingAdditionalOptions to fetch.
     */
    orderBy?: BookingAdditionalOptionOrderByWithRelationInput | BookingAdditionalOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookingAdditionalOptions.
     */
    cursor?: BookingAdditionalOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingAdditionalOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingAdditionalOptions.
     */
    skip?: number
    distinct?: BookingAdditionalOptionScalarFieldEnum | BookingAdditionalOptionScalarFieldEnum[]
  }

  /**
   * BookingAdditionalOption create
   */
  export type BookingAdditionalOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingAdditionalOption
     */
    select?: BookingAdditionalOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingAdditionalOption
     */
    omit?: BookingAdditionalOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingAdditionalOptionInclude<ExtArgs> | null
    /**
     * The data needed to create a BookingAdditionalOption.
     */
    data: XOR<BookingAdditionalOptionCreateInput, BookingAdditionalOptionUncheckedCreateInput>
  }

  /**
   * BookingAdditionalOption createMany
   */
  export type BookingAdditionalOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookingAdditionalOptions.
     */
    data: BookingAdditionalOptionCreateManyInput | BookingAdditionalOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookingAdditionalOption createManyAndReturn
   */
  export type BookingAdditionalOptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingAdditionalOption
     */
    select?: BookingAdditionalOptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingAdditionalOption
     */
    omit?: BookingAdditionalOptionOmit<ExtArgs> | null
    /**
     * The data used to create many BookingAdditionalOptions.
     */
    data: BookingAdditionalOptionCreateManyInput | BookingAdditionalOptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingAdditionalOptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingAdditionalOption update
   */
  export type BookingAdditionalOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingAdditionalOption
     */
    select?: BookingAdditionalOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingAdditionalOption
     */
    omit?: BookingAdditionalOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingAdditionalOptionInclude<ExtArgs> | null
    /**
     * The data needed to update a BookingAdditionalOption.
     */
    data: XOR<BookingAdditionalOptionUpdateInput, BookingAdditionalOptionUncheckedUpdateInput>
    /**
     * Choose, which BookingAdditionalOption to update.
     */
    where: BookingAdditionalOptionWhereUniqueInput
  }

  /**
   * BookingAdditionalOption updateMany
   */
  export type BookingAdditionalOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookingAdditionalOptions.
     */
    data: XOR<BookingAdditionalOptionUpdateManyMutationInput, BookingAdditionalOptionUncheckedUpdateManyInput>
    /**
     * Filter which BookingAdditionalOptions to update
     */
    where?: BookingAdditionalOptionWhereInput
    /**
     * Limit how many BookingAdditionalOptions to update.
     */
    limit?: number
  }

  /**
   * BookingAdditionalOption updateManyAndReturn
   */
  export type BookingAdditionalOptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingAdditionalOption
     */
    select?: BookingAdditionalOptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingAdditionalOption
     */
    omit?: BookingAdditionalOptionOmit<ExtArgs> | null
    /**
     * The data used to update BookingAdditionalOptions.
     */
    data: XOR<BookingAdditionalOptionUpdateManyMutationInput, BookingAdditionalOptionUncheckedUpdateManyInput>
    /**
     * Filter which BookingAdditionalOptions to update
     */
    where?: BookingAdditionalOptionWhereInput
    /**
     * Limit how many BookingAdditionalOptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingAdditionalOptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingAdditionalOption upsert
   */
  export type BookingAdditionalOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingAdditionalOption
     */
    select?: BookingAdditionalOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingAdditionalOption
     */
    omit?: BookingAdditionalOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingAdditionalOptionInclude<ExtArgs> | null
    /**
     * The filter to search for the BookingAdditionalOption to update in case it exists.
     */
    where: BookingAdditionalOptionWhereUniqueInput
    /**
     * In case the BookingAdditionalOption found by the `where` argument doesn't exist, create a new BookingAdditionalOption with this data.
     */
    create: XOR<BookingAdditionalOptionCreateInput, BookingAdditionalOptionUncheckedCreateInput>
    /**
     * In case the BookingAdditionalOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingAdditionalOptionUpdateInput, BookingAdditionalOptionUncheckedUpdateInput>
  }

  /**
   * BookingAdditionalOption delete
   */
  export type BookingAdditionalOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingAdditionalOption
     */
    select?: BookingAdditionalOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingAdditionalOption
     */
    omit?: BookingAdditionalOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingAdditionalOptionInclude<ExtArgs> | null
    /**
     * Filter which BookingAdditionalOption to delete.
     */
    where: BookingAdditionalOptionWhereUniqueInput
  }

  /**
   * BookingAdditionalOption deleteMany
   */
  export type BookingAdditionalOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingAdditionalOptions to delete
     */
    where?: BookingAdditionalOptionWhereInput
    /**
     * Limit how many BookingAdditionalOptions to delete.
     */
    limit?: number
  }

  /**
   * BookingAdditionalOption without action
   */
  export type BookingAdditionalOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingAdditionalOption
     */
    select?: BookingAdditionalOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingAdditionalOption
     */
    omit?: BookingAdditionalOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingAdditionalOptionInclude<ExtArgs> | null
  }


  /**
   * Model BookingEvent
   */

  export type AggregateBookingEvent = {
    _count: BookingEventCountAggregateOutputType | null
    _avg: BookingEventAvgAggregateOutputType | null
    _sum: BookingEventSumAggregateOutputType | null
    _min: BookingEventMinAggregateOutputType | null
    _max: BookingEventMaxAggregateOutputType | null
  }

  export type BookingEventAvgAggregateOutputType = {
    number_of_people: number | null
  }

  export type BookingEventSumAggregateOutputType = {
    number_of_people: number | null
  }

  export type BookingEventMinAggregateOutputType = {
    id: string | null
    number_of_people: number | null
    booking_id: string | null
    event_id: string | null
    transaction_id: string | null
    created: Date | null
    updated: Date | null
    is_excluded: boolean | null
  }

  export type BookingEventMaxAggregateOutputType = {
    id: string | null
    number_of_people: number | null
    booking_id: string | null
    event_id: string | null
    transaction_id: string | null
    created: Date | null
    updated: Date | null
    is_excluded: boolean | null
  }

  export type BookingEventCountAggregateOutputType = {
    id: number
    number_of_people: number
    booking_id: number
    event_id: number
    transaction_id: number
    created: number
    updated: number
    is_excluded: number
    _all: number
  }


  export type BookingEventAvgAggregateInputType = {
    number_of_people?: true
  }

  export type BookingEventSumAggregateInputType = {
    number_of_people?: true
  }

  export type BookingEventMinAggregateInputType = {
    id?: true
    number_of_people?: true
    booking_id?: true
    event_id?: true
    transaction_id?: true
    created?: true
    updated?: true
    is_excluded?: true
  }

  export type BookingEventMaxAggregateInputType = {
    id?: true
    number_of_people?: true
    booking_id?: true
    event_id?: true
    transaction_id?: true
    created?: true
    updated?: true
    is_excluded?: true
  }

  export type BookingEventCountAggregateInputType = {
    id?: true
    number_of_people?: true
    booking_id?: true
    event_id?: true
    transaction_id?: true
    created?: true
    updated?: true
    is_excluded?: true
    _all?: true
  }

  export type BookingEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingEvent to aggregate.
     */
    where?: BookingEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingEvents to fetch.
     */
    orderBy?: BookingEventOrderByWithRelationInput | BookingEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookingEvents
    **/
    _count?: true | BookingEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingEventMaxAggregateInputType
  }

  export type GetBookingEventAggregateType<T extends BookingEventAggregateArgs> = {
        [P in keyof T & keyof AggregateBookingEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookingEvent[P]>
      : GetScalarType<T[P], AggregateBookingEvent[P]>
  }




  export type BookingEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingEventWhereInput
    orderBy?: BookingEventOrderByWithAggregationInput | BookingEventOrderByWithAggregationInput[]
    by: BookingEventScalarFieldEnum[] | BookingEventScalarFieldEnum
    having?: BookingEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingEventCountAggregateInputType | true
    _avg?: BookingEventAvgAggregateInputType
    _sum?: BookingEventSumAggregateInputType
    _min?: BookingEventMinAggregateInputType
    _max?: BookingEventMaxAggregateInputType
  }

  export type BookingEventGroupByOutputType = {
    id: string
    number_of_people: number
    booking_id: string
    event_id: string
    transaction_id: string
    created: Date
    updated: Date
    is_excluded: boolean
    _count: BookingEventCountAggregateOutputType | null
    _avg: BookingEventAvgAggregateOutputType | null
    _sum: BookingEventSumAggregateOutputType | null
    _min: BookingEventMinAggregateOutputType | null
    _max: BookingEventMaxAggregateOutputType | null
  }

  type GetBookingEventGroupByPayload<T extends BookingEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingEventGroupByOutputType[P]>
            : GetScalarType<T[P], BookingEventGroupByOutputType[P]>
        }
      >
    >


  export type BookingEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number_of_people?: boolean
    booking_id?: boolean
    event_id?: boolean
    transaction_id?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingEvent"]>

  export type BookingEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number_of_people?: boolean
    booking_id?: boolean
    event_id?: boolean
    transaction_id?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingEvent"]>

  export type BookingEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number_of_people?: boolean
    booking_id?: boolean
    event_id?: boolean
    transaction_id?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingEvent"]>

  export type BookingEventSelectScalar = {
    id?: boolean
    number_of_people?: boolean
    booking_id?: boolean
    event_id?: boolean
    transaction_id?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
  }

  export type BookingEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "number_of_people" | "booking_id" | "event_id" | "transaction_id" | "created" | "updated" | "is_excluded", ExtArgs["result"]["bookingEvent"]>
  export type BookingEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }
  export type BookingEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }
  export type BookingEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }

  export type $BookingEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookingEvent"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
      event: Prisma.$EventPayload<ExtArgs>
      transaction: Prisma.$TransactionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      number_of_people: number
      booking_id: string
      event_id: string
      transaction_id: string
      created: Date
      updated: Date
      is_excluded: boolean
    }, ExtArgs["result"]["bookingEvent"]>
    composites: {}
  }

  type BookingEventGetPayload<S extends boolean | null | undefined | BookingEventDefaultArgs> = $Result.GetResult<Prisma.$BookingEventPayload, S>

  type BookingEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingEventCountAggregateInputType | true
    }

  export interface BookingEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookingEvent'], meta: { name: 'BookingEvent' } }
    /**
     * Find zero or one BookingEvent that matches the filter.
     * @param {BookingEventFindUniqueArgs} args - Arguments to find a BookingEvent
     * @example
     * // Get one BookingEvent
     * const bookingEvent = await prisma.bookingEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingEventFindUniqueArgs>(args: SelectSubset<T, BookingEventFindUniqueArgs<ExtArgs>>): Prisma__BookingEventClient<$Result.GetResult<Prisma.$BookingEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BookingEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingEventFindUniqueOrThrowArgs} args - Arguments to find a BookingEvent
     * @example
     * // Get one BookingEvent
     * const bookingEvent = await prisma.bookingEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingEventFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingEventClient<$Result.GetResult<Prisma.$BookingEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingEventFindFirstArgs} args - Arguments to find a BookingEvent
     * @example
     * // Get one BookingEvent
     * const bookingEvent = await prisma.bookingEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingEventFindFirstArgs>(args?: SelectSubset<T, BookingEventFindFirstArgs<ExtArgs>>): Prisma__BookingEventClient<$Result.GetResult<Prisma.$BookingEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingEventFindFirstOrThrowArgs} args - Arguments to find a BookingEvent
     * @example
     * // Get one BookingEvent
     * const bookingEvent = await prisma.bookingEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingEventFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingEventClient<$Result.GetResult<Prisma.$BookingEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BookingEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookingEvents
     * const bookingEvents = await prisma.bookingEvent.findMany()
     * 
     * // Get first 10 BookingEvents
     * const bookingEvents = await prisma.bookingEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingEventWithIdOnly = await prisma.bookingEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingEventFindManyArgs>(args?: SelectSubset<T, BookingEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BookingEvent.
     * @param {BookingEventCreateArgs} args - Arguments to create a BookingEvent.
     * @example
     * // Create one BookingEvent
     * const BookingEvent = await prisma.bookingEvent.create({
     *   data: {
     *     // ... data to create a BookingEvent
     *   }
     * })
     * 
     */
    create<T extends BookingEventCreateArgs>(args: SelectSubset<T, BookingEventCreateArgs<ExtArgs>>): Prisma__BookingEventClient<$Result.GetResult<Prisma.$BookingEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BookingEvents.
     * @param {BookingEventCreateManyArgs} args - Arguments to create many BookingEvents.
     * @example
     * // Create many BookingEvents
     * const bookingEvent = await prisma.bookingEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingEventCreateManyArgs>(args?: SelectSubset<T, BookingEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BookingEvents and returns the data saved in the database.
     * @param {BookingEventCreateManyAndReturnArgs} args - Arguments to create many BookingEvents.
     * @example
     * // Create many BookingEvents
     * const bookingEvent = await prisma.bookingEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BookingEvents and only return the `id`
     * const bookingEventWithIdOnly = await prisma.bookingEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingEventCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BookingEvent.
     * @param {BookingEventDeleteArgs} args - Arguments to delete one BookingEvent.
     * @example
     * // Delete one BookingEvent
     * const BookingEvent = await prisma.bookingEvent.delete({
     *   where: {
     *     // ... filter to delete one BookingEvent
     *   }
     * })
     * 
     */
    delete<T extends BookingEventDeleteArgs>(args: SelectSubset<T, BookingEventDeleteArgs<ExtArgs>>): Prisma__BookingEventClient<$Result.GetResult<Prisma.$BookingEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BookingEvent.
     * @param {BookingEventUpdateArgs} args - Arguments to update one BookingEvent.
     * @example
     * // Update one BookingEvent
     * const bookingEvent = await prisma.bookingEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingEventUpdateArgs>(args: SelectSubset<T, BookingEventUpdateArgs<ExtArgs>>): Prisma__BookingEventClient<$Result.GetResult<Prisma.$BookingEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BookingEvents.
     * @param {BookingEventDeleteManyArgs} args - Arguments to filter BookingEvents to delete.
     * @example
     * // Delete a few BookingEvents
     * const { count } = await prisma.bookingEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingEventDeleteManyArgs>(args?: SelectSubset<T, BookingEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookingEvents
     * const bookingEvent = await prisma.bookingEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingEventUpdateManyArgs>(args: SelectSubset<T, BookingEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingEvents and returns the data updated in the database.
     * @param {BookingEventUpdateManyAndReturnArgs} args - Arguments to update many BookingEvents.
     * @example
     * // Update many BookingEvents
     * const bookingEvent = await prisma.bookingEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BookingEvents and only return the `id`
     * const bookingEventWithIdOnly = await prisma.bookingEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookingEventUpdateManyAndReturnArgs>(args: SelectSubset<T, BookingEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BookingEvent.
     * @param {BookingEventUpsertArgs} args - Arguments to update or create a BookingEvent.
     * @example
     * // Update or create a BookingEvent
     * const bookingEvent = await prisma.bookingEvent.upsert({
     *   create: {
     *     // ... data to create a BookingEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookingEvent we want to update
     *   }
     * })
     */
    upsert<T extends BookingEventUpsertArgs>(args: SelectSubset<T, BookingEventUpsertArgs<ExtArgs>>): Prisma__BookingEventClient<$Result.GetResult<Prisma.$BookingEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BookingEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingEventCountArgs} args - Arguments to filter BookingEvents to count.
     * @example
     * // Count the number of BookingEvents
     * const count = await prisma.bookingEvent.count({
     *   where: {
     *     // ... the filter for the BookingEvents we want to count
     *   }
     * })
    **/
    count<T extends BookingEventCountArgs>(
      args?: Subset<T, BookingEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookingEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingEventAggregateArgs>(args: Subset<T, BookingEventAggregateArgs>): Prisma.PrismaPromise<GetBookingEventAggregateType<T>>

    /**
     * Group by BookingEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingEventGroupByArgs['orderBy'] }
        : { orderBy?: BookingEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookingEvent model
   */
  readonly fields: BookingEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookingEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transaction<T extends TransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransactionDefaultArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookingEvent model
   */
  interface BookingEventFieldRefs {
    readonly id: FieldRef<"BookingEvent", 'String'>
    readonly number_of_people: FieldRef<"BookingEvent", 'Int'>
    readonly booking_id: FieldRef<"BookingEvent", 'String'>
    readonly event_id: FieldRef<"BookingEvent", 'String'>
    readonly transaction_id: FieldRef<"BookingEvent", 'String'>
    readonly created: FieldRef<"BookingEvent", 'DateTime'>
    readonly updated: FieldRef<"BookingEvent", 'DateTime'>
    readonly is_excluded: FieldRef<"BookingEvent", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * BookingEvent findUnique
   */
  export type BookingEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingEvent
     */
    select?: BookingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingEvent
     */
    omit?: BookingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingEventInclude<ExtArgs> | null
    /**
     * Filter, which BookingEvent to fetch.
     */
    where: BookingEventWhereUniqueInput
  }

  /**
   * BookingEvent findUniqueOrThrow
   */
  export type BookingEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingEvent
     */
    select?: BookingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingEvent
     */
    omit?: BookingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingEventInclude<ExtArgs> | null
    /**
     * Filter, which BookingEvent to fetch.
     */
    where: BookingEventWhereUniqueInput
  }

  /**
   * BookingEvent findFirst
   */
  export type BookingEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingEvent
     */
    select?: BookingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingEvent
     */
    omit?: BookingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingEventInclude<ExtArgs> | null
    /**
     * Filter, which BookingEvent to fetch.
     */
    where?: BookingEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingEvents to fetch.
     */
    orderBy?: BookingEventOrderByWithRelationInput | BookingEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingEvents.
     */
    cursor?: BookingEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingEvents.
     */
    distinct?: BookingEventScalarFieldEnum | BookingEventScalarFieldEnum[]
  }

  /**
   * BookingEvent findFirstOrThrow
   */
  export type BookingEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingEvent
     */
    select?: BookingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingEvent
     */
    omit?: BookingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingEventInclude<ExtArgs> | null
    /**
     * Filter, which BookingEvent to fetch.
     */
    where?: BookingEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingEvents to fetch.
     */
    orderBy?: BookingEventOrderByWithRelationInput | BookingEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingEvents.
     */
    cursor?: BookingEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingEvents.
     */
    distinct?: BookingEventScalarFieldEnum | BookingEventScalarFieldEnum[]
  }

  /**
   * BookingEvent findMany
   */
  export type BookingEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingEvent
     */
    select?: BookingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingEvent
     */
    omit?: BookingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingEventInclude<ExtArgs> | null
    /**
     * Filter, which BookingEvents to fetch.
     */
    where?: BookingEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingEvents to fetch.
     */
    orderBy?: BookingEventOrderByWithRelationInput | BookingEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookingEvents.
     */
    cursor?: BookingEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingEvents.
     */
    skip?: number
    distinct?: BookingEventScalarFieldEnum | BookingEventScalarFieldEnum[]
  }

  /**
   * BookingEvent create
   */
  export type BookingEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingEvent
     */
    select?: BookingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingEvent
     */
    omit?: BookingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingEventInclude<ExtArgs> | null
    /**
     * The data needed to create a BookingEvent.
     */
    data: XOR<BookingEventCreateInput, BookingEventUncheckedCreateInput>
  }

  /**
   * BookingEvent createMany
   */
  export type BookingEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookingEvents.
     */
    data: BookingEventCreateManyInput | BookingEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookingEvent createManyAndReturn
   */
  export type BookingEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingEvent
     */
    select?: BookingEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingEvent
     */
    omit?: BookingEventOmit<ExtArgs> | null
    /**
     * The data used to create many BookingEvents.
     */
    data: BookingEventCreateManyInput | BookingEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingEvent update
   */
  export type BookingEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingEvent
     */
    select?: BookingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingEvent
     */
    omit?: BookingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingEventInclude<ExtArgs> | null
    /**
     * The data needed to update a BookingEvent.
     */
    data: XOR<BookingEventUpdateInput, BookingEventUncheckedUpdateInput>
    /**
     * Choose, which BookingEvent to update.
     */
    where: BookingEventWhereUniqueInput
  }

  /**
   * BookingEvent updateMany
   */
  export type BookingEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookingEvents.
     */
    data: XOR<BookingEventUpdateManyMutationInput, BookingEventUncheckedUpdateManyInput>
    /**
     * Filter which BookingEvents to update
     */
    where?: BookingEventWhereInput
    /**
     * Limit how many BookingEvents to update.
     */
    limit?: number
  }

  /**
   * BookingEvent updateManyAndReturn
   */
  export type BookingEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingEvent
     */
    select?: BookingEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingEvent
     */
    omit?: BookingEventOmit<ExtArgs> | null
    /**
     * The data used to update BookingEvents.
     */
    data: XOR<BookingEventUpdateManyMutationInput, BookingEventUncheckedUpdateManyInput>
    /**
     * Filter which BookingEvents to update
     */
    where?: BookingEventWhereInput
    /**
     * Limit how many BookingEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingEvent upsert
   */
  export type BookingEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingEvent
     */
    select?: BookingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingEvent
     */
    omit?: BookingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingEventInclude<ExtArgs> | null
    /**
     * The filter to search for the BookingEvent to update in case it exists.
     */
    where: BookingEventWhereUniqueInput
    /**
     * In case the BookingEvent found by the `where` argument doesn't exist, create a new BookingEvent with this data.
     */
    create: XOR<BookingEventCreateInput, BookingEventUncheckedCreateInput>
    /**
     * In case the BookingEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingEventUpdateInput, BookingEventUncheckedUpdateInput>
  }

  /**
   * BookingEvent delete
   */
  export type BookingEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingEvent
     */
    select?: BookingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingEvent
     */
    omit?: BookingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingEventInclude<ExtArgs> | null
    /**
     * Filter which BookingEvent to delete.
     */
    where: BookingEventWhereUniqueInput
  }

  /**
   * BookingEvent deleteMany
   */
  export type BookingEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingEvents to delete
     */
    where?: BookingEventWhereInput
    /**
     * Limit how many BookingEvents to delete.
     */
    limit?: number
  }

  /**
   * BookingEvent without action
   */
  export type BookingEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingEvent
     */
    select?: BookingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingEvent
     */
    omit?: BookingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingEventInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amount: number | null
  }

  export type TransactionSumAggregateOutputType = {
    amount: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    amount: number | null
    user_id: string | null
    description: string | null
    card_details_id: string | null
    transfer_details_id: string | null
    transaction_type: $Enums.TransactionType | null
    transaction_status: $Enums.TransactionStatus | null
    payment_method: $Enums.PaymentMethod | null
    created: Date | null
    updated: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    amount: number | null
    user_id: string | null
    description: string | null
    card_details_id: string | null
    transfer_details_id: string | null
    transaction_type: $Enums.TransactionType | null
    transaction_status: $Enums.TransactionStatus | null
    payment_method: $Enums.PaymentMethod | null
    created: Date | null
    updated: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    amount: number
    user_id: number
    description: number
    card_details_id: number
    transfer_details_id: number
    transaction_type: number
    transaction_status: number
    payment_method: number
    created: number
    updated: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amount?: true
  }

  export type TransactionSumAggregateInputType = {
    amount?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    amount?: true
    user_id?: true
    description?: true
    card_details_id?: true
    transfer_details_id?: true
    transaction_type?: true
    transaction_status?: true
    payment_method?: true
    created?: true
    updated?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    amount?: true
    user_id?: true
    description?: true
    card_details_id?: true
    transfer_details_id?: true
    transaction_type?: true
    transaction_status?: true
    payment_method?: true
    created?: true
    updated?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    amount?: true
    user_id?: true
    description?: true
    card_details_id?: true
    transfer_details_id?: true
    transaction_type?: true
    transaction_status?: true
    payment_method?: true
    created?: true
    updated?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    amount: number
    user_id: string
    description: string
    card_details_id: string | null
    transfer_details_id: string | null
    transaction_type: $Enums.TransactionType
    transaction_status: $Enums.TransactionStatus
    payment_method: $Enums.PaymentMethod
    created: Date
    updated: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    user_id?: boolean
    description?: boolean
    card_details_id?: boolean
    transfer_details_id?: boolean
    transaction_type?: boolean
    transaction_status?: boolean
    payment_method?: boolean
    created?: boolean
    updated?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    card_detail?: boolean | Transaction$card_detailArgs<ExtArgs>
    transfer_detail?: boolean | Transaction$transfer_detailArgs<ExtArgs>
    booking?: boolean | Transaction$bookingArgs<ExtArgs>
    booking_event?: boolean | Transaction$booking_eventArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    user_id?: boolean
    description?: boolean
    card_details_id?: boolean
    transfer_details_id?: boolean
    transaction_type?: boolean
    transaction_status?: boolean
    payment_method?: boolean
    created?: boolean
    updated?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    card_detail?: boolean | Transaction$card_detailArgs<ExtArgs>
    transfer_detail?: boolean | Transaction$transfer_detailArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    user_id?: boolean
    description?: boolean
    card_details_id?: boolean
    transfer_details_id?: boolean
    transaction_type?: boolean
    transaction_status?: boolean
    payment_method?: boolean
    created?: boolean
    updated?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    card_detail?: boolean | Transaction$card_detailArgs<ExtArgs>
    transfer_detail?: boolean | Transaction$transfer_detailArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    amount?: boolean
    user_id?: boolean
    description?: boolean
    card_details_id?: boolean
    transfer_details_id?: boolean
    transaction_type?: boolean
    transaction_status?: boolean
    payment_method?: boolean
    created?: boolean
    updated?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amount" | "user_id" | "description" | "card_details_id" | "transfer_details_id" | "transaction_type" | "transaction_status" | "payment_method" | "created" | "updated", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    card_detail?: boolean | Transaction$card_detailArgs<ExtArgs>
    transfer_detail?: boolean | Transaction$transfer_detailArgs<ExtArgs>
    booking?: boolean | Transaction$bookingArgs<ExtArgs>
    booking_event?: boolean | Transaction$booking_eventArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    card_detail?: boolean | Transaction$card_detailArgs<ExtArgs>
    transfer_detail?: boolean | Transaction$transfer_detailArgs<ExtArgs>
  }
  export type TransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    card_detail?: boolean | Transaction$card_detailArgs<ExtArgs>
    transfer_detail?: boolean | Transaction$transfer_detailArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      card_detail: Prisma.$CardDetailPayload<ExtArgs> | null
      transfer_detail: Prisma.$TransferDetailPayload<ExtArgs> | null
      booking: Prisma.$BookingPayload<ExtArgs> | null
      booking_event: Prisma.$BookingEventPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      amount: number
      user_id: string
      description: string
      card_details_id: string | null
      transfer_details_id: string | null
      transaction_type: $Enums.TransactionType
      transaction_status: $Enums.TransactionStatus
      payment_method: $Enums.PaymentMethod
      created: Date
      updated: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {TransactionUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    card_detail<T extends Transaction$card_detailArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$card_detailArgs<ExtArgs>>): Prisma__CardDetailClient<$Result.GetResult<Prisma.$CardDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    transfer_detail<T extends Transaction$transfer_detailArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$transfer_detailArgs<ExtArgs>>): Prisma__TransferDetailClient<$Result.GetResult<Prisma.$TransferDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    booking<T extends Transaction$bookingArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$bookingArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    booking_event<T extends Transaction$booking_eventArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$booking_eventArgs<ExtArgs>>): Prisma__BookingEventClient<$Result.GetResult<Prisma.$BookingEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly amount: FieldRef<"Transaction", 'Float'>
    readonly user_id: FieldRef<"Transaction", 'String'>
    readonly description: FieldRef<"Transaction", 'String'>
    readonly card_details_id: FieldRef<"Transaction", 'String'>
    readonly transfer_details_id: FieldRef<"Transaction", 'String'>
    readonly transaction_type: FieldRef<"Transaction", 'TransactionType'>
    readonly transaction_status: FieldRef<"Transaction", 'TransactionStatus'>
    readonly payment_method: FieldRef<"Transaction", 'PaymentMethod'>
    readonly created: FieldRef<"Transaction", 'DateTime'>
    readonly updated: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction updateManyAndReturn
   */
  export type TransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction.card_detail
   */
  export type Transaction$card_detailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardDetail
     */
    select?: CardDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardDetail
     */
    omit?: CardDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardDetailInclude<ExtArgs> | null
    where?: CardDetailWhereInput
  }

  /**
   * Transaction.transfer_detail
   */
  export type Transaction$transfer_detailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferDetail
     */
    select?: TransferDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferDetail
     */
    omit?: TransferDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferDetailInclude<ExtArgs> | null
    where?: TransferDetailWhereInput
  }

  /**
   * Transaction.booking
   */
  export type Transaction$bookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
  }

  /**
   * Transaction.booking_event
   */
  export type Transaction$booking_eventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingEvent
     */
    select?: BookingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingEvent
     */
    omit?: BookingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingEventInclude<ExtArgs> | null
    where?: BookingEventWhereInput
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model TransferDetail
   */

  export type AggregateTransferDetail = {
    _count: TransferDetailCountAggregateOutputType | null
    _min: TransferDetailMinAggregateOutputType | null
    _max: TransferDetailMaxAggregateOutputType | null
  }

  export type TransferDetailMinAggregateOutputType = {
    id: string | null
    bank_name: string | null
    account_number: string | null
    swift: string | null
    payer_name: string | null
    user_id: string | null
    created: Date | null
    updated: Date | null
  }

  export type TransferDetailMaxAggregateOutputType = {
    id: string | null
    bank_name: string | null
    account_number: string | null
    swift: string | null
    payer_name: string | null
    user_id: string | null
    created: Date | null
    updated: Date | null
  }

  export type TransferDetailCountAggregateOutputType = {
    id: number
    bank_name: number
    account_number: number
    swift: number
    payer_name: number
    user_id: number
    created: number
    updated: number
    _all: number
  }


  export type TransferDetailMinAggregateInputType = {
    id?: true
    bank_name?: true
    account_number?: true
    swift?: true
    payer_name?: true
    user_id?: true
    created?: true
    updated?: true
  }

  export type TransferDetailMaxAggregateInputType = {
    id?: true
    bank_name?: true
    account_number?: true
    swift?: true
    payer_name?: true
    user_id?: true
    created?: true
    updated?: true
  }

  export type TransferDetailCountAggregateInputType = {
    id?: true
    bank_name?: true
    account_number?: true
    swift?: true
    payer_name?: true
    user_id?: true
    created?: true
    updated?: true
    _all?: true
  }

  export type TransferDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransferDetail to aggregate.
     */
    where?: TransferDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferDetails to fetch.
     */
    orderBy?: TransferDetailOrderByWithRelationInput | TransferDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransferDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransferDetails
    **/
    _count?: true | TransferDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransferDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransferDetailMaxAggregateInputType
  }

  export type GetTransferDetailAggregateType<T extends TransferDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateTransferDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransferDetail[P]>
      : GetScalarType<T[P], AggregateTransferDetail[P]>
  }




  export type TransferDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferDetailWhereInput
    orderBy?: TransferDetailOrderByWithAggregationInput | TransferDetailOrderByWithAggregationInput[]
    by: TransferDetailScalarFieldEnum[] | TransferDetailScalarFieldEnum
    having?: TransferDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransferDetailCountAggregateInputType | true
    _min?: TransferDetailMinAggregateInputType
    _max?: TransferDetailMaxAggregateInputType
  }

  export type TransferDetailGroupByOutputType = {
    id: string
    bank_name: string
    account_number: string
    swift: string
    payer_name: string
    user_id: string
    created: Date
    updated: Date
    _count: TransferDetailCountAggregateOutputType | null
    _min: TransferDetailMinAggregateOutputType | null
    _max: TransferDetailMaxAggregateOutputType | null
  }

  type GetTransferDetailGroupByPayload<T extends TransferDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransferDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransferDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransferDetailGroupByOutputType[P]>
            : GetScalarType<T[P], TransferDetailGroupByOutputType[P]>
        }
      >
    >


  export type TransferDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bank_name?: boolean
    account_number?: boolean
    swift?: boolean
    payer_name?: boolean
    user_id?: boolean
    created?: boolean
    updated?: boolean
    transactions?: boolean | TransferDetail$transactionsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | TransferDetailCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transferDetail"]>

  export type TransferDetailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bank_name?: boolean
    account_number?: boolean
    swift?: boolean
    payer_name?: boolean
    user_id?: boolean
    created?: boolean
    updated?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transferDetail"]>

  export type TransferDetailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bank_name?: boolean
    account_number?: boolean
    swift?: boolean
    payer_name?: boolean
    user_id?: boolean
    created?: boolean
    updated?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transferDetail"]>

  export type TransferDetailSelectScalar = {
    id?: boolean
    bank_name?: boolean
    account_number?: boolean
    swift?: boolean
    payer_name?: boolean
    user_id?: boolean
    created?: boolean
    updated?: boolean
  }

  export type TransferDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bank_name" | "account_number" | "swift" | "payer_name" | "user_id" | "created" | "updated", ExtArgs["result"]["transferDetail"]>
  export type TransferDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | TransferDetail$transactionsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | TransferDetailCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TransferDetailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TransferDetailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TransferDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransferDetail"
    objects: {
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bank_name: string
      account_number: string
      swift: string
      payer_name: string
      user_id: string
      created: Date
      updated: Date
    }, ExtArgs["result"]["transferDetail"]>
    composites: {}
  }

  type TransferDetailGetPayload<S extends boolean | null | undefined | TransferDetailDefaultArgs> = $Result.GetResult<Prisma.$TransferDetailPayload, S>

  type TransferDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransferDetailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransferDetailCountAggregateInputType | true
    }

  export interface TransferDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransferDetail'], meta: { name: 'TransferDetail' } }
    /**
     * Find zero or one TransferDetail that matches the filter.
     * @param {TransferDetailFindUniqueArgs} args - Arguments to find a TransferDetail
     * @example
     * // Get one TransferDetail
     * const transferDetail = await prisma.transferDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransferDetailFindUniqueArgs>(args: SelectSubset<T, TransferDetailFindUniqueArgs<ExtArgs>>): Prisma__TransferDetailClient<$Result.GetResult<Prisma.$TransferDetailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TransferDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransferDetailFindUniqueOrThrowArgs} args - Arguments to find a TransferDetail
     * @example
     * // Get one TransferDetail
     * const transferDetail = await prisma.transferDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransferDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, TransferDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransferDetailClient<$Result.GetResult<Prisma.$TransferDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransferDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferDetailFindFirstArgs} args - Arguments to find a TransferDetail
     * @example
     * // Get one TransferDetail
     * const transferDetail = await prisma.transferDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransferDetailFindFirstArgs>(args?: SelectSubset<T, TransferDetailFindFirstArgs<ExtArgs>>): Prisma__TransferDetailClient<$Result.GetResult<Prisma.$TransferDetailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransferDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferDetailFindFirstOrThrowArgs} args - Arguments to find a TransferDetail
     * @example
     * // Get one TransferDetail
     * const transferDetail = await prisma.transferDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransferDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, TransferDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransferDetailClient<$Result.GetResult<Prisma.$TransferDetailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TransferDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransferDetails
     * const transferDetails = await prisma.transferDetail.findMany()
     * 
     * // Get first 10 TransferDetails
     * const transferDetails = await prisma.transferDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transferDetailWithIdOnly = await prisma.transferDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransferDetailFindManyArgs>(args?: SelectSubset<T, TransferDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TransferDetail.
     * @param {TransferDetailCreateArgs} args - Arguments to create a TransferDetail.
     * @example
     * // Create one TransferDetail
     * const TransferDetail = await prisma.transferDetail.create({
     *   data: {
     *     // ... data to create a TransferDetail
     *   }
     * })
     * 
     */
    create<T extends TransferDetailCreateArgs>(args: SelectSubset<T, TransferDetailCreateArgs<ExtArgs>>): Prisma__TransferDetailClient<$Result.GetResult<Prisma.$TransferDetailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TransferDetails.
     * @param {TransferDetailCreateManyArgs} args - Arguments to create many TransferDetails.
     * @example
     * // Create many TransferDetails
     * const transferDetail = await prisma.transferDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransferDetailCreateManyArgs>(args?: SelectSubset<T, TransferDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TransferDetails and returns the data saved in the database.
     * @param {TransferDetailCreateManyAndReturnArgs} args - Arguments to create many TransferDetails.
     * @example
     * // Create many TransferDetails
     * const transferDetail = await prisma.transferDetail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TransferDetails and only return the `id`
     * const transferDetailWithIdOnly = await prisma.transferDetail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransferDetailCreateManyAndReturnArgs>(args?: SelectSubset<T, TransferDetailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferDetailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TransferDetail.
     * @param {TransferDetailDeleteArgs} args - Arguments to delete one TransferDetail.
     * @example
     * // Delete one TransferDetail
     * const TransferDetail = await prisma.transferDetail.delete({
     *   where: {
     *     // ... filter to delete one TransferDetail
     *   }
     * })
     * 
     */
    delete<T extends TransferDetailDeleteArgs>(args: SelectSubset<T, TransferDetailDeleteArgs<ExtArgs>>): Prisma__TransferDetailClient<$Result.GetResult<Prisma.$TransferDetailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TransferDetail.
     * @param {TransferDetailUpdateArgs} args - Arguments to update one TransferDetail.
     * @example
     * // Update one TransferDetail
     * const transferDetail = await prisma.transferDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransferDetailUpdateArgs>(args: SelectSubset<T, TransferDetailUpdateArgs<ExtArgs>>): Prisma__TransferDetailClient<$Result.GetResult<Prisma.$TransferDetailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TransferDetails.
     * @param {TransferDetailDeleteManyArgs} args - Arguments to filter TransferDetails to delete.
     * @example
     * // Delete a few TransferDetails
     * const { count } = await prisma.transferDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransferDetailDeleteManyArgs>(args?: SelectSubset<T, TransferDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransferDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransferDetails
     * const transferDetail = await prisma.transferDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransferDetailUpdateManyArgs>(args: SelectSubset<T, TransferDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransferDetails and returns the data updated in the database.
     * @param {TransferDetailUpdateManyAndReturnArgs} args - Arguments to update many TransferDetails.
     * @example
     * // Update many TransferDetails
     * const transferDetail = await prisma.transferDetail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TransferDetails and only return the `id`
     * const transferDetailWithIdOnly = await prisma.transferDetail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransferDetailUpdateManyAndReturnArgs>(args: SelectSubset<T, TransferDetailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferDetailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TransferDetail.
     * @param {TransferDetailUpsertArgs} args - Arguments to update or create a TransferDetail.
     * @example
     * // Update or create a TransferDetail
     * const transferDetail = await prisma.transferDetail.upsert({
     *   create: {
     *     // ... data to create a TransferDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransferDetail we want to update
     *   }
     * })
     */
    upsert<T extends TransferDetailUpsertArgs>(args: SelectSubset<T, TransferDetailUpsertArgs<ExtArgs>>): Prisma__TransferDetailClient<$Result.GetResult<Prisma.$TransferDetailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TransferDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferDetailCountArgs} args - Arguments to filter TransferDetails to count.
     * @example
     * // Count the number of TransferDetails
     * const count = await prisma.transferDetail.count({
     *   where: {
     *     // ... the filter for the TransferDetails we want to count
     *   }
     * })
    **/
    count<T extends TransferDetailCountArgs>(
      args?: Subset<T, TransferDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransferDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransferDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransferDetailAggregateArgs>(args: Subset<T, TransferDetailAggregateArgs>): Prisma.PrismaPromise<GetTransferDetailAggregateType<T>>

    /**
     * Group by TransferDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransferDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransferDetailGroupByArgs['orderBy'] }
        : { orderBy?: TransferDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransferDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransferDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransferDetail model
   */
  readonly fields: TransferDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransferDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransferDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactions<T extends TransferDetail$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, TransferDetail$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TransferDetail model
   */
  interface TransferDetailFieldRefs {
    readonly id: FieldRef<"TransferDetail", 'String'>
    readonly bank_name: FieldRef<"TransferDetail", 'String'>
    readonly account_number: FieldRef<"TransferDetail", 'String'>
    readonly swift: FieldRef<"TransferDetail", 'String'>
    readonly payer_name: FieldRef<"TransferDetail", 'String'>
    readonly user_id: FieldRef<"TransferDetail", 'String'>
    readonly created: FieldRef<"TransferDetail", 'DateTime'>
    readonly updated: FieldRef<"TransferDetail", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TransferDetail findUnique
   */
  export type TransferDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferDetail
     */
    select?: TransferDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferDetail
     */
    omit?: TransferDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferDetailInclude<ExtArgs> | null
    /**
     * Filter, which TransferDetail to fetch.
     */
    where: TransferDetailWhereUniqueInput
  }

  /**
   * TransferDetail findUniqueOrThrow
   */
  export type TransferDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferDetail
     */
    select?: TransferDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferDetail
     */
    omit?: TransferDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferDetailInclude<ExtArgs> | null
    /**
     * Filter, which TransferDetail to fetch.
     */
    where: TransferDetailWhereUniqueInput
  }

  /**
   * TransferDetail findFirst
   */
  export type TransferDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferDetail
     */
    select?: TransferDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferDetail
     */
    omit?: TransferDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferDetailInclude<ExtArgs> | null
    /**
     * Filter, which TransferDetail to fetch.
     */
    where?: TransferDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferDetails to fetch.
     */
    orderBy?: TransferDetailOrderByWithRelationInput | TransferDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransferDetails.
     */
    cursor?: TransferDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransferDetails.
     */
    distinct?: TransferDetailScalarFieldEnum | TransferDetailScalarFieldEnum[]
  }

  /**
   * TransferDetail findFirstOrThrow
   */
  export type TransferDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferDetail
     */
    select?: TransferDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferDetail
     */
    omit?: TransferDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferDetailInclude<ExtArgs> | null
    /**
     * Filter, which TransferDetail to fetch.
     */
    where?: TransferDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferDetails to fetch.
     */
    orderBy?: TransferDetailOrderByWithRelationInput | TransferDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransferDetails.
     */
    cursor?: TransferDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransferDetails.
     */
    distinct?: TransferDetailScalarFieldEnum | TransferDetailScalarFieldEnum[]
  }

  /**
   * TransferDetail findMany
   */
  export type TransferDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferDetail
     */
    select?: TransferDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferDetail
     */
    omit?: TransferDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferDetailInclude<ExtArgs> | null
    /**
     * Filter, which TransferDetails to fetch.
     */
    where?: TransferDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferDetails to fetch.
     */
    orderBy?: TransferDetailOrderByWithRelationInput | TransferDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransferDetails.
     */
    cursor?: TransferDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferDetails.
     */
    skip?: number
    distinct?: TransferDetailScalarFieldEnum | TransferDetailScalarFieldEnum[]
  }

  /**
   * TransferDetail create
   */
  export type TransferDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferDetail
     */
    select?: TransferDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferDetail
     */
    omit?: TransferDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a TransferDetail.
     */
    data: XOR<TransferDetailCreateInput, TransferDetailUncheckedCreateInput>
  }

  /**
   * TransferDetail createMany
   */
  export type TransferDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransferDetails.
     */
    data: TransferDetailCreateManyInput | TransferDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TransferDetail createManyAndReturn
   */
  export type TransferDetailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferDetail
     */
    select?: TransferDetailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransferDetail
     */
    omit?: TransferDetailOmit<ExtArgs> | null
    /**
     * The data used to create many TransferDetails.
     */
    data: TransferDetailCreateManyInput | TransferDetailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferDetailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransferDetail update
   */
  export type TransferDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferDetail
     */
    select?: TransferDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferDetail
     */
    omit?: TransferDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a TransferDetail.
     */
    data: XOR<TransferDetailUpdateInput, TransferDetailUncheckedUpdateInput>
    /**
     * Choose, which TransferDetail to update.
     */
    where: TransferDetailWhereUniqueInput
  }

  /**
   * TransferDetail updateMany
   */
  export type TransferDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransferDetails.
     */
    data: XOR<TransferDetailUpdateManyMutationInput, TransferDetailUncheckedUpdateManyInput>
    /**
     * Filter which TransferDetails to update
     */
    where?: TransferDetailWhereInput
    /**
     * Limit how many TransferDetails to update.
     */
    limit?: number
  }

  /**
   * TransferDetail updateManyAndReturn
   */
  export type TransferDetailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferDetail
     */
    select?: TransferDetailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransferDetail
     */
    omit?: TransferDetailOmit<ExtArgs> | null
    /**
     * The data used to update TransferDetails.
     */
    data: XOR<TransferDetailUpdateManyMutationInput, TransferDetailUncheckedUpdateManyInput>
    /**
     * Filter which TransferDetails to update
     */
    where?: TransferDetailWhereInput
    /**
     * Limit how many TransferDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferDetailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransferDetail upsert
   */
  export type TransferDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferDetail
     */
    select?: TransferDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferDetail
     */
    omit?: TransferDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the TransferDetail to update in case it exists.
     */
    where: TransferDetailWhereUniqueInput
    /**
     * In case the TransferDetail found by the `where` argument doesn't exist, create a new TransferDetail with this data.
     */
    create: XOR<TransferDetailCreateInput, TransferDetailUncheckedCreateInput>
    /**
     * In case the TransferDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransferDetailUpdateInput, TransferDetailUncheckedUpdateInput>
  }

  /**
   * TransferDetail delete
   */
  export type TransferDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferDetail
     */
    select?: TransferDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferDetail
     */
    omit?: TransferDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferDetailInclude<ExtArgs> | null
    /**
     * Filter which TransferDetail to delete.
     */
    where: TransferDetailWhereUniqueInput
  }

  /**
   * TransferDetail deleteMany
   */
  export type TransferDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransferDetails to delete
     */
    where?: TransferDetailWhereInput
    /**
     * Limit how many TransferDetails to delete.
     */
    limit?: number
  }

  /**
   * TransferDetail.transactions
   */
  export type TransferDetail$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * TransferDetail without action
   */
  export type TransferDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferDetail
     */
    select?: TransferDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferDetail
     */
    omit?: TransferDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferDetailInclude<ExtArgs> | null
  }


  /**
   * Model CardDetail
   */

  export type AggregateCardDetail = {
    _count: CardDetailCountAggregateOutputType | null
    _avg: CardDetailAvgAggregateOutputType | null
    _sum: CardDetailSumAggregateOutputType | null
    _min: CardDetailMinAggregateOutputType | null
    _max: CardDetailMaxAggregateOutputType | null
  }

  export type CardDetailAvgAggregateOutputType = {
    expiry_month: number | null
    expiry_year: number | null
  }

  export type CardDetailSumAggregateOutputType = {
    expiry_month: number | null
    expiry_year: number | null
  }

  export type CardDetailMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    number: string | null
    expiry_month: number | null
    expiry_year: number | null
    holder: string | null
    token: string | null
    created: Date | null
    updated: Date | null
    is_excluded: boolean | null
  }

  export type CardDetailMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    number: string | null
    expiry_month: number | null
    expiry_year: number | null
    holder: string | null
    token: string | null
    created: Date | null
    updated: Date | null
    is_excluded: boolean | null
  }

  export type CardDetailCountAggregateOutputType = {
    id: number
    user_id: number
    number: number
    expiry_month: number
    expiry_year: number
    holder: number
    token: number
    created: number
    updated: number
    is_excluded: number
    _all: number
  }


  export type CardDetailAvgAggregateInputType = {
    expiry_month?: true
    expiry_year?: true
  }

  export type CardDetailSumAggregateInputType = {
    expiry_month?: true
    expiry_year?: true
  }

  export type CardDetailMinAggregateInputType = {
    id?: true
    user_id?: true
    number?: true
    expiry_month?: true
    expiry_year?: true
    holder?: true
    token?: true
    created?: true
    updated?: true
    is_excluded?: true
  }

  export type CardDetailMaxAggregateInputType = {
    id?: true
    user_id?: true
    number?: true
    expiry_month?: true
    expiry_year?: true
    holder?: true
    token?: true
    created?: true
    updated?: true
    is_excluded?: true
  }

  export type CardDetailCountAggregateInputType = {
    id?: true
    user_id?: true
    number?: true
    expiry_month?: true
    expiry_year?: true
    holder?: true
    token?: true
    created?: true
    updated?: true
    is_excluded?: true
    _all?: true
  }

  export type CardDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CardDetail to aggregate.
     */
    where?: CardDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardDetails to fetch.
     */
    orderBy?: CardDetailOrderByWithRelationInput | CardDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CardDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CardDetails
    **/
    _count?: true | CardDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CardDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CardDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CardDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CardDetailMaxAggregateInputType
  }

  export type GetCardDetailAggregateType<T extends CardDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateCardDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCardDetail[P]>
      : GetScalarType<T[P], AggregateCardDetail[P]>
  }




  export type CardDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CardDetailWhereInput
    orderBy?: CardDetailOrderByWithAggregationInput | CardDetailOrderByWithAggregationInput[]
    by: CardDetailScalarFieldEnum[] | CardDetailScalarFieldEnum
    having?: CardDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CardDetailCountAggregateInputType | true
    _avg?: CardDetailAvgAggregateInputType
    _sum?: CardDetailSumAggregateInputType
    _min?: CardDetailMinAggregateInputType
    _max?: CardDetailMaxAggregateInputType
  }

  export type CardDetailGroupByOutputType = {
    id: string
    user_id: string
    number: string
    expiry_month: number
    expiry_year: number
    holder: string
    token: string
    created: Date
    updated: Date
    is_excluded: boolean
    _count: CardDetailCountAggregateOutputType | null
    _avg: CardDetailAvgAggregateOutputType | null
    _sum: CardDetailSumAggregateOutputType | null
    _min: CardDetailMinAggregateOutputType | null
    _max: CardDetailMaxAggregateOutputType | null
  }

  type GetCardDetailGroupByPayload<T extends CardDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CardDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CardDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CardDetailGroupByOutputType[P]>
            : GetScalarType<T[P], CardDetailGroupByOutputType[P]>
        }
      >
    >


  export type CardDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    number?: boolean
    expiry_month?: boolean
    expiry_year?: boolean
    holder?: boolean
    token?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
    transactions?: boolean | CardDetail$transactionsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | CardDetailCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cardDetail"]>

  export type CardDetailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    number?: boolean
    expiry_month?: boolean
    expiry_year?: boolean
    holder?: boolean
    token?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cardDetail"]>

  export type CardDetailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    number?: boolean
    expiry_month?: boolean
    expiry_year?: boolean
    holder?: boolean
    token?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cardDetail"]>

  export type CardDetailSelectScalar = {
    id?: boolean
    user_id?: boolean
    number?: boolean
    expiry_month?: boolean
    expiry_year?: boolean
    holder?: boolean
    token?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
  }

  export type CardDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "number" | "expiry_month" | "expiry_year" | "holder" | "token" | "created" | "updated" | "is_excluded", ExtArgs["result"]["cardDetail"]>
  export type CardDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | CardDetail$transactionsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | CardDetailCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CardDetailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CardDetailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CardDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CardDetail"
    objects: {
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      number: string
      expiry_month: number
      expiry_year: number
      holder: string
      token: string
      created: Date
      updated: Date
      is_excluded: boolean
    }, ExtArgs["result"]["cardDetail"]>
    composites: {}
  }

  type CardDetailGetPayload<S extends boolean | null | undefined | CardDetailDefaultArgs> = $Result.GetResult<Prisma.$CardDetailPayload, S>

  type CardDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CardDetailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CardDetailCountAggregateInputType | true
    }

  export interface CardDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CardDetail'], meta: { name: 'CardDetail' } }
    /**
     * Find zero or one CardDetail that matches the filter.
     * @param {CardDetailFindUniqueArgs} args - Arguments to find a CardDetail
     * @example
     * // Get one CardDetail
     * const cardDetail = await prisma.cardDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CardDetailFindUniqueArgs>(args: SelectSubset<T, CardDetailFindUniqueArgs<ExtArgs>>): Prisma__CardDetailClient<$Result.GetResult<Prisma.$CardDetailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CardDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CardDetailFindUniqueOrThrowArgs} args - Arguments to find a CardDetail
     * @example
     * // Get one CardDetail
     * const cardDetail = await prisma.cardDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CardDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, CardDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CardDetailClient<$Result.GetResult<Prisma.$CardDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CardDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardDetailFindFirstArgs} args - Arguments to find a CardDetail
     * @example
     * // Get one CardDetail
     * const cardDetail = await prisma.cardDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CardDetailFindFirstArgs>(args?: SelectSubset<T, CardDetailFindFirstArgs<ExtArgs>>): Prisma__CardDetailClient<$Result.GetResult<Prisma.$CardDetailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CardDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardDetailFindFirstOrThrowArgs} args - Arguments to find a CardDetail
     * @example
     * // Get one CardDetail
     * const cardDetail = await prisma.cardDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CardDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, CardDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__CardDetailClient<$Result.GetResult<Prisma.$CardDetailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CardDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CardDetails
     * const cardDetails = await prisma.cardDetail.findMany()
     * 
     * // Get first 10 CardDetails
     * const cardDetails = await prisma.cardDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cardDetailWithIdOnly = await prisma.cardDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CardDetailFindManyArgs>(args?: SelectSubset<T, CardDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CardDetail.
     * @param {CardDetailCreateArgs} args - Arguments to create a CardDetail.
     * @example
     * // Create one CardDetail
     * const CardDetail = await prisma.cardDetail.create({
     *   data: {
     *     // ... data to create a CardDetail
     *   }
     * })
     * 
     */
    create<T extends CardDetailCreateArgs>(args: SelectSubset<T, CardDetailCreateArgs<ExtArgs>>): Prisma__CardDetailClient<$Result.GetResult<Prisma.$CardDetailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CardDetails.
     * @param {CardDetailCreateManyArgs} args - Arguments to create many CardDetails.
     * @example
     * // Create many CardDetails
     * const cardDetail = await prisma.cardDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CardDetailCreateManyArgs>(args?: SelectSubset<T, CardDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CardDetails and returns the data saved in the database.
     * @param {CardDetailCreateManyAndReturnArgs} args - Arguments to create many CardDetails.
     * @example
     * // Create many CardDetails
     * const cardDetail = await prisma.cardDetail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CardDetails and only return the `id`
     * const cardDetailWithIdOnly = await prisma.cardDetail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CardDetailCreateManyAndReturnArgs>(args?: SelectSubset<T, CardDetailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardDetailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CardDetail.
     * @param {CardDetailDeleteArgs} args - Arguments to delete one CardDetail.
     * @example
     * // Delete one CardDetail
     * const CardDetail = await prisma.cardDetail.delete({
     *   where: {
     *     // ... filter to delete one CardDetail
     *   }
     * })
     * 
     */
    delete<T extends CardDetailDeleteArgs>(args: SelectSubset<T, CardDetailDeleteArgs<ExtArgs>>): Prisma__CardDetailClient<$Result.GetResult<Prisma.$CardDetailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CardDetail.
     * @param {CardDetailUpdateArgs} args - Arguments to update one CardDetail.
     * @example
     * // Update one CardDetail
     * const cardDetail = await prisma.cardDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CardDetailUpdateArgs>(args: SelectSubset<T, CardDetailUpdateArgs<ExtArgs>>): Prisma__CardDetailClient<$Result.GetResult<Prisma.$CardDetailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CardDetails.
     * @param {CardDetailDeleteManyArgs} args - Arguments to filter CardDetails to delete.
     * @example
     * // Delete a few CardDetails
     * const { count } = await prisma.cardDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CardDetailDeleteManyArgs>(args?: SelectSubset<T, CardDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CardDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CardDetails
     * const cardDetail = await prisma.cardDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CardDetailUpdateManyArgs>(args: SelectSubset<T, CardDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CardDetails and returns the data updated in the database.
     * @param {CardDetailUpdateManyAndReturnArgs} args - Arguments to update many CardDetails.
     * @example
     * // Update many CardDetails
     * const cardDetail = await prisma.cardDetail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CardDetails and only return the `id`
     * const cardDetailWithIdOnly = await prisma.cardDetail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CardDetailUpdateManyAndReturnArgs>(args: SelectSubset<T, CardDetailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardDetailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CardDetail.
     * @param {CardDetailUpsertArgs} args - Arguments to update or create a CardDetail.
     * @example
     * // Update or create a CardDetail
     * const cardDetail = await prisma.cardDetail.upsert({
     *   create: {
     *     // ... data to create a CardDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CardDetail we want to update
     *   }
     * })
     */
    upsert<T extends CardDetailUpsertArgs>(args: SelectSubset<T, CardDetailUpsertArgs<ExtArgs>>): Prisma__CardDetailClient<$Result.GetResult<Prisma.$CardDetailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CardDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardDetailCountArgs} args - Arguments to filter CardDetails to count.
     * @example
     * // Count the number of CardDetails
     * const count = await prisma.cardDetail.count({
     *   where: {
     *     // ... the filter for the CardDetails we want to count
     *   }
     * })
    **/
    count<T extends CardDetailCountArgs>(
      args?: Subset<T, CardDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CardDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CardDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CardDetailAggregateArgs>(args: Subset<T, CardDetailAggregateArgs>): Prisma.PrismaPromise<GetCardDetailAggregateType<T>>

    /**
     * Group by CardDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CardDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CardDetailGroupByArgs['orderBy'] }
        : { orderBy?: CardDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CardDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCardDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CardDetail model
   */
  readonly fields: CardDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CardDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CardDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactions<T extends CardDetail$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, CardDetail$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CardDetail model
   */
  interface CardDetailFieldRefs {
    readonly id: FieldRef<"CardDetail", 'String'>
    readonly user_id: FieldRef<"CardDetail", 'String'>
    readonly number: FieldRef<"CardDetail", 'String'>
    readonly expiry_month: FieldRef<"CardDetail", 'Int'>
    readonly expiry_year: FieldRef<"CardDetail", 'Int'>
    readonly holder: FieldRef<"CardDetail", 'String'>
    readonly token: FieldRef<"CardDetail", 'String'>
    readonly created: FieldRef<"CardDetail", 'DateTime'>
    readonly updated: FieldRef<"CardDetail", 'DateTime'>
    readonly is_excluded: FieldRef<"CardDetail", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * CardDetail findUnique
   */
  export type CardDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardDetail
     */
    select?: CardDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardDetail
     */
    omit?: CardDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardDetailInclude<ExtArgs> | null
    /**
     * Filter, which CardDetail to fetch.
     */
    where: CardDetailWhereUniqueInput
  }

  /**
   * CardDetail findUniqueOrThrow
   */
  export type CardDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardDetail
     */
    select?: CardDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardDetail
     */
    omit?: CardDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardDetailInclude<ExtArgs> | null
    /**
     * Filter, which CardDetail to fetch.
     */
    where: CardDetailWhereUniqueInput
  }

  /**
   * CardDetail findFirst
   */
  export type CardDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardDetail
     */
    select?: CardDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardDetail
     */
    omit?: CardDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardDetailInclude<ExtArgs> | null
    /**
     * Filter, which CardDetail to fetch.
     */
    where?: CardDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardDetails to fetch.
     */
    orderBy?: CardDetailOrderByWithRelationInput | CardDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CardDetails.
     */
    cursor?: CardDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CardDetails.
     */
    distinct?: CardDetailScalarFieldEnum | CardDetailScalarFieldEnum[]
  }

  /**
   * CardDetail findFirstOrThrow
   */
  export type CardDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardDetail
     */
    select?: CardDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardDetail
     */
    omit?: CardDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardDetailInclude<ExtArgs> | null
    /**
     * Filter, which CardDetail to fetch.
     */
    where?: CardDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardDetails to fetch.
     */
    orderBy?: CardDetailOrderByWithRelationInput | CardDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CardDetails.
     */
    cursor?: CardDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CardDetails.
     */
    distinct?: CardDetailScalarFieldEnum | CardDetailScalarFieldEnum[]
  }

  /**
   * CardDetail findMany
   */
  export type CardDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardDetail
     */
    select?: CardDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardDetail
     */
    omit?: CardDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardDetailInclude<ExtArgs> | null
    /**
     * Filter, which CardDetails to fetch.
     */
    where?: CardDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardDetails to fetch.
     */
    orderBy?: CardDetailOrderByWithRelationInput | CardDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CardDetails.
     */
    cursor?: CardDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardDetails.
     */
    skip?: number
    distinct?: CardDetailScalarFieldEnum | CardDetailScalarFieldEnum[]
  }

  /**
   * CardDetail create
   */
  export type CardDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardDetail
     */
    select?: CardDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardDetail
     */
    omit?: CardDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a CardDetail.
     */
    data: XOR<CardDetailCreateInput, CardDetailUncheckedCreateInput>
  }

  /**
   * CardDetail createMany
   */
  export type CardDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CardDetails.
     */
    data: CardDetailCreateManyInput | CardDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CardDetail createManyAndReturn
   */
  export type CardDetailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardDetail
     */
    select?: CardDetailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CardDetail
     */
    omit?: CardDetailOmit<ExtArgs> | null
    /**
     * The data used to create many CardDetails.
     */
    data: CardDetailCreateManyInput | CardDetailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardDetailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CardDetail update
   */
  export type CardDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardDetail
     */
    select?: CardDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardDetail
     */
    omit?: CardDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a CardDetail.
     */
    data: XOR<CardDetailUpdateInput, CardDetailUncheckedUpdateInput>
    /**
     * Choose, which CardDetail to update.
     */
    where: CardDetailWhereUniqueInput
  }

  /**
   * CardDetail updateMany
   */
  export type CardDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CardDetails.
     */
    data: XOR<CardDetailUpdateManyMutationInput, CardDetailUncheckedUpdateManyInput>
    /**
     * Filter which CardDetails to update
     */
    where?: CardDetailWhereInput
    /**
     * Limit how many CardDetails to update.
     */
    limit?: number
  }

  /**
   * CardDetail updateManyAndReturn
   */
  export type CardDetailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardDetail
     */
    select?: CardDetailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CardDetail
     */
    omit?: CardDetailOmit<ExtArgs> | null
    /**
     * The data used to update CardDetails.
     */
    data: XOR<CardDetailUpdateManyMutationInput, CardDetailUncheckedUpdateManyInput>
    /**
     * Filter which CardDetails to update
     */
    where?: CardDetailWhereInput
    /**
     * Limit how many CardDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardDetailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CardDetail upsert
   */
  export type CardDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardDetail
     */
    select?: CardDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardDetail
     */
    omit?: CardDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the CardDetail to update in case it exists.
     */
    where: CardDetailWhereUniqueInput
    /**
     * In case the CardDetail found by the `where` argument doesn't exist, create a new CardDetail with this data.
     */
    create: XOR<CardDetailCreateInput, CardDetailUncheckedCreateInput>
    /**
     * In case the CardDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CardDetailUpdateInput, CardDetailUncheckedUpdateInput>
  }

  /**
   * CardDetail delete
   */
  export type CardDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardDetail
     */
    select?: CardDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardDetail
     */
    omit?: CardDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardDetailInclude<ExtArgs> | null
    /**
     * Filter which CardDetail to delete.
     */
    where: CardDetailWhereUniqueInput
  }

  /**
   * CardDetail deleteMany
   */
  export type CardDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CardDetails to delete
     */
    where?: CardDetailWhereInput
    /**
     * Limit how many CardDetails to delete.
     */
    limit?: number
  }

  /**
   * CardDetail.transactions
   */
  export type CardDetail$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * CardDetail without action
   */
  export type CardDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardDetail
     */
    select?: CardDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardDetail
     */
    omit?: CardDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardDetailInclude<ExtArgs> | null
  }


  /**
   * Model Event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventAvgAggregateOutputType = {
    price: number | null
    capacity: number | null
  }

  export type EventSumAggregateOutputType = {
    price: number | null
    capacity: number | null
  }

  export type EventMinAggregateOutputType = {
    id: string | null
    name: string | null
    image: string | null
    description: string | null
    guide_id: string | null
    price: number | null
    capacity: number | null
    start: Date | null
    end: Date | null
    created: Date | null
    updated: Date | null
    is_excluded: boolean | null
  }

  export type EventMaxAggregateOutputType = {
    id: string | null
    name: string | null
    image: string | null
    description: string | null
    guide_id: string | null
    price: number | null
    capacity: number | null
    start: Date | null
    end: Date | null
    created: Date | null
    updated: Date | null
    is_excluded: boolean | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    name: number
    image: number
    description: number
    guide_id: number
    price: number
    capacity: number
    start: number
    end: number
    created: number
    updated: number
    is_excluded: number
    _all: number
  }


  export type EventAvgAggregateInputType = {
    price?: true
    capacity?: true
  }

  export type EventSumAggregateInputType = {
    price?: true
    capacity?: true
  }

  export type EventMinAggregateInputType = {
    id?: true
    name?: true
    image?: true
    description?: true
    guide_id?: true
    price?: true
    capacity?: true
    start?: true
    end?: true
    created?: true
    updated?: true
    is_excluded?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    name?: true
    image?: true
    description?: true
    guide_id?: true
    price?: true
    capacity?: true
    start?: true
    end?: true
    created?: true
    updated?: true
    is_excluded?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    name?: true
    image?: true
    description?: true
    guide_id?: true
    price?: true
    capacity?: true
    start?: true
    end?: true
    created?: true
    updated?: true
    is_excluded?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Event to aggregate.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type EventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
    orderBy?: EventOrderByWithAggregationInput | EventOrderByWithAggregationInput[]
    by: EventScalarFieldEnum[] | EventScalarFieldEnum
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _avg?: EventAvgAggregateInputType
    _sum?: EventSumAggregateInputType
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }

  export type EventGroupByOutputType = {
    id: string
    name: string
    image: string
    description: string
    guide_id: string | null
    price: number
    capacity: number
    start: Date
    end: Date
    created: Date
    updated: Date
    is_excluded: boolean
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type EventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    image?: boolean
    description?: boolean
    guide_id?: boolean
    price?: boolean
    capacity?: boolean
    start?: boolean
    end?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
    guide?: boolean | Event$guideArgs<ExtArgs>
    images?: boolean | Event$imagesArgs<ExtArgs>
    booking_events?: boolean | Event$booking_eventsArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    image?: boolean
    description?: boolean
    guide_id?: boolean
    price?: boolean
    capacity?: boolean
    start?: boolean
    end?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
    guide?: boolean | Event$guideArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    image?: boolean
    description?: boolean
    guide_id?: boolean
    price?: boolean
    capacity?: boolean
    start?: boolean
    end?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
    guide?: boolean | Event$guideArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectScalar = {
    id?: boolean
    name?: boolean
    image?: boolean
    description?: boolean
    guide_id?: boolean
    price?: boolean
    capacity?: boolean
    start?: boolean
    end?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
  }

  export type EventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "image" | "description" | "guide_id" | "price" | "capacity" | "start" | "end" | "created" | "updated" | "is_excluded", ExtArgs["result"]["event"]>
  export type EventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guide?: boolean | Event$guideArgs<ExtArgs>
    images?: boolean | Event$imagesArgs<ExtArgs>
    booking_events?: boolean | Event$booking_eventsArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guide?: boolean | Event$guideArgs<ExtArgs>
  }
  export type EventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guide?: boolean | Event$guideArgs<ExtArgs>
  }

  export type $EventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Event"
    objects: {
      guide: Prisma.$UserPayload<ExtArgs> | null
      images: Prisma.$EventImagePayload<ExtArgs>[]
      booking_events: Prisma.$BookingEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      image: string
      description: string
      guide_id: string | null
      price: number
      capacity: number
      start: Date
      end: Date
      created: Date
      updated: Date
      is_excluded: boolean
    }, ExtArgs["result"]["event"]>
    composites: {}
  }

  type EventGetPayload<S extends boolean | null | undefined | EventDefaultArgs> = $Result.GetResult<Prisma.$EventPayload, S>

  type EventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface EventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Event'], meta: { name: 'Event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventFindUniqueArgs>(args: SelectSubset<T, EventFindUniqueArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventFindUniqueOrThrowArgs>(args: SelectSubset<T, EventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventFindFirstArgs>(args?: SelectSubset<T, EventFindFirstArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventFindFirstOrThrowArgs>(args?: SelectSubset<T, EventFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventFindManyArgs>(args?: SelectSubset<T, EventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
     */
    create<T extends EventCreateArgs>(args: SelectSubset<T, EventCreateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Events.
     * @param {EventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventCreateManyArgs>(args?: SelectSubset<T, EventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Events and returns the data saved in the database.
     * @param {EventCreateManyAndReturnArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventCreateManyAndReturnArgs>(args?: SelectSubset<T, EventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
     */
    delete<T extends EventDeleteArgs>(args: SelectSubset<T, EventDeleteArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventUpdateArgs>(args: SelectSubset<T, EventUpdateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventDeleteManyArgs>(args?: SelectSubset<T, EventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventUpdateManyArgs>(args: SelectSubset<T, EventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events and returns the data updated in the database.
     * @param {EventUpdateManyAndReturnArgs} args - Arguments to update many Events.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventUpdateManyAndReturnArgs>(args: SelectSubset<T, EventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends EventUpsertArgs>(args: SelectSubset<T, EventUpsertArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Event model
   */
  readonly fields: EventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    guide<T extends Event$guideArgs<ExtArgs> = {}>(args?: Subset<T, Event$guideArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    images<T extends Event$imagesArgs<ExtArgs> = {}>(args?: Subset<T, Event$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    booking_events<T extends Event$booking_eventsArgs<ExtArgs> = {}>(args?: Subset<T, Event$booking_eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Event model
   */
  interface EventFieldRefs {
    readonly id: FieldRef<"Event", 'String'>
    readonly name: FieldRef<"Event", 'String'>
    readonly image: FieldRef<"Event", 'String'>
    readonly description: FieldRef<"Event", 'String'>
    readonly guide_id: FieldRef<"Event", 'String'>
    readonly price: FieldRef<"Event", 'Float'>
    readonly capacity: FieldRef<"Event", 'Int'>
    readonly start: FieldRef<"Event", 'DateTime'>
    readonly end: FieldRef<"Event", 'DateTime'>
    readonly created: FieldRef<"Event", 'DateTime'>
    readonly updated: FieldRef<"Event", 'DateTime'>
    readonly is_excluded: FieldRef<"Event", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findUniqueOrThrow
   */
  export type EventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findFirst
   */
  export type EventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findFirstOrThrow
   */
  export type EventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findMany
   */
  export type EventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event create
   */
  export type EventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to create a Event.
     */
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
  }

  /**
   * Event createMany
   */
  export type EventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Event createManyAndReturn
   */
  export type EventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Event update
   */
  export type EventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to update a Event.
     */
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
  }

  /**
   * Event updateManyAndReturn
   */
  export type EventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Event upsert
   */
  export type EventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The filter to search for the Event to update in case it exists.
     */
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     */
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
  }

  /**
   * Event delete
   */
  export type EventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter which Event to delete.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to delete.
     */
    limit?: number
  }

  /**
   * Event.guide
   */
  export type Event$guideArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Event.images
   */
  export type Event$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventImage
     */
    select?: EventImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventImage
     */
    omit?: EventImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventImageInclude<ExtArgs> | null
    where?: EventImageWhereInput
    orderBy?: EventImageOrderByWithRelationInput | EventImageOrderByWithRelationInput[]
    cursor?: EventImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventImageScalarFieldEnum | EventImageScalarFieldEnum[]
  }

  /**
   * Event.booking_events
   */
  export type Event$booking_eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingEvent
     */
    select?: BookingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingEvent
     */
    omit?: BookingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingEventInclude<ExtArgs> | null
    where?: BookingEventWhereInput
    orderBy?: BookingEventOrderByWithRelationInput | BookingEventOrderByWithRelationInput[]
    cursor?: BookingEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingEventScalarFieldEnum | BookingEventScalarFieldEnum[]
  }

  /**
   * Event without action
   */
  export type EventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
  }


  /**
   * Model EventImage
   */

  export type AggregateEventImage = {
    _count: EventImageCountAggregateOutputType | null
    _min: EventImageMinAggregateOutputType | null
    _max: EventImageMaxAggregateOutputType | null
  }

  export type EventImageMinAggregateOutputType = {
    id: string | null
    name: string | null
    image: string | null
    description: string | null
    event_id: string | null
    created: Date | null
    updated: Date | null
    is_excluded: boolean | null
  }

  export type EventImageMaxAggregateOutputType = {
    id: string | null
    name: string | null
    image: string | null
    description: string | null
    event_id: string | null
    created: Date | null
    updated: Date | null
    is_excluded: boolean | null
  }

  export type EventImageCountAggregateOutputType = {
    id: number
    name: number
    image: number
    description: number
    event_id: number
    created: number
    updated: number
    is_excluded: number
    _all: number
  }


  export type EventImageMinAggregateInputType = {
    id?: true
    name?: true
    image?: true
    description?: true
    event_id?: true
    created?: true
    updated?: true
    is_excluded?: true
  }

  export type EventImageMaxAggregateInputType = {
    id?: true
    name?: true
    image?: true
    description?: true
    event_id?: true
    created?: true
    updated?: true
    is_excluded?: true
  }

  export type EventImageCountAggregateInputType = {
    id?: true
    name?: true
    image?: true
    description?: true
    event_id?: true
    created?: true
    updated?: true
    is_excluded?: true
    _all?: true
  }

  export type EventImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventImage to aggregate.
     */
    where?: EventImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventImages to fetch.
     */
    orderBy?: EventImageOrderByWithRelationInput | EventImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventImages
    **/
    _count?: true | EventImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventImageMaxAggregateInputType
  }

  export type GetEventImageAggregateType<T extends EventImageAggregateArgs> = {
        [P in keyof T & keyof AggregateEventImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventImage[P]>
      : GetScalarType<T[P], AggregateEventImage[P]>
  }




  export type EventImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventImageWhereInput
    orderBy?: EventImageOrderByWithAggregationInput | EventImageOrderByWithAggregationInput[]
    by: EventImageScalarFieldEnum[] | EventImageScalarFieldEnum
    having?: EventImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventImageCountAggregateInputType | true
    _min?: EventImageMinAggregateInputType
    _max?: EventImageMaxAggregateInputType
  }

  export type EventImageGroupByOutputType = {
    id: string
    name: string
    image: string | null
    description: string | null
    event_id: string
    created: Date
    updated: Date
    is_excluded: boolean
    _count: EventImageCountAggregateOutputType | null
    _min: EventImageMinAggregateOutputType | null
    _max: EventImageMaxAggregateOutputType | null
  }

  type GetEventImageGroupByPayload<T extends EventImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventImageGroupByOutputType[P]>
            : GetScalarType<T[P], EventImageGroupByOutputType[P]>
        }
      >
    >


  export type EventImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    image?: boolean
    description?: boolean
    event_id?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventImage"]>

  export type EventImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    image?: boolean
    description?: boolean
    event_id?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventImage"]>

  export type EventImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    image?: boolean
    description?: boolean
    event_id?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventImage"]>

  export type EventImageSelectScalar = {
    id?: boolean
    name?: boolean
    image?: boolean
    description?: boolean
    event_id?: boolean
    created?: boolean
    updated?: boolean
    is_excluded?: boolean
  }

  export type EventImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "image" | "description" | "event_id" | "created" | "updated" | "is_excluded", ExtArgs["result"]["eventImage"]>
  export type EventImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
  }
  export type EventImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
  }
  export type EventImageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
  }

  export type $EventImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventImage"
    objects: {
      event: Prisma.$EventPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      image: string | null
      description: string | null
      event_id: string
      created: Date
      updated: Date
      is_excluded: boolean
    }, ExtArgs["result"]["eventImage"]>
    composites: {}
  }

  type EventImageGetPayload<S extends boolean | null | undefined | EventImageDefaultArgs> = $Result.GetResult<Prisma.$EventImagePayload, S>

  type EventImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventImageCountAggregateInputType | true
    }

  export interface EventImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventImage'], meta: { name: 'EventImage' } }
    /**
     * Find zero or one EventImage that matches the filter.
     * @param {EventImageFindUniqueArgs} args - Arguments to find a EventImage
     * @example
     * // Get one EventImage
     * const eventImage = await prisma.eventImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventImageFindUniqueArgs>(args: SelectSubset<T, EventImageFindUniqueArgs<ExtArgs>>): Prisma__EventImageClient<$Result.GetResult<Prisma.$EventImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EventImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventImageFindUniqueOrThrowArgs} args - Arguments to find a EventImage
     * @example
     * // Get one EventImage
     * const eventImage = await prisma.eventImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventImageFindUniqueOrThrowArgs>(args: SelectSubset<T, EventImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventImageClient<$Result.GetResult<Prisma.$EventImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EventImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventImageFindFirstArgs} args - Arguments to find a EventImage
     * @example
     * // Get one EventImage
     * const eventImage = await prisma.eventImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventImageFindFirstArgs>(args?: SelectSubset<T, EventImageFindFirstArgs<ExtArgs>>): Prisma__EventImageClient<$Result.GetResult<Prisma.$EventImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EventImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventImageFindFirstOrThrowArgs} args - Arguments to find a EventImage
     * @example
     * // Get one EventImage
     * const eventImage = await prisma.eventImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventImageFindFirstOrThrowArgs>(args?: SelectSubset<T, EventImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventImageClient<$Result.GetResult<Prisma.$EventImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EventImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventImages
     * const eventImages = await prisma.eventImage.findMany()
     * 
     * // Get first 10 EventImages
     * const eventImages = await prisma.eventImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventImageWithIdOnly = await prisma.eventImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventImageFindManyArgs>(args?: SelectSubset<T, EventImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EventImage.
     * @param {EventImageCreateArgs} args - Arguments to create a EventImage.
     * @example
     * // Create one EventImage
     * const EventImage = await prisma.eventImage.create({
     *   data: {
     *     // ... data to create a EventImage
     *   }
     * })
     * 
     */
    create<T extends EventImageCreateArgs>(args: SelectSubset<T, EventImageCreateArgs<ExtArgs>>): Prisma__EventImageClient<$Result.GetResult<Prisma.$EventImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EventImages.
     * @param {EventImageCreateManyArgs} args - Arguments to create many EventImages.
     * @example
     * // Create many EventImages
     * const eventImage = await prisma.eventImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventImageCreateManyArgs>(args?: SelectSubset<T, EventImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EventImages and returns the data saved in the database.
     * @param {EventImageCreateManyAndReturnArgs} args - Arguments to create many EventImages.
     * @example
     * // Create many EventImages
     * const eventImage = await prisma.eventImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EventImages and only return the `id`
     * const eventImageWithIdOnly = await prisma.eventImage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventImageCreateManyAndReturnArgs>(args?: SelectSubset<T, EventImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EventImage.
     * @param {EventImageDeleteArgs} args - Arguments to delete one EventImage.
     * @example
     * // Delete one EventImage
     * const EventImage = await prisma.eventImage.delete({
     *   where: {
     *     // ... filter to delete one EventImage
     *   }
     * })
     * 
     */
    delete<T extends EventImageDeleteArgs>(args: SelectSubset<T, EventImageDeleteArgs<ExtArgs>>): Prisma__EventImageClient<$Result.GetResult<Prisma.$EventImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EventImage.
     * @param {EventImageUpdateArgs} args - Arguments to update one EventImage.
     * @example
     * // Update one EventImage
     * const eventImage = await prisma.eventImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventImageUpdateArgs>(args: SelectSubset<T, EventImageUpdateArgs<ExtArgs>>): Prisma__EventImageClient<$Result.GetResult<Prisma.$EventImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EventImages.
     * @param {EventImageDeleteManyArgs} args - Arguments to filter EventImages to delete.
     * @example
     * // Delete a few EventImages
     * const { count } = await prisma.eventImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventImageDeleteManyArgs>(args?: SelectSubset<T, EventImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventImages
     * const eventImage = await prisma.eventImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventImageUpdateManyArgs>(args: SelectSubset<T, EventImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventImages and returns the data updated in the database.
     * @param {EventImageUpdateManyAndReturnArgs} args - Arguments to update many EventImages.
     * @example
     * // Update many EventImages
     * const eventImage = await prisma.eventImage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EventImages and only return the `id`
     * const eventImageWithIdOnly = await prisma.eventImage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventImageUpdateManyAndReturnArgs>(args: SelectSubset<T, EventImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EventImage.
     * @param {EventImageUpsertArgs} args - Arguments to update or create a EventImage.
     * @example
     * // Update or create a EventImage
     * const eventImage = await prisma.eventImage.upsert({
     *   create: {
     *     // ... data to create a EventImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventImage we want to update
     *   }
     * })
     */
    upsert<T extends EventImageUpsertArgs>(args: SelectSubset<T, EventImageUpsertArgs<ExtArgs>>): Prisma__EventImageClient<$Result.GetResult<Prisma.$EventImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EventImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventImageCountArgs} args - Arguments to filter EventImages to count.
     * @example
     * // Count the number of EventImages
     * const count = await prisma.eventImage.count({
     *   where: {
     *     // ... the filter for the EventImages we want to count
     *   }
     * })
    **/
    count<T extends EventImageCountArgs>(
      args?: Subset<T, EventImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventImageAggregateArgs>(args: Subset<T, EventImageAggregateArgs>): Prisma.PrismaPromise<GetEventImageAggregateType<T>>

    /**
     * Group by EventImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventImageGroupByArgs['orderBy'] }
        : { orderBy?: EventImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventImage model
   */
  readonly fields: EventImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventImage model
   */
  interface EventImageFieldRefs {
    readonly id: FieldRef<"EventImage", 'String'>
    readonly name: FieldRef<"EventImage", 'String'>
    readonly image: FieldRef<"EventImage", 'String'>
    readonly description: FieldRef<"EventImage", 'String'>
    readonly event_id: FieldRef<"EventImage", 'String'>
    readonly created: FieldRef<"EventImage", 'DateTime'>
    readonly updated: FieldRef<"EventImage", 'DateTime'>
    readonly is_excluded: FieldRef<"EventImage", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * EventImage findUnique
   */
  export type EventImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventImage
     */
    select?: EventImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventImage
     */
    omit?: EventImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventImageInclude<ExtArgs> | null
    /**
     * Filter, which EventImage to fetch.
     */
    where: EventImageWhereUniqueInput
  }

  /**
   * EventImage findUniqueOrThrow
   */
  export type EventImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventImage
     */
    select?: EventImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventImage
     */
    omit?: EventImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventImageInclude<ExtArgs> | null
    /**
     * Filter, which EventImage to fetch.
     */
    where: EventImageWhereUniqueInput
  }

  /**
   * EventImage findFirst
   */
  export type EventImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventImage
     */
    select?: EventImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventImage
     */
    omit?: EventImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventImageInclude<ExtArgs> | null
    /**
     * Filter, which EventImage to fetch.
     */
    where?: EventImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventImages to fetch.
     */
    orderBy?: EventImageOrderByWithRelationInput | EventImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventImages.
     */
    cursor?: EventImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventImages.
     */
    distinct?: EventImageScalarFieldEnum | EventImageScalarFieldEnum[]
  }

  /**
   * EventImage findFirstOrThrow
   */
  export type EventImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventImage
     */
    select?: EventImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventImage
     */
    omit?: EventImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventImageInclude<ExtArgs> | null
    /**
     * Filter, which EventImage to fetch.
     */
    where?: EventImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventImages to fetch.
     */
    orderBy?: EventImageOrderByWithRelationInput | EventImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventImages.
     */
    cursor?: EventImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventImages.
     */
    distinct?: EventImageScalarFieldEnum | EventImageScalarFieldEnum[]
  }

  /**
   * EventImage findMany
   */
  export type EventImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventImage
     */
    select?: EventImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventImage
     */
    omit?: EventImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventImageInclude<ExtArgs> | null
    /**
     * Filter, which EventImages to fetch.
     */
    where?: EventImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventImages to fetch.
     */
    orderBy?: EventImageOrderByWithRelationInput | EventImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventImages.
     */
    cursor?: EventImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventImages.
     */
    skip?: number
    distinct?: EventImageScalarFieldEnum | EventImageScalarFieldEnum[]
  }

  /**
   * EventImage create
   */
  export type EventImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventImage
     */
    select?: EventImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventImage
     */
    omit?: EventImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventImageInclude<ExtArgs> | null
    /**
     * The data needed to create a EventImage.
     */
    data: XOR<EventImageCreateInput, EventImageUncheckedCreateInput>
  }

  /**
   * EventImage createMany
   */
  export type EventImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventImages.
     */
    data: EventImageCreateManyInput | EventImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventImage createManyAndReturn
   */
  export type EventImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventImage
     */
    select?: EventImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EventImage
     */
    omit?: EventImageOmit<ExtArgs> | null
    /**
     * The data used to create many EventImages.
     */
    data: EventImageCreateManyInput | EventImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventImage update
   */
  export type EventImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventImage
     */
    select?: EventImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventImage
     */
    omit?: EventImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventImageInclude<ExtArgs> | null
    /**
     * The data needed to update a EventImage.
     */
    data: XOR<EventImageUpdateInput, EventImageUncheckedUpdateInput>
    /**
     * Choose, which EventImage to update.
     */
    where: EventImageWhereUniqueInput
  }

  /**
   * EventImage updateMany
   */
  export type EventImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventImages.
     */
    data: XOR<EventImageUpdateManyMutationInput, EventImageUncheckedUpdateManyInput>
    /**
     * Filter which EventImages to update
     */
    where?: EventImageWhereInput
    /**
     * Limit how many EventImages to update.
     */
    limit?: number
  }

  /**
   * EventImage updateManyAndReturn
   */
  export type EventImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventImage
     */
    select?: EventImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EventImage
     */
    omit?: EventImageOmit<ExtArgs> | null
    /**
     * The data used to update EventImages.
     */
    data: XOR<EventImageUpdateManyMutationInput, EventImageUncheckedUpdateManyInput>
    /**
     * Filter which EventImages to update
     */
    where?: EventImageWhereInput
    /**
     * Limit how many EventImages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventImageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventImage upsert
   */
  export type EventImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventImage
     */
    select?: EventImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventImage
     */
    omit?: EventImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventImageInclude<ExtArgs> | null
    /**
     * The filter to search for the EventImage to update in case it exists.
     */
    where: EventImageWhereUniqueInput
    /**
     * In case the EventImage found by the `where` argument doesn't exist, create a new EventImage with this data.
     */
    create: XOR<EventImageCreateInput, EventImageUncheckedCreateInput>
    /**
     * In case the EventImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventImageUpdateInput, EventImageUncheckedUpdateInput>
  }

  /**
   * EventImage delete
   */
  export type EventImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventImage
     */
    select?: EventImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventImage
     */
    omit?: EventImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventImageInclude<ExtArgs> | null
    /**
     * Filter which EventImage to delete.
     */
    where: EventImageWhereUniqueInput
  }

  /**
   * EventImage deleteMany
   */
  export type EventImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventImages to delete
     */
    where?: EventImageWhereInput
    /**
     * Limit how many EventImages to delete.
     */
    limit?: number
  }

  /**
   * EventImage without action
   */
  export type EventImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventImage
     */
    select?: EventImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventImage
     */
    omit?: EventImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventImageInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password_hash: 'password_hash',
    image: 'image',
    first_name: 'first_name',
    last_name: 'last_name',
    phone_number: 'phone_number',
    date_of_birth: 'date_of_birth',
    is_active: 'is_active',
    email_verified: 'email_verified',
    phone_verified: 'phone_verified',
    role: 'role',
    created: 'created',
    updated: 'updated'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    type: 'type',
    action: 'action',
    message: 'message',
    user_id: 'user_id',
    is_read: 'is_read',
    created: 'created',
    updated: 'updated'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    sender_id: 'sender_id',
    receiver_id: 'receiver_id',
    message: 'message',
    is_read: 'is_read',
    booking_id: 'booking_id',
    edited: 'edited',
    replace_to: 'replace_to',
    is_excluded: 'is_excluded',
    created: 'created',
    updated: 'updated'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const ApartmentScalarFieldEnum: {
    id: 'id',
    image: 'image',
    name: 'name',
    description: 'description',
    rules: 'rules',
    number: 'number',
    floor: 'floor',
    rooms_count: 'rooms_count',
    max_capacity: 'max_capacity',
    is_available: 'is_available',
    is_smoking: 'is_smoking',
    is_pet_friendly: 'is_pet_friendly',
    deposit: 'deposit',
    type: 'type',
    created: 'created',
    updated: 'updated',
    is_excluded: 'is_excluded'
  };

  export type ApartmentScalarFieldEnum = (typeof ApartmentScalarFieldEnum)[keyof typeof ApartmentScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    apartment_id: 'apartment_id',
    booking_id: 'booking_id',
    rating: 'rating',
    comment: 'comment',
    created: 'created',
    updated: 'updated',
    is_excluded: 'is_excluded'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const AmenityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    image: 'image',
    description: 'description',
    created: 'created',
    updated: 'updated',
    is_excluded: 'is_excluded'
  };

  export type AmenityScalarFieldEnum = (typeof AmenityScalarFieldEnum)[keyof typeof AmenityScalarFieldEnum]


  export const ApartmentAmenityScalarFieldEnum: {
    id: 'id',
    amenity_id: 'amenity_id',
    apartment_id: 'apartment_id',
    created: 'created',
    updated: 'updated',
    is_excluded: 'is_excluded'
  };

  export type ApartmentAmenityScalarFieldEnum = (typeof ApartmentAmenityScalarFieldEnum)[keyof typeof ApartmentAmenityScalarFieldEnum]


  export const ApartmentImageScalarFieldEnum: {
    id: 'id',
    image: 'image',
    name: 'name',
    description: 'description',
    apartment_id: 'apartment_id',
    created: 'created',
    updated: 'updated',
    is_excluded: 'is_excluded'
  };

  export type ApartmentImageScalarFieldEnum = (typeof ApartmentImageScalarFieldEnum)[keyof typeof ApartmentImageScalarFieldEnum]


  export const BedTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    image: 'image',
    created: 'created',
    updated: 'updated',
    is_excluded: 'is_excluded'
  };

  export type BedTypeScalarFieldEnum = (typeof BedTypeScalarFieldEnum)[keyof typeof BedTypeScalarFieldEnum]


  export const ApartmentBedScalarFieldEnum: {
    id: 'id',
    apartment_id: 'apartment_id',
    bed_type_id: 'bed_type_id',
    count: 'count',
    created: 'created',
    updated: 'updated',
    is_excluded: 'is_excluded'
  };

  export type ApartmentBedScalarFieldEnum = (typeof ApartmentBedScalarFieldEnum)[keyof typeof ApartmentBedScalarFieldEnum]


  export const BookingVariantScalarFieldEnum: {
    id: 'id',
    apartment_id: 'apartment_id',
    price: 'price',
    capacity: 'capacity',
    is_available: 'is_available',
    created: 'created',
    updated: 'updated',
    is_excluded: 'is_excluded'
  };

  export type BookingVariantScalarFieldEnum = (typeof BookingVariantScalarFieldEnum)[keyof typeof BookingVariantScalarFieldEnum]


  export const ReservationScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    apartment_id: 'apartment_id',
    start: 'start',
    end: 'end',
    created: 'created',
    updated: 'updated'
  };

  export type ReservationScalarFieldEnum = (typeof ReservationScalarFieldEnum)[keyof typeof ReservationScalarFieldEnum]


  export const BookingScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    booking_variant_id: 'booking_variant_id',
    transaction_id: 'transaction_id',
    message: 'message',
    status: 'status',
    start: 'start',
    end: 'end',
    created: 'created',
    updated: 'updated'
  };

  export type BookingScalarFieldEnum = (typeof BookingScalarFieldEnum)[keyof typeof BookingScalarFieldEnum]


  export const AdditionalOptionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    image: 'image',
    price: 'price',
    created: 'created',
    updated: 'updated',
    is_excluded: 'is_excluded'
  };

  export type AdditionalOptionScalarFieldEnum = (typeof AdditionalOptionScalarFieldEnum)[keyof typeof AdditionalOptionScalarFieldEnum]


  export const BookingAdditionalOptionScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    option_id: 'option_id',
    booking_id: 'booking_id',
    created: 'created',
    updated: 'updated'
  };

  export type BookingAdditionalOptionScalarFieldEnum = (typeof BookingAdditionalOptionScalarFieldEnum)[keyof typeof BookingAdditionalOptionScalarFieldEnum]


  export const BookingEventScalarFieldEnum: {
    id: 'id',
    number_of_people: 'number_of_people',
    booking_id: 'booking_id',
    event_id: 'event_id',
    transaction_id: 'transaction_id',
    created: 'created',
    updated: 'updated',
    is_excluded: 'is_excluded'
  };

  export type BookingEventScalarFieldEnum = (typeof BookingEventScalarFieldEnum)[keyof typeof BookingEventScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    user_id: 'user_id',
    description: 'description',
    card_details_id: 'card_details_id',
    transfer_details_id: 'transfer_details_id',
    transaction_type: 'transaction_type',
    transaction_status: 'transaction_status',
    payment_method: 'payment_method',
    created: 'created',
    updated: 'updated'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const TransferDetailScalarFieldEnum: {
    id: 'id',
    bank_name: 'bank_name',
    account_number: 'account_number',
    swift: 'swift',
    payer_name: 'payer_name',
    user_id: 'user_id',
    created: 'created',
    updated: 'updated'
  };

  export type TransferDetailScalarFieldEnum = (typeof TransferDetailScalarFieldEnum)[keyof typeof TransferDetailScalarFieldEnum]


  export const CardDetailScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    number: 'number',
    expiry_month: 'expiry_month',
    expiry_year: 'expiry_year',
    holder: 'holder',
    token: 'token',
    created: 'created',
    updated: 'updated',
    is_excluded: 'is_excluded'
  };

  export type CardDetailScalarFieldEnum = (typeof CardDetailScalarFieldEnum)[keyof typeof CardDetailScalarFieldEnum]


  export const EventScalarFieldEnum: {
    id: 'id',
    name: 'name',
    image: 'image',
    description: 'description',
    guide_id: 'guide_id',
    price: 'price',
    capacity: 'capacity',
    start: 'start',
    end: 'end',
    created: 'created',
    updated: 'updated',
    is_excluded: 'is_excluded'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const EventImageScalarFieldEnum: {
    id: 'id',
    name: 'name',
    image: 'image',
    description: 'description',
    event_id: 'event_id',
    created: 'created',
    updated: 'updated',
    is_excluded: 'is_excluded'
  };

  export type EventImageScalarFieldEnum = (typeof EventImageScalarFieldEnum)[keyof typeof EventImageScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'NotificationAction'
   */
  export type EnumNotificationActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationAction'>
    


  /**
   * Reference to a field of type 'NotificationAction[]'
   */
  export type ListEnumNotificationActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationAction[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'ApartmentType'
   */
  export type EnumApartmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApartmentType'>
    


  /**
   * Reference to a field of type 'ApartmentType[]'
   */
  export type ListEnumApartmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApartmentType[]'>
    


  /**
   * Reference to a field of type 'BookingStatus'
   */
  export type EnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus'>
    


  /**
   * Reference to a field of type 'BookingStatus[]'
   */
  export type ListEnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus[]'>
    


  /**
   * Reference to a field of type 'TransactionType'
   */
  export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>
    


  /**
   * Reference to a field of type 'TransactionType[]'
   */
  export type ListEnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType[]'>
    


  /**
   * Reference to a field of type 'TransactionStatus'
   */
  export type EnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus'>
    


  /**
   * Reference to a field of type 'TransactionStatus[]'
   */
  export type ListEnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password_hash?: StringFilter<"User"> | string
    image?: StringNullableFilter<"User"> | string | null
    first_name?: StringFilter<"User"> | string
    last_name?: StringFilter<"User"> | string
    phone_number?: StringNullableFilter<"User"> | string | null
    date_of_birth?: DateTimeNullableFilter<"User"> | Date | string | null
    is_active?: BoolFilter<"User"> | boolean
    email_verified?: BoolFilter<"User"> | boolean
    phone_verified?: BoolFilter<"User"> | boolean
    role?: EnumRoleFilter<"User"> | $Enums.Role
    created?: DateTimeFilter<"User"> | Date | string
    updated?: DateTimeFilter<"User"> | Date | string
    reservations?: ReservationListRelationFilter
    events?: EventListRelationFilter
    bookings?: BookingListRelationFilter
    transactions?: TransactionListRelationFilter
    card_details?: CardDetailListRelationFilter
    transfer_details?: TransferDetailListRelationFilter
    reviews?: ReviewListRelationFilter
    sent_messages?: MessageListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    image?: SortOrderInput | SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    phone_number?: SortOrderInput | SortOrder
    date_of_birth?: SortOrderInput | SortOrder
    is_active?: SortOrder
    email_verified?: SortOrder
    phone_verified?: SortOrder
    role?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    reservations?: ReservationOrderByRelationAggregateInput
    events?: EventOrderByRelationAggregateInput
    bookings?: BookingOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    card_details?: CardDetailOrderByRelationAggregateInput
    transfer_details?: TransferDetailOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    sent_messages?: MessageOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password_hash?: StringFilter<"User"> | string
    image?: StringNullableFilter<"User"> | string | null
    first_name?: StringFilter<"User"> | string
    last_name?: StringFilter<"User"> | string
    phone_number?: StringNullableFilter<"User"> | string | null
    date_of_birth?: DateTimeNullableFilter<"User"> | Date | string | null
    is_active?: BoolFilter<"User"> | boolean
    email_verified?: BoolFilter<"User"> | boolean
    phone_verified?: BoolFilter<"User"> | boolean
    role?: EnumRoleFilter<"User"> | $Enums.Role
    created?: DateTimeFilter<"User"> | Date | string
    updated?: DateTimeFilter<"User"> | Date | string
    reservations?: ReservationListRelationFilter
    events?: EventListRelationFilter
    bookings?: BookingListRelationFilter
    transactions?: TransactionListRelationFilter
    card_details?: CardDetailListRelationFilter
    transfer_details?: TransferDetailListRelationFilter
    reviews?: ReviewListRelationFilter
    sent_messages?: MessageListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    image?: SortOrderInput | SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    phone_number?: SortOrderInput | SortOrder
    date_of_birth?: SortOrderInput | SortOrder
    is_active?: SortOrder
    email_verified?: SortOrder
    phone_verified?: SortOrder
    role?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password_hash?: StringWithAggregatesFilter<"User"> | string
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    first_name?: StringWithAggregatesFilter<"User"> | string
    last_name?: StringWithAggregatesFilter<"User"> | string
    phone_number?: StringNullableWithAggregatesFilter<"User"> | string | null
    date_of_birth?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    is_active?: BoolWithAggregatesFilter<"User"> | boolean
    email_verified?: BoolWithAggregatesFilter<"User"> | boolean
    phone_verified?: BoolWithAggregatesFilter<"User"> | boolean
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    created?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updated?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    action?: EnumNotificationActionFilter<"Notification"> | $Enums.NotificationAction
    message?: StringNullableFilter<"Notification"> | string | null
    user_id?: StringNullableFilter<"Notification"> | string | null
    is_read?: BoolFilter<"Notification"> | boolean
    created?: DateTimeFilter<"Notification"> | Date | string
    updated?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    action?: SortOrder
    message?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    is_read?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    action?: EnumNotificationActionFilter<"Notification"> | $Enums.NotificationAction
    message?: StringNullableFilter<"Notification"> | string | null
    user_id?: StringNullableFilter<"Notification"> | string | null
    is_read?: BoolFilter<"Notification"> | boolean
    created?: DateTimeFilter<"Notification"> | Date | string
    updated?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    action?: SortOrder
    message?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    is_read?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    action?: EnumNotificationActionWithAggregatesFilter<"Notification"> | $Enums.NotificationAction
    message?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    user_id?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    is_read?: BoolWithAggregatesFilter<"Notification"> | boolean
    created?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updated?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    sender_id?: StringFilter<"Message"> | string
    receiver_id?: StringFilter<"Message"> | string
    message?: StringFilter<"Message"> | string
    is_read?: BoolFilter<"Message"> | boolean
    booking_id?: StringNullableFilter<"Message"> | string | null
    edited?: DateTimeNullableFilter<"Message"> | Date | string | null
    replace_to?: StringNullableFilter<"Message"> | string | null
    is_excluded?: BoolFilter<"Message"> | boolean
    created?: DateTimeFilter<"Message"> | Date | string
    updated?: DateTimeFilter<"Message"> | Date | string
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    booking?: XOR<BookingNullableScalarRelationFilter, BookingWhereInput> | null
    replaces?: XOR<MessageNullableScalarRelationFilter, MessageWhereInput> | null
    replaced_by?: MessageListRelationFilter
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    sender_id?: SortOrder
    receiver_id?: SortOrder
    message?: SortOrder
    is_read?: SortOrder
    booking_id?: SortOrderInput | SortOrder
    edited?: SortOrderInput | SortOrder
    replace_to?: SortOrderInput | SortOrder
    is_excluded?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    sender?: UserOrderByWithRelationInput
    booking?: BookingOrderByWithRelationInput
    replaces?: MessageOrderByWithRelationInput
    replaced_by?: MessageOrderByRelationAggregateInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    sender_id?: StringFilter<"Message"> | string
    receiver_id?: StringFilter<"Message"> | string
    message?: StringFilter<"Message"> | string
    is_read?: BoolFilter<"Message"> | boolean
    booking_id?: StringNullableFilter<"Message"> | string | null
    edited?: DateTimeNullableFilter<"Message"> | Date | string | null
    replace_to?: StringNullableFilter<"Message"> | string | null
    is_excluded?: BoolFilter<"Message"> | boolean
    created?: DateTimeFilter<"Message"> | Date | string
    updated?: DateTimeFilter<"Message"> | Date | string
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    booking?: XOR<BookingNullableScalarRelationFilter, BookingWhereInput> | null
    replaces?: XOR<MessageNullableScalarRelationFilter, MessageWhereInput> | null
    replaced_by?: MessageListRelationFilter
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    sender_id?: SortOrder
    receiver_id?: SortOrder
    message?: SortOrder
    is_read?: SortOrder
    booking_id?: SortOrderInput | SortOrder
    edited?: SortOrderInput | SortOrder
    replace_to?: SortOrderInput | SortOrder
    is_excluded?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    sender_id?: StringWithAggregatesFilter<"Message"> | string
    receiver_id?: StringWithAggregatesFilter<"Message"> | string
    message?: StringWithAggregatesFilter<"Message"> | string
    is_read?: BoolWithAggregatesFilter<"Message"> | boolean
    booking_id?: StringNullableWithAggregatesFilter<"Message"> | string | null
    edited?: DateTimeNullableWithAggregatesFilter<"Message"> | Date | string | null
    replace_to?: StringNullableWithAggregatesFilter<"Message"> | string | null
    is_excluded?: BoolWithAggregatesFilter<"Message"> | boolean
    created?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    updated?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type ApartmentWhereInput = {
    AND?: ApartmentWhereInput | ApartmentWhereInput[]
    OR?: ApartmentWhereInput[]
    NOT?: ApartmentWhereInput | ApartmentWhereInput[]
    id?: StringFilter<"Apartment"> | string
    image?: StringNullableFilter<"Apartment"> | string | null
    name?: StringNullableFilter<"Apartment"> | string | null
    description?: StringNullableFilter<"Apartment"> | string | null
    rules?: StringNullableFilter<"Apartment"> | string | null
    number?: IntFilter<"Apartment"> | number
    floor?: IntFilter<"Apartment"> | number
    rooms_count?: IntFilter<"Apartment"> | number
    max_capacity?: IntNullableFilter<"Apartment"> | number | null
    is_available?: BoolFilter<"Apartment"> | boolean
    is_smoking?: BoolFilter<"Apartment"> | boolean
    is_pet_friendly?: BoolFilter<"Apartment"> | boolean
    deposit?: FloatFilter<"Apartment"> | number
    type?: EnumApartmentTypeFilter<"Apartment"> | $Enums.ApartmentType
    created?: DateTimeFilter<"Apartment"> | Date | string
    updated?: DateTimeFilter<"Apartment"> | Date | string
    is_excluded?: BoolFilter<"Apartment"> | boolean
    images?: ApartmentImageListRelationFilter
    apartment_beds?: ApartmentBedListRelationFilter
    apartment_amenities?: ApartmentAmenityListRelationFilter
    reservations?: ReservationListRelationFilter
    booking_variants?: BookingVariantListRelationFilter
    reviews?: ReviewListRelationFilter
  }

  export type ApartmentOrderByWithRelationInput = {
    id?: SortOrder
    image?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    rules?: SortOrderInput | SortOrder
    number?: SortOrder
    floor?: SortOrder
    rooms_count?: SortOrder
    max_capacity?: SortOrderInput | SortOrder
    is_available?: SortOrder
    is_smoking?: SortOrder
    is_pet_friendly?: SortOrder
    deposit?: SortOrder
    type?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
    images?: ApartmentImageOrderByRelationAggregateInput
    apartment_beds?: ApartmentBedOrderByRelationAggregateInput
    apartment_amenities?: ApartmentAmenityOrderByRelationAggregateInput
    reservations?: ReservationOrderByRelationAggregateInput
    booking_variants?: BookingVariantOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
  }

  export type ApartmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    number?: number
    AND?: ApartmentWhereInput | ApartmentWhereInput[]
    OR?: ApartmentWhereInput[]
    NOT?: ApartmentWhereInput | ApartmentWhereInput[]
    image?: StringNullableFilter<"Apartment"> | string | null
    name?: StringNullableFilter<"Apartment"> | string | null
    description?: StringNullableFilter<"Apartment"> | string | null
    rules?: StringNullableFilter<"Apartment"> | string | null
    floor?: IntFilter<"Apartment"> | number
    rooms_count?: IntFilter<"Apartment"> | number
    max_capacity?: IntNullableFilter<"Apartment"> | number | null
    is_available?: BoolFilter<"Apartment"> | boolean
    is_smoking?: BoolFilter<"Apartment"> | boolean
    is_pet_friendly?: BoolFilter<"Apartment"> | boolean
    deposit?: FloatFilter<"Apartment"> | number
    type?: EnumApartmentTypeFilter<"Apartment"> | $Enums.ApartmentType
    created?: DateTimeFilter<"Apartment"> | Date | string
    updated?: DateTimeFilter<"Apartment"> | Date | string
    is_excluded?: BoolFilter<"Apartment"> | boolean
    images?: ApartmentImageListRelationFilter
    apartment_beds?: ApartmentBedListRelationFilter
    apartment_amenities?: ApartmentAmenityListRelationFilter
    reservations?: ReservationListRelationFilter
    booking_variants?: BookingVariantListRelationFilter
    reviews?: ReviewListRelationFilter
  }, "id" | "number">

  export type ApartmentOrderByWithAggregationInput = {
    id?: SortOrder
    image?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    rules?: SortOrderInput | SortOrder
    number?: SortOrder
    floor?: SortOrder
    rooms_count?: SortOrder
    max_capacity?: SortOrderInput | SortOrder
    is_available?: SortOrder
    is_smoking?: SortOrder
    is_pet_friendly?: SortOrder
    deposit?: SortOrder
    type?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
    _count?: ApartmentCountOrderByAggregateInput
    _avg?: ApartmentAvgOrderByAggregateInput
    _max?: ApartmentMaxOrderByAggregateInput
    _min?: ApartmentMinOrderByAggregateInput
    _sum?: ApartmentSumOrderByAggregateInput
  }

  export type ApartmentScalarWhereWithAggregatesInput = {
    AND?: ApartmentScalarWhereWithAggregatesInput | ApartmentScalarWhereWithAggregatesInput[]
    OR?: ApartmentScalarWhereWithAggregatesInput[]
    NOT?: ApartmentScalarWhereWithAggregatesInput | ApartmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Apartment"> | string
    image?: StringNullableWithAggregatesFilter<"Apartment"> | string | null
    name?: StringNullableWithAggregatesFilter<"Apartment"> | string | null
    description?: StringNullableWithAggregatesFilter<"Apartment"> | string | null
    rules?: StringNullableWithAggregatesFilter<"Apartment"> | string | null
    number?: IntWithAggregatesFilter<"Apartment"> | number
    floor?: IntWithAggregatesFilter<"Apartment"> | number
    rooms_count?: IntWithAggregatesFilter<"Apartment"> | number
    max_capacity?: IntNullableWithAggregatesFilter<"Apartment"> | number | null
    is_available?: BoolWithAggregatesFilter<"Apartment"> | boolean
    is_smoking?: BoolWithAggregatesFilter<"Apartment"> | boolean
    is_pet_friendly?: BoolWithAggregatesFilter<"Apartment"> | boolean
    deposit?: FloatWithAggregatesFilter<"Apartment"> | number
    type?: EnumApartmentTypeWithAggregatesFilter<"Apartment"> | $Enums.ApartmentType
    created?: DateTimeWithAggregatesFilter<"Apartment"> | Date | string
    updated?: DateTimeWithAggregatesFilter<"Apartment"> | Date | string
    is_excluded?: BoolWithAggregatesFilter<"Apartment"> | boolean
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: StringFilter<"Review"> | string
    user_id?: StringFilter<"Review"> | string
    apartment_id?: StringNullableFilter<"Review"> | string | null
    booking_id?: StringNullableFilter<"Review"> | string | null
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    created?: DateTimeFilter<"Review"> | Date | string
    updated?: DateTimeFilter<"Review"> | Date | string
    is_excluded?: BoolFilter<"Review"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    apartment?: XOR<ApartmentNullableScalarRelationFilter, ApartmentWhereInput> | null
    booking?: XOR<BookingNullableScalarRelationFilter, BookingWhereInput> | null
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    apartment_id?: SortOrderInput | SortOrder
    booking_id?: SortOrderInput | SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
    user?: UserOrderByWithRelationInput
    apartment?: ApartmentOrderByWithRelationInput
    booking?: BookingOrderByWithRelationInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    user_id?: StringFilter<"Review"> | string
    apartment_id?: StringNullableFilter<"Review"> | string | null
    booking_id?: StringNullableFilter<"Review"> | string | null
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    created?: DateTimeFilter<"Review"> | Date | string
    updated?: DateTimeFilter<"Review"> | Date | string
    is_excluded?: BoolFilter<"Review"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    apartment?: XOR<ApartmentNullableScalarRelationFilter, ApartmentWhereInput> | null
    booking?: XOR<BookingNullableScalarRelationFilter, BookingWhereInput> | null
  }, "id">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    apartment_id?: SortOrderInput | SortOrder
    booking_id?: SortOrderInput | SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Review"> | string
    user_id?: StringWithAggregatesFilter<"Review"> | string
    apartment_id?: StringNullableWithAggregatesFilter<"Review"> | string | null
    booking_id?: StringNullableWithAggregatesFilter<"Review"> | string | null
    rating?: IntWithAggregatesFilter<"Review"> | number
    comment?: StringNullableWithAggregatesFilter<"Review"> | string | null
    created?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    updated?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    is_excluded?: BoolWithAggregatesFilter<"Review"> | boolean
  }

  export type AmenityWhereInput = {
    AND?: AmenityWhereInput | AmenityWhereInput[]
    OR?: AmenityWhereInput[]
    NOT?: AmenityWhereInput | AmenityWhereInput[]
    id?: StringFilter<"Amenity"> | string
    name?: StringFilter<"Amenity"> | string
    image?: StringFilter<"Amenity"> | string
    description?: StringNullableFilter<"Amenity"> | string | null
    created?: DateTimeFilter<"Amenity"> | Date | string
    updated?: DateTimeFilter<"Amenity"> | Date | string
    is_excluded?: BoolFilter<"Amenity"> | boolean
    apartment_amenities?: ApartmentAmenityListRelationFilter
  }

  export type AmenityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    description?: SortOrderInput | SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
    apartment_amenities?: ApartmentAmenityOrderByRelationAggregateInput
  }

  export type AmenityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: AmenityWhereInput | AmenityWhereInput[]
    OR?: AmenityWhereInput[]
    NOT?: AmenityWhereInput | AmenityWhereInput[]
    image?: StringFilter<"Amenity"> | string
    description?: StringNullableFilter<"Amenity"> | string | null
    created?: DateTimeFilter<"Amenity"> | Date | string
    updated?: DateTimeFilter<"Amenity"> | Date | string
    is_excluded?: BoolFilter<"Amenity"> | boolean
    apartment_amenities?: ApartmentAmenityListRelationFilter
  }, "id" | "name">

  export type AmenityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    description?: SortOrderInput | SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
    _count?: AmenityCountOrderByAggregateInput
    _max?: AmenityMaxOrderByAggregateInput
    _min?: AmenityMinOrderByAggregateInput
  }

  export type AmenityScalarWhereWithAggregatesInput = {
    AND?: AmenityScalarWhereWithAggregatesInput | AmenityScalarWhereWithAggregatesInput[]
    OR?: AmenityScalarWhereWithAggregatesInput[]
    NOT?: AmenityScalarWhereWithAggregatesInput | AmenityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Amenity"> | string
    name?: StringWithAggregatesFilter<"Amenity"> | string
    image?: StringWithAggregatesFilter<"Amenity"> | string
    description?: StringNullableWithAggregatesFilter<"Amenity"> | string | null
    created?: DateTimeWithAggregatesFilter<"Amenity"> | Date | string
    updated?: DateTimeWithAggregatesFilter<"Amenity"> | Date | string
    is_excluded?: BoolWithAggregatesFilter<"Amenity"> | boolean
  }

  export type ApartmentAmenityWhereInput = {
    AND?: ApartmentAmenityWhereInput | ApartmentAmenityWhereInput[]
    OR?: ApartmentAmenityWhereInput[]
    NOT?: ApartmentAmenityWhereInput | ApartmentAmenityWhereInput[]
    id?: StringFilter<"ApartmentAmenity"> | string
    amenity_id?: StringFilter<"ApartmentAmenity"> | string
    apartment_id?: StringFilter<"ApartmentAmenity"> | string
    created?: DateTimeFilter<"ApartmentAmenity"> | Date | string
    updated?: DateTimeFilter<"ApartmentAmenity"> | Date | string
    is_excluded?: BoolFilter<"ApartmentAmenity"> | boolean
    apartment?: XOR<ApartmentScalarRelationFilter, ApartmentWhereInput>
    amenity?: XOR<AmenityScalarRelationFilter, AmenityWhereInput>
  }

  export type ApartmentAmenityOrderByWithRelationInput = {
    id?: SortOrder
    amenity_id?: SortOrder
    apartment_id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
    apartment?: ApartmentOrderByWithRelationInput
    amenity?: AmenityOrderByWithRelationInput
  }

  export type ApartmentAmenityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    apartment_id_amenity_id?: ApartmentAmenityApartment_idAmenity_idCompoundUniqueInput
    AND?: ApartmentAmenityWhereInput | ApartmentAmenityWhereInput[]
    OR?: ApartmentAmenityWhereInput[]
    NOT?: ApartmentAmenityWhereInput | ApartmentAmenityWhereInput[]
    amenity_id?: StringFilter<"ApartmentAmenity"> | string
    apartment_id?: StringFilter<"ApartmentAmenity"> | string
    created?: DateTimeFilter<"ApartmentAmenity"> | Date | string
    updated?: DateTimeFilter<"ApartmentAmenity"> | Date | string
    is_excluded?: BoolFilter<"ApartmentAmenity"> | boolean
    apartment?: XOR<ApartmentScalarRelationFilter, ApartmentWhereInput>
    amenity?: XOR<AmenityScalarRelationFilter, AmenityWhereInput>
  }, "id" | "apartment_id_amenity_id">

  export type ApartmentAmenityOrderByWithAggregationInput = {
    id?: SortOrder
    amenity_id?: SortOrder
    apartment_id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
    _count?: ApartmentAmenityCountOrderByAggregateInput
    _max?: ApartmentAmenityMaxOrderByAggregateInput
    _min?: ApartmentAmenityMinOrderByAggregateInput
  }

  export type ApartmentAmenityScalarWhereWithAggregatesInput = {
    AND?: ApartmentAmenityScalarWhereWithAggregatesInput | ApartmentAmenityScalarWhereWithAggregatesInput[]
    OR?: ApartmentAmenityScalarWhereWithAggregatesInput[]
    NOT?: ApartmentAmenityScalarWhereWithAggregatesInput | ApartmentAmenityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApartmentAmenity"> | string
    amenity_id?: StringWithAggregatesFilter<"ApartmentAmenity"> | string
    apartment_id?: StringWithAggregatesFilter<"ApartmentAmenity"> | string
    created?: DateTimeWithAggregatesFilter<"ApartmentAmenity"> | Date | string
    updated?: DateTimeWithAggregatesFilter<"ApartmentAmenity"> | Date | string
    is_excluded?: BoolWithAggregatesFilter<"ApartmentAmenity"> | boolean
  }

  export type ApartmentImageWhereInput = {
    AND?: ApartmentImageWhereInput | ApartmentImageWhereInput[]
    OR?: ApartmentImageWhereInput[]
    NOT?: ApartmentImageWhereInput | ApartmentImageWhereInput[]
    id?: StringFilter<"ApartmentImage"> | string
    image?: StringFilter<"ApartmentImage"> | string
    name?: StringNullableFilter<"ApartmentImage"> | string | null
    description?: StringNullableFilter<"ApartmentImage"> | string | null
    apartment_id?: StringFilter<"ApartmentImage"> | string
    created?: DateTimeFilter<"ApartmentImage"> | Date | string
    updated?: DateTimeFilter<"ApartmentImage"> | Date | string
    is_excluded?: BoolFilter<"ApartmentImage"> | boolean
    apartment?: XOR<ApartmentScalarRelationFilter, ApartmentWhereInput>
  }

  export type ApartmentImageOrderByWithRelationInput = {
    id?: SortOrder
    image?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    apartment_id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
    apartment?: ApartmentOrderByWithRelationInput
  }

  export type ApartmentImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ApartmentImageWhereInput | ApartmentImageWhereInput[]
    OR?: ApartmentImageWhereInput[]
    NOT?: ApartmentImageWhereInput | ApartmentImageWhereInput[]
    image?: StringFilter<"ApartmentImage"> | string
    name?: StringNullableFilter<"ApartmentImage"> | string | null
    description?: StringNullableFilter<"ApartmentImage"> | string | null
    apartment_id?: StringFilter<"ApartmentImage"> | string
    created?: DateTimeFilter<"ApartmentImage"> | Date | string
    updated?: DateTimeFilter<"ApartmentImage"> | Date | string
    is_excluded?: BoolFilter<"ApartmentImage"> | boolean
    apartment?: XOR<ApartmentScalarRelationFilter, ApartmentWhereInput>
  }, "id">

  export type ApartmentImageOrderByWithAggregationInput = {
    id?: SortOrder
    image?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    apartment_id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
    _count?: ApartmentImageCountOrderByAggregateInput
    _max?: ApartmentImageMaxOrderByAggregateInput
    _min?: ApartmentImageMinOrderByAggregateInput
  }

  export type ApartmentImageScalarWhereWithAggregatesInput = {
    AND?: ApartmentImageScalarWhereWithAggregatesInput | ApartmentImageScalarWhereWithAggregatesInput[]
    OR?: ApartmentImageScalarWhereWithAggregatesInput[]
    NOT?: ApartmentImageScalarWhereWithAggregatesInput | ApartmentImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApartmentImage"> | string
    image?: StringWithAggregatesFilter<"ApartmentImage"> | string
    name?: StringNullableWithAggregatesFilter<"ApartmentImage"> | string | null
    description?: StringNullableWithAggregatesFilter<"ApartmentImage"> | string | null
    apartment_id?: StringWithAggregatesFilter<"ApartmentImage"> | string
    created?: DateTimeWithAggregatesFilter<"ApartmentImage"> | Date | string
    updated?: DateTimeWithAggregatesFilter<"ApartmentImage"> | Date | string
    is_excluded?: BoolWithAggregatesFilter<"ApartmentImage"> | boolean
  }

  export type BedTypeWhereInput = {
    AND?: BedTypeWhereInput | BedTypeWhereInput[]
    OR?: BedTypeWhereInput[]
    NOT?: BedTypeWhereInput | BedTypeWhereInput[]
    id?: StringFilter<"BedType"> | string
    name?: StringFilter<"BedType"> | string
    image?: StringFilter<"BedType"> | string
    created?: DateTimeFilter<"BedType"> | Date | string
    updated?: DateTimeFilter<"BedType"> | Date | string
    is_excluded?: BoolFilter<"BedType"> | boolean
    apartment_beds?: ApartmentBedListRelationFilter
  }

  export type BedTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
    apartment_beds?: ApartmentBedOrderByRelationAggregateInput
  }

  export type BedTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: BedTypeWhereInput | BedTypeWhereInput[]
    OR?: BedTypeWhereInput[]
    NOT?: BedTypeWhereInput | BedTypeWhereInput[]
    image?: StringFilter<"BedType"> | string
    created?: DateTimeFilter<"BedType"> | Date | string
    updated?: DateTimeFilter<"BedType"> | Date | string
    is_excluded?: BoolFilter<"BedType"> | boolean
    apartment_beds?: ApartmentBedListRelationFilter
  }, "id" | "name">

  export type BedTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
    _count?: BedTypeCountOrderByAggregateInput
    _max?: BedTypeMaxOrderByAggregateInput
    _min?: BedTypeMinOrderByAggregateInput
  }

  export type BedTypeScalarWhereWithAggregatesInput = {
    AND?: BedTypeScalarWhereWithAggregatesInput | BedTypeScalarWhereWithAggregatesInput[]
    OR?: BedTypeScalarWhereWithAggregatesInput[]
    NOT?: BedTypeScalarWhereWithAggregatesInput | BedTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BedType"> | string
    name?: StringWithAggregatesFilter<"BedType"> | string
    image?: StringWithAggregatesFilter<"BedType"> | string
    created?: DateTimeWithAggregatesFilter<"BedType"> | Date | string
    updated?: DateTimeWithAggregatesFilter<"BedType"> | Date | string
    is_excluded?: BoolWithAggregatesFilter<"BedType"> | boolean
  }

  export type ApartmentBedWhereInput = {
    AND?: ApartmentBedWhereInput | ApartmentBedWhereInput[]
    OR?: ApartmentBedWhereInput[]
    NOT?: ApartmentBedWhereInput | ApartmentBedWhereInput[]
    id?: StringFilter<"ApartmentBed"> | string
    apartment_id?: StringFilter<"ApartmentBed"> | string
    bed_type_id?: StringFilter<"ApartmentBed"> | string
    count?: IntFilter<"ApartmentBed"> | number
    created?: DateTimeFilter<"ApartmentBed"> | Date | string
    updated?: DateTimeFilter<"ApartmentBed"> | Date | string
    is_excluded?: BoolFilter<"ApartmentBed"> | boolean
    apartment?: XOR<ApartmentScalarRelationFilter, ApartmentWhereInput>
    bed_type?: XOR<BedTypeScalarRelationFilter, BedTypeWhereInput>
  }

  export type ApartmentBedOrderByWithRelationInput = {
    id?: SortOrder
    apartment_id?: SortOrder
    bed_type_id?: SortOrder
    count?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
    apartment?: ApartmentOrderByWithRelationInput
    bed_type?: BedTypeOrderByWithRelationInput
  }

  export type ApartmentBedWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    apartment_id_bed_type_id?: ApartmentBedApartment_idBed_type_idCompoundUniqueInput
    AND?: ApartmentBedWhereInput | ApartmentBedWhereInput[]
    OR?: ApartmentBedWhereInput[]
    NOT?: ApartmentBedWhereInput | ApartmentBedWhereInput[]
    apartment_id?: StringFilter<"ApartmentBed"> | string
    bed_type_id?: StringFilter<"ApartmentBed"> | string
    count?: IntFilter<"ApartmentBed"> | number
    created?: DateTimeFilter<"ApartmentBed"> | Date | string
    updated?: DateTimeFilter<"ApartmentBed"> | Date | string
    is_excluded?: BoolFilter<"ApartmentBed"> | boolean
    apartment?: XOR<ApartmentScalarRelationFilter, ApartmentWhereInput>
    bed_type?: XOR<BedTypeScalarRelationFilter, BedTypeWhereInput>
  }, "id" | "apartment_id_bed_type_id">

  export type ApartmentBedOrderByWithAggregationInput = {
    id?: SortOrder
    apartment_id?: SortOrder
    bed_type_id?: SortOrder
    count?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
    _count?: ApartmentBedCountOrderByAggregateInput
    _avg?: ApartmentBedAvgOrderByAggregateInput
    _max?: ApartmentBedMaxOrderByAggregateInput
    _min?: ApartmentBedMinOrderByAggregateInput
    _sum?: ApartmentBedSumOrderByAggregateInput
  }

  export type ApartmentBedScalarWhereWithAggregatesInput = {
    AND?: ApartmentBedScalarWhereWithAggregatesInput | ApartmentBedScalarWhereWithAggregatesInput[]
    OR?: ApartmentBedScalarWhereWithAggregatesInput[]
    NOT?: ApartmentBedScalarWhereWithAggregatesInput | ApartmentBedScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApartmentBed"> | string
    apartment_id?: StringWithAggregatesFilter<"ApartmentBed"> | string
    bed_type_id?: StringWithAggregatesFilter<"ApartmentBed"> | string
    count?: IntWithAggregatesFilter<"ApartmentBed"> | number
    created?: DateTimeWithAggregatesFilter<"ApartmentBed"> | Date | string
    updated?: DateTimeWithAggregatesFilter<"ApartmentBed"> | Date | string
    is_excluded?: BoolWithAggregatesFilter<"ApartmentBed"> | boolean
  }

  export type BookingVariantWhereInput = {
    AND?: BookingVariantWhereInput | BookingVariantWhereInput[]
    OR?: BookingVariantWhereInput[]
    NOT?: BookingVariantWhereInput | BookingVariantWhereInput[]
    id?: StringFilter<"BookingVariant"> | string
    apartment_id?: StringFilter<"BookingVariant"> | string
    price?: FloatFilter<"BookingVariant"> | number
    capacity?: IntFilter<"BookingVariant"> | number
    is_available?: BoolFilter<"BookingVariant"> | boolean
    created?: DateTimeFilter<"BookingVariant"> | Date | string
    updated?: DateTimeFilter<"BookingVariant"> | Date | string
    is_excluded?: BoolFilter<"BookingVariant"> | boolean
    apartment?: XOR<ApartmentScalarRelationFilter, ApartmentWhereInput>
    bookings?: BookingListRelationFilter
  }

  export type BookingVariantOrderByWithRelationInput = {
    id?: SortOrder
    apartment_id?: SortOrder
    price?: SortOrder
    capacity?: SortOrder
    is_available?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
    apartment?: ApartmentOrderByWithRelationInput
    bookings?: BookingOrderByRelationAggregateInput
  }

  export type BookingVariantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BookingVariantWhereInput | BookingVariantWhereInput[]
    OR?: BookingVariantWhereInput[]
    NOT?: BookingVariantWhereInput | BookingVariantWhereInput[]
    apartment_id?: StringFilter<"BookingVariant"> | string
    price?: FloatFilter<"BookingVariant"> | number
    capacity?: IntFilter<"BookingVariant"> | number
    is_available?: BoolFilter<"BookingVariant"> | boolean
    created?: DateTimeFilter<"BookingVariant"> | Date | string
    updated?: DateTimeFilter<"BookingVariant"> | Date | string
    is_excluded?: BoolFilter<"BookingVariant"> | boolean
    apartment?: XOR<ApartmentScalarRelationFilter, ApartmentWhereInput>
    bookings?: BookingListRelationFilter
  }, "id">

  export type BookingVariantOrderByWithAggregationInput = {
    id?: SortOrder
    apartment_id?: SortOrder
    price?: SortOrder
    capacity?: SortOrder
    is_available?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
    _count?: BookingVariantCountOrderByAggregateInput
    _avg?: BookingVariantAvgOrderByAggregateInput
    _max?: BookingVariantMaxOrderByAggregateInput
    _min?: BookingVariantMinOrderByAggregateInput
    _sum?: BookingVariantSumOrderByAggregateInput
  }

  export type BookingVariantScalarWhereWithAggregatesInput = {
    AND?: BookingVariantScalarWhereWithAggregatesInput | BookingVariantScalarWhereWithAggregatesInput[]
    OR?: BookingVariantScalarWhereWithAggregatesInput[]
    NOT?: BookingVariantScalarWhereWithAggregatesInput | BookingVariantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BookingVariant"> | string
    apartment_id?: StringWithAggregatesFilter<"BookingVariant"> | string
    price?: FloatWithAggregatesFilter<"BookingVariant"> | number
    capacity?: IntWithAggregatesFilter<"BookingVariant"> | number
    is_available?: BoolWithAggregatesFilter<"BookingVariant"> | boolean
    created?: DateTimeWithAggregatesFilter<"BookingVariant"> | Date | string
    updated?: DateTimeWithAggregatesFilter<"BookingVariant"> | Date | string
    is_excluded?: BoolWithAggregatesFilter<"BookingVariant"> | boolean
  }

  export type ReservationWhereInput = {
    AND?: ReservationWhereInput | ReservationWhereInput[]
    OR?: ReservationWhereInput[]
    NOT?: ReservationWhereInput | ReservationWhereInput[]
    id?: StringFilter<"Reservation"> | string
    user_id?: StringFilter<"Reservation"> | string
    apartment_id?: StringFilter<"Reservation"> | string
    start?: DateTimeFilter<"Reservation"> | Date | string
    end?: DateTimeFilter<"Reservation"> | Date | string
    created?: DateTimeFilter<"Reservation"> | Date | string
    updated?: DateTimeFilter<"Reservation"> | Date | string
    apartment?: XOR<ApartmentScalarRelationFilter, ApartmentWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ReservationOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    apartment_id?: SortOrder
    start?: SortOrder
    end?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    apartment?: ApartmentOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ReservationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReservationWhereInput | ReservationWhereInput[]
    OR?: ReservationWhereInput[]
    NOT?: ReservationWhereInput | ReservationWhereInput[]
    user_id?: StringFilter<"Reservation"> | string
    apartment_id?: StringFilter<"Reservation"> | string
    start?: DateTimeFilter<"Reservation"> | Date | string
    end?: DateTimeFilter<"Reservation"> | Date | string
    created?: DateTimeFilter<"Reservation"> | Date | string
    updated?: DateTimeFilter<"Reservation"> | Date | string
    apartment?: XOR<ApartmentScalarRelationFilter, ApartmentWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ReservationOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    apartment_id?: SortOrder
    start?: SortOrder
    end?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    _count?: ReservationCountOrderByAggregateInput
    _max?: ReservationMaxOrderByAggregateInput
    _min?: ReservationMinOrderByAggregateInput
  }

  export type ReservationScalarWhereWithAggregatesInput = {
    AND?: ReservationScalarWhereWithAggregatesInput | ReservationScalarWhereWithAggregatesInput[]
    OR?: ReservationScalarWhereWithAggregatesInput[]
    NOT?: ReservationScalarWhereWithAggregatesInput | ReservationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Reservation"> | string
    user_id?: StringWithAggregatesFilter<"Reservation"> | string
    apartment_id?: StringWithAggregatesFilter<"Reservation"> | string
    start?: DateTimeWithAggregatesFilter<"Reservation"> | Date | string
    end?: DateTimeWithAggregatesFilter<"Reservation"> | Date | string
    created?: DateTimeWithAggregatesFilter<"Reservation"> | Date | string
    updated?: DateTimeWithAggregatesFilter<"Reservation"> | Date | string
  }

  export type BookingWhereInput = {
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    id?: StringFilter<"Booking"> | string
    user_id?: StringFilter<"Booking"> | string
    booking_variant_id?: StringFilter<"Booking"> | string
    transaction_id?: StringFilter<"Booking"> | string
    message?: StringNullableFilter<"Booking"> | string | null
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    start?: DateTimeFilter<"Booking"> | Date | string
    end?: DateTimeFilter<"Booking"> | Date | string
    created?: DateTimeFilter<"Booking"> | Date | string
    updated?: DateTimeFilter<"Booking"> | Date | string
    booking_variant?: XOR<BookingVariantScalarRelationFilter, BookingVariantWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
    booking_events?: BookingEventListRelationFilter
    booking_additional_options?: BookingAdditionalOptionListRelationFilter
    reviews?: ReviewListRelationFilter
    messages?: MessageListRelationFilter
  }

  export type BookingOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    booking_variant_id?: SortOrder
    transaction_id?: SortOrder
    message?: SortOrderInput | SortOrder
    status?: SortOrder
    start?: SortOrder
    end?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    booking_variant?: BookingVariantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    transaction?: TransactionOrderByWithRelationInput
    booking_events?: BookingEventOrderByRelationAggregateInput
    booking_additional_options?: BookingAdditionalOptionOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
  }

  export type BookingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    transaction_id?: string
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    user_id?: StringFilter<"Booking"> | string
    booking_variant_id?: StringFilter<"Booking"> | string
    message?: StringNullableFilter<"Booking"> | string | null
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    start?: DateTimeFilter<"Booking"> | Date | string
    end?: DateTimeFilter<"Booking"> | Date | string
    created?: DateTimeFilter<"Booking"> | Date | string
    updated?: DateTimeFilter<"Booking"> | Date | string
    booking_variant?: XOR<BookingVariantScalarRelationFilter, BookingVariantWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
    booking_events?: BookingEventListRelationFilter
    booking_additional_options?: BookingAdditionalOptionListRelationFilter
    reviews?: ReviewListRelationFilter
    messages?: MessageListRelationFilter
  }, "id" | "transaction_id">

  export type BookingOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    booking_variant_id?: SortOrder
    transaction_id?: SortOrder
    message?: SortOrderInput | SortOrder
    status?: SortOrder
    start?: SortOrder
    end?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    _count?: BookingCountOrderByAggregateInput
    _max?: BookingMaxOrderByAggregateInput
    _min?: BookingMinOrderByAggregateInput
  }

  export type BookingScalarWhereWithAggregatesInput = {
    AND?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    OR?: BookingScalarWhereWithAggregatesInput[]
    NOT?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Booking"> | string
    user_id?: StringWithAggregatesFilter<"Booking"> | string
    booking_variant_id?: StringWithAggregatesFilter<"Booking"> | string
    transaction_id?: StringWithAggregatesFilter<"Booking"> | string
    message?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    status?: EnumBookingStatusWithAggregatesFilter<"Booking"> | $Enums.BookingStatus
    start?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    end?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    created?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    updated?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
  }

  export type AdditionalOptionWhereInput = {
    AND?: AdditionalOptionWhereInput | AdditionalOptionWhereInput[]
    OR?: AdditionalOptionWhereInput[]
    NOT?: AdditionalOptionWhereInput | AdditionalOptionWhereInput[]
    id?: StringFilter<"AdditionalOption"> | string
    name?: StringFilter<"AdditionalOption"> | string
    description?: StringFilter<"AdditionalOption"> | string
    image?: StringFilter<"AdditionalOption"> | string
    price?: FloatFilter<"AdditionalOption"> | number
    created?: DateTimeFilter<"AdditionalOption"> | Date | string
    updated?: DateTimeFilter<"AdditionalOption"> | Date | string
    is_excluded?: BoolFilter<"AdditionalOption"> | boolean
    booking_additional_options?: BookingAdditionalOptionListRelationFilter
  }

  export type AdditionalOptionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    price?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
    booking_additional_options?: BookingAdditionalOptionOrderByRelationAggregateInput
  }

  export type AdditionalOptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: AdditionalOptionWhereInput | AdditionalOptionWhereInput[]
    OR?: AdditionalOptionWhereInput[]
    NOT?: AdditionalOptionWhereInput | AdditionalOptionWhereInput[]
    description?: StringFilter<"AdditionalOption"> | string
    image?: StringFilter<"AdditionalOption"> | string
    price?: FloatFilter<"AdditionalOption"> | number
    created?: DateTimeFilter<"AdditionalOption"> | Date | string
    updated?: DateTimeFilter<"AdditionalOption"> | Date | string
    is_excluded?: BoolFilter<"AdditionalOption"> | boolean
    booking_additional_options?: BookingAdditionalOptionListRelationFilter
  }, "id" | "name">

  export type AdditionalOptionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    price?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
    _count?: AdditionalOptionCountOrderByAggregateInput
    _avg?: AdditionalOptionAvgOrderByAggregateInput
    _max?: AdditionalOptionMaxOrderByAggregateInput
    _min?: AdditionalOptionMinOrderByAggregateInput
    _sum?: AdditionalOptionSumOrderByAggregateInput
  }

  export type AdditionalOptionScalarWhereWithAggregatesInput = {
    AND?: AdditionalOptionScalarWhereWithAggregatesInput | AdditionalOptionScalarWhereWithAggregatesInput[]
    OR?: AdditionalOptionScalarWhereWithAggregatesInput[]
    NOT?: AdditionalOptionScalarWhereWithAggregatesInput | AdditionalOptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdditionalOption"> | string
    name?: StringWithAggregatesFilter<"AdditionalOption"> | string
    description?: StringWithAggregatesFilter<"AdditionalOption"> | string
    image?: StringWithAggregatesFilter<"AdditionalOption"> | string
    price?: FloatWithAggregatesFilter<"AdditionalOption"> | number
    created?: DateTimeWithAggregatesFilter<"AdditionalOption"> | Date | string
    updated?: DateTimeWithAggregatesFilter<"AdditionalOption"> | Date | string
    is_excluded?: BoolWithAggregatesFilter<"AdditionalOption"> | boolean
  }

  export type BookingAdditionalOptionWhereInput = {
    AND?: BookingAdditionalOptionWhereInput | BookingAdditionalOptionWhereInput[]
    OR?: BookingAdditionalOptionWhereInput[]
    NOT?: BookingAdditionalOptionWhereInput | BookingAdditionalOptionWhereInput[]
    id?: StringFilter<"BookingAdditionalOption"> | string
    amount?: IntFilter<"BookingAdditionalOption"> | number
    option_id?: StringFilter<"BookingAdditionalOption"> | string
    booking_id?: StringFilter<"BookingAdditionalOption"> | string
    created?: DateTimeFilter<"BookingAdditionalOption"> | Date | string
    updated?: DateTimeFilter<"BookingAdditionalOption"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    additional_option?: XOR<AdditionalOptionScalarRelationFilter, AdditionalOptionWhereInput>
  }

  export type BookingAdditionalOptionOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    option_id?: SortOrder
    booking_id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    booking?: BookingOrderByWithRelationInput
    additional_option?: AdditionalOptionOrderByWithRelationInput
  }

  export type BookingAdditionalOptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    booking_id_option_id?: BookingAdditionalOptionBooking_idOption_idCompoundUniqueInput
    AND?: BookingAdditionalOptionWhereInput | BookingAdditionalOptionWhereInput[]
    OR?: BookingAdditionalOptionWhereInput[]
    NOT?: BookingAdditionalOptionWhereInput | BookingAdditionalOptionWhereInput[]
    amount?: IntFilter<"BookingAdditionalOption"> | number
    option_id?: StringFilter<"BookingAdditionalOption"> | string
    booking_id?: StringFilter<"BookingAdditionalOption"> | string
    created?: DateTimeFilter<"BookingAdditionalOption"> | Date | string
    updated?: DateTimeFilter<"BookingAdditionalOption"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    additional_option?: XOR<AdditionalOptionScalarRelationFilter, AdditionalOptionWhereInput>
  }, "id" | "booking_id_option_id">

  export type BookingAdditionalOptionOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    option_id?: SortOrder
    booking_id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    _count?: BookingAdditionalOptionCountOrderByAggregateInput
    _avg?: BookingAdditionalOptionAvgOrderByAggregateInput
    _max?: BookingAdditionalOptionMaxOrderByAggregateInput
    _min?: BookingAdditionalOptionMinOrderByAggregateInput
    _sum?: BookingAdditionalOptionSumOrderByAggregateInput
  }

  export type BookingAdditionalOptionScalarWhereWithAggregatesInput = {
    AND?: BookingAdditionalOptionScalarWhereWithAggregatesInput | BookingAdditionalOptionScalarWhereWithAggregatesInput[]
    OR?: BookingAdditionalOptionScalarWhereWithAggregatesInput[]
    NOT?: BookingAdditionalOptionScalarWhereWithAggregatesInput | BookingAdditionalOptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BookingAdditionalOption"> | string
    amount?: IntWithAggregatesFilter<"BookingAdditionalOption"> | number
    option_id?: StringWithAggregatesFilter<"BookingAdditionalOption"> | string
    booking_id?: StringWithAggregatesFilter<"BookingAdditionalOption"> | string
    created?: DateTimeWithAggregatesFilter<"BookingAdditionalOption"> | Date | string
    updated?: DateTimeWithAggregatesFilter<"BookingAdditionalOption"> | Date | string
  }

  export type BookingEventWhereInput = {
    AND?: BookingEventWhereInput | BookingEventWhereInput[]
    OR?: BookingEventWhereInput[]
    NOT?: BookingEventWhereInput | BookingEventWhereInput[]
    id?: StringFilter<"BookingEvent"> | string
    number_of_people?: IntFilter<"BookingEvent"> | number
    booking_id?: StringFilter<"BookingEvent"> | string
    event_id?: StringFilter<"BookingEvent"> | string
    transaction_id?: StringFilter<"BookingEvent"> | string
    created?: DateTimeFilter<"BookingEvent"> | Date | string
    updated?: DateTimeFilter<"BookingEvent"> | Date | string
    is_excluded?: BoolFilter<"BookingEvent"> | boolean
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
  }

  export type BookingEventOrderByWithRelationInput = {
    id?: SortOrder
    number_of_people?: SortOrder
    booking_id?: SortOrder
    event_id?: SortOrder
    transaction_id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
    booking?: BookingOrderByWithRelationInput
    event?: EventOrderByWithRelationInput
    transaction?: TransactionOrderByWithRelationInput
  }

  export type BookingEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    transaction_id?: string
    AND?: BookingEventWhereInput | BookingEventWhereInput[]
    OR?: BookingEventWhereInput[]
    NOT?: BookingEventWhereInput | BookingEventWhereInput[]
    number_of_people?: IntFilter<"BookingEvent"> | number
    booking_id?: StringFilter<"BookingEvent"> | string
    event_id?: StringFilter<"BookingEvent"> | string
    created?: DateTimeFilter<"BookingEvent"> | Date | string
    updated?: DateTimeFilter<"BookingEvent"> | Date | string
    is_excluded?: BoolFilter<"BookingEvent"> | boolean
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
  }, "id" | "transaction_id">

  export type BookingEventOrderByWithAggregationInput = {
    id?: SortOrder
    number_of_people?: SortOrder
    booking_id?: SortOrder
    event_id?: SortOrder
    transaction_id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
    _count?: BookingEventCountOrderByAggregateInput
    _avg?: BookingEventAvgOrderByAggregateInput
    _max?: BookingEventMaxOrderByAggregateInput
    _min?: BookingEventMinOrderByAggregateInput
    _sum?: BookingEventSumOrderByAggregateInput
  }

  export type BookingEventScalarWhereWithAggregatesInput = {
    AND?: BookingEventScalarWhereWithAggregatesInput | BookingEventScalarWhereWithAggregatesInput[]
    OR?: BookingEventScalarWhereWithAggregatesInput[]
    NOT?: BookingEventScalarWhereWithAggregatesInput | BookingEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BookingEvent"> | string
    number_of_people?: IntWithAggregatesFilter<"BookingEvent"> | number
    booking_id?: StringWithAggregatesFilter<"BookingEvent"> | string
    event_id?: StringWithAggregatesFilter<"BookingEvent"> | string
    transaction_id?: StringWithAggregatesFilter<"BookingEvent"> | string
    created?: DateTimeWithAggregatesFilter<"BookingEvent"> | Date | string
    updated?: DateTimeWithAggregatesFilter<"BookingEvent"> | Date | string
    is_excluded?: BoolWithAggregatesFilter<"BookingEvent"> | boolean
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    amount?: FloatFilter<"Transaction"> | number
    user_id?: StringFilter<"Transaction"> | string
    description?: StringFilter<"Transaction"> | string
    card_details_id?: StringNullableFilter<"Transaction"> | string | null
    transfer_details_id?: StringNullableFilter<"Transaction"> | string | null
    transaction_type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    transaction_status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    payment_method?: EnumPaymentMethodFilter<"Transaction"> | $Enums.PaymentMethod
    created?: DateTimeFilter<"Transaction"> | Date | string
    updated?: DateTimeFilter<"Transaction"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    card_detail?: XOR<CardDetailNullableScalarRelationFilter, CardDetailWhereInput> | null
    transfer_detail?: XOR<TransferDetailNullableScalarRelationFilter, TransferDetailWhereInput> | null
    booking?: XOR<BookingNullableScalarRelationFilter, BookingWhereInput> | null
    booking_event?: XOR<BookingEventNullableScalarRelationFilter, BookingEventWhereInput> | null
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    user_id?: SortOrder
    description?: SortOrder
    card_details_id?: SortOrderInput | SortOrder
    transfer_details_id?: SortOrderInput | SortOrder
    transaction_type?: SortOrder
    transaction_status?: SortOrder
    payment_method?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    user?: UserOrderByWithRelationInput
    card_detail?: CardDetailOrderByWithRelationInput
    transfer_detail?: TransferDetailOrderByWithRelationInput
    booking?: BookingOrderByWithRelationInput
    booking_event?: BookingEventOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    amount?: FloatFilter<"Transaction"> | number
    user_id?: StringFilter<"Transaction"> | string
    description?: StringFilter<"Transaction"> | string
    card_details_id?: StringNullableFilter<"Transaction"> | string | null
    transfer_details_id?: StringNullableFilter<"Transaction"> | string | null
    transaction_type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    transaction_status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    payment_method?: EnumPaymentMethodFilter<"Transaction"> | $Enums.PaymentMethod
    created?: DateTimeFilter<"Transaction"> | Date | string
    updated?: DateTimeFilter<"Transaction"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    card_detail?: XOR<CardDetailNullableScalarRelationFilter, CardDetailWhereInput> | null
    transfer_detail?: XOR<TransferDetailNullableScalarRelationFilter, TransferDetailWhereInput> | null
    booking?: XOR<BookingNullableScalarRelationFilter, BookingWhereInput> | null
    booking_event?: XOR<BookingEventNullableScalarRelationFilter, BookingEventWhereInput> | null
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    user_id?: SortOrder
    description?: SortOrder
    card_details_id?: SortOrderInput | SortOrder
    transfer_details_id?: SortOrderInput | SortOrder
    transaction_type?: SortOrder
    transaction_status?: SortOrder
    payment_method?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    amount?: FloatWithAggregatesFilter<"Transaction"> | number
    user_id?: StringWithAggregatesFilter<"Transaction"> | string
    description?: StringWithAggregatesFilter<"Transaction"> | string
    card_details_id?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    transfer_details_id?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    transaction_type?: EnumTransactionTypeWithAggregatesFilter<"Transaction"> | $Enums.TransactionType
    transaction_status?: EnumTransactionStatusWithAggregatesFilter<"Transaction"> | $Enums.TransactionStatus
    payment_method?: EnumPaymentMethodWithAggregatesFilter<"Transaction"> | $Enums.PaymentMethod
    created?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    updated?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
  }

  export type TransferDetailWhereInput = {
    AND?: TransferDetailWhereInput | TransferDetailWhereInput[]
    OR?: TransferDetailWhereInput[]
    NOT?: TransferDetailWhereInput | TransferDetailWhereInput[]
    id?: StringFilter<"TransferDetail"> | string
    bank_name?: StringFilter<"TransferDetail"> | string
    account_number?: StringFilter<"TransferDetail"> | string
    swift?: StringFilter<"TransferDetail"> | string
    payer_name?: StringFilter<"TransferDetail"> | string
    user_id?: StringFilter<"TransferDetail"> | string
    created?: DateTimeFilter<"TransferDetail"> | Date | string
    updated?: DateTimeFilter<"TransferDetail"> | Date | string
    transactions?: TransactionListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TransferDetailOrderByWithRelationInput = {
    id?: SortOrder
    bank_name?: SortOrder
    account_number?: SortOrder
    swift?: SortOrder
    payer_name?: SortOrder
    user_id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    transactions?: TransactionOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
  }

  export type TransferDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransferDetailWhereInput | TransferDetailWhereInput[]
    OR?: TransferDetailWhereInput[]
    NOT?: TransferDetailWhereInput | TransferDetailWhereInput[]
    bank_name?: StringFilter<"TransferDetail"> | string
    account_number?: StringFilter<"TransferDetail"> | string
    swift?: StringFilter<"TransferDetail"> | string
    payer_name?: StringFilter<"TransferDetail"> | string
    user_id?: StringFilter<"TransferDetail"> | string
    created?: DateTimeFilter<"TransferDetail"> | Date | string
    updated?: DateTimeFilter<"TransferDetail"> | Date | string
    transactions?: TransactionListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TransferDetailOrderByWithAggregationInput = {
    id?: SortOrder
    bank_name?: SortOrder
    account_number?: SortOrder
    swift?: SortOrder
    payer_name?: SortOrder
    user_id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    _count?: TransferDetailCountOrderByAggregateInput
    _max?: TransferDetailMaxOrderByAggregateInput
    _min?: TransferDetailMinOrderByAggregateInput
  }

  export type TransferDetailScalarWhereWithAggregatesInput = {
    AND?: TransferDetailScalarWhereWithAggregatesInput | TransferDetailScalarWhereWithAggregatesInput[]
    OR?: TransferDetailScalarWhereWithAggregatesInput[]
    NOT?: TransferDetailScalarWhereWithAggregatesInput | TransferDetailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TransferDetail"> | string
    bank_name?: StringWithAggregatesFilter<"TransferDetail"> | string
    account_number?: StringWithAggregatesFilter<"TransferDetail"> | string
    swift?: StringWithAggregatesFilter<"TransferDetail"> | string
    payer_name?: StringWithAggregatesFilter<"TransferDetail"> | string
    user_id?: StringWithAggregatesFilter<"TransferDetail"> | string
    created?: DateTimeWithAggregatesFilter<"TransferDetail"> | Date | string
    updated?: DateTimeWithAggregatesFilter<"TransferDetail"> | Date | string
  }

  export type CardDetailWhereInput = {
    AND?: CardDetailWhereInput | CardDetailWhereInput[]
    OR?: CardDetailWhereInput[]
    NOT?: CardDetailWhereInput | CardDetailWhereInput[]
    id?: StringFilter<"CardDetail"> | string
    user_id?: StringFilter<"CardDetail"> | string
    number?: StringFilter<"CardDetail"> | string
    expiry_month?: IntFilter<"CardDetail"> | number
    expiry_year?: IntFilter<"CardDetail"> | number
    holder?: StringFilter<"CardDetail"> | string
    token?: StringFilter<"CardDetail"> | string
    created?: DateTimeFilter<"CardDetail"> | Date | string
    updated?: DateTimeFilter<"CardDetail"> | Date | string
    is_excluded?: BoolFilter<"CardDetail"> | boolean
    transactions?: TransactionListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CardDetailOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    number?: SortOrder
    expiry_month?: SortOrder
    expiry_year?: SortOrder
    holder?: SortOrder
    token?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
    transactions?: TransactionOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
  }

  export type CardDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    number?: string
    AND?: CardDetailWhereInput | CardDetailWhereInput[]
    OR?: CardDetailWhereInput[]
    NOT?: CardDetailWhereInput | CardDetailWhereInput[]
    user_id?: StringFilter<"CardDetail"> | string
    expiry_month?: IntFilter<"CardDetail"> | number
    expiry_year?: IntFilter<"CardDetail"> | number
    holder?: StringFilter<"CardDetail"> | string
    token?: StringFilter<"CardDetail"> | string
    created?: DateTimeFilter<"CardDetail"> | Date | string
    updated?: DateTimeFilter<"CardDetail"> | Date | string
    is_excluded?: BoolFilter<"CardDetail"> | boolean
    transactions?: TransactionListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "number">

  export type CardDetailOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    number?: SortOrder
    expiry_month?: SortOrder
    expiry_year?: SortOrder
    holder?: SortOrder
    token?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
    _count?: CardDetailCountOrderByAggregateInput
    _avg?: CardDetailAvgOrderByAggregateInput
    _max?: CardDetailMaxOrderByAggregateInput
    _min?: CardDetailMinOrderByAggregateInput
    _sum?: CardDetailSumOrderByAggregateInput
  }

  export type CardDetailScalarWhereWithAggregatesInput = {
    AND?: CardDetailScalarWhereWithAggregatesInput | CardDetailScalarWhereWithAggregatesInput[]
    OR?: CardDetailScalarWhereWithAggregatesInput[]
    NOT?: CardDetailScalarWhereWithAggregatesInput | CardDetailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CardDetail"> | string
    user_id?: StringWithAggregatesFilter<"CardDetail"> | string
    number?: StringWithAggregatesFilter<"CardDetail"> | string
    expiry_month?: IntWithAggregatesFilter<"CardDetail"> | number
    expiry_year?: IntWithAggregatesFilter<"CardDetail"> | number
    holder?: StringWithAggregatesFilter<"CardDetail"> | string
    token?: StringWithAggregatesFilter<"CardDetail"> | string
    created?: DateTimeWithAggregatesFilter<"CardDetail"> | Date | string
    updated?: DateTimeWithAggregatesFilter<"CardDetail"> | Date | string
    is_excluded?: BoolWithAggregatesFilter<"CardDetail"> | boolean
  }

  export type EventWhereInput = {
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    id?: StringFilter<"Event"> | string
    name?: StringFilter<"Event"> | string
    image?: StringFilter<"Event"> | string
    description?: StringFilter<"Event"> | string
    guide_id?: StringNullableFilter<"Event"> | string | null
    price?: FloatFilter<"Event"> | number
    capacity?: IntFilter<"Event"> | number
    start?: DateTimeFilter<"Event"> | Date | string
    end?: DateTimeFilter<"Event"> | Date | string
    created?: DateTimeFilter<"Event"> | Date | string
    updated?: DateTimeFilter<"Event"> | Date | string
    is_excluded?: BoolFilter<"Event"> | boolean
    guide?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    images?: EventImageListRelationFilter
    booking_events?: BookingEventListRelationFilter
  }

  export type EventOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    description?: SortOrder
    guide_id?: SortOrderInput | SortOrder
    price?: SortOrder
    capacity?: SortOrder
    start?: SortOrder
    end?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
    guide?: UserOrderByWithRelationInput
    images?: EventImageOrderByRelationAggregateInput
    booking_events?: BookingEventOrderByRelationAggregateInput
  }

  export type EventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    name?: StringFilter<"Event"> | string
    image?: StringFilter<"Event"> | string
    description?: StringFilter<"Event"> | string
    guide_id?: StringNullableFilter<"Event"> | string | null
    price?: FloatFilter<"Event"> | number
    capacity?: IntFilter<"Event"> | number
    start?: DateTimeFilter<"Event"> | Date | string
    end?: DateTimeFilter<"Event"> | Date | string
    created?: DateTimeFilter<"Event"> | Date | string
    updated?: DateTimeFilter<"Event"> | Date | string
    is_excluded?: BoolFilter<"Event"> | boolean
    guide?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    images?: EventImageListRelationFilter
    booking_events?: BookingEventListRelationFilter
  }, "id">

  export type EventOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    description?: SortOrder
    guide_id?: SortOrderInput | SortOrder
    price?: SortOrder
    capacity?: SortOrder
    start?: SortOrder
    end?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
    _count?: EventCountOrderByAggregateInput
    _avg?: EventAvgOrderByAggregateInput
    _max?: EventMaxOrderByAggregateInput
    _min?: EventMinOrderByAggregateInput
    _sum?: EventSumOrderByAggregateInput
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    OR?: EventScalarWhereWithAggregatesInput[]
    NOT?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Event"> | string
    name?: StringWithAggregatesFilter<"Event"> | string
    image?: StringWithAggregatesFilter<"Event"> | string
    description?: StringWithAggregatesFilter<"Event"> | string
    guide_id?: StringNullableWithAggregatesFilter<"Event"> | string | null
    price?: FloatWithAggregatesFilter<"Event"> | number
    capacity?: IntWithAggregatesFilter<"Event"> | number
    start?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    end?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    created?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    updated?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    is_excluded?: BoolWithAggregatesFilter<"Event"> | boolean
  }

  export type EventImageWhereInput = {
    AND?: EventImageWhereInput | EventImageWhereInput[]
    OR?: EventImageWhereInput[]
    NOT?: EventImageWhereInput | EventImageWhereInput[]
    id?: StringFilter<"EventImage"> | string
    name?: StringFilter<"EventImage"> | string
    image?: StringNullableFilter<"EventImage"> | string | null
    description?: StringNullableFilter<"EventImage"> | string | null
    event_id?: StringFilter<"EventImage"> | string
    created?: DateTimeFilter<"EventImage"> | Date | string
    updated?: DateTimeFilter<"EventImage"> | Date | string
    is_excluded?: BoolFilter<"EventImage"> | boolean
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
  }

  export type EventImageOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    event_id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
    event?: EventOrderByWithRelationInput
  }

  export type EventImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventImageWhereInput | EventImageWhereInput[]
    OR?: EventImageWhereInput[]
    NOT?: EventImageWhereInput | EventImageWhereInput[]
    name?: StringFilter<"EventImage"> | string
    image?: StringNullableFilter<"EventImage"> | string | null
    description?: StringNullableFilter<"EventImage"> | string | null
    event_id?: StringFilter<"EventImage"> | string
    created?: DateTimeFilter<"EventImage"> | Date | string
    updated?: DateTimeFilter<"EventImage"> | Date | string
    is_excluded?: BoolFilter<"EventImage"> | boolean
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
  }, "id">

  export type EventImageOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    event_id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
    _count?: EventImageCountOrderByAggregateInput
    _max?: EventImageMaxOrderByAggregateInput
    _min?: EventImageMinOrderByAggregateInput
  }

  export type EventImageScalarWhereWithAggregatesInput = {
    AND?: EventImageScalarWhereWithAggregatesInput | EventImageScalarWhereWithAggregatesInput[]
    OR?: EventImageScalarWhereWithAggregatesInput[]
    NOT?: EventImageScalarWhereWithAggregatesInput | EventImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EventImage"> | string
    name?: StringWithAggregatesFilter<"EventImage"> | string
    image?: StringNullableWithAggregatesFilter<"EventImage"> | string | null
    description?: StringNullableWithAggregatesFilter<"EventImage"> | string | null
    event_id?: StringWithAggregatesFilter<"EventImage"> | string
    created?: DateTimeWithAggregatesFilter<"EventImage"> | Date | string
    updated?: DateTimeWithAggregatesFilter<"EventImage"> | Date | string
    is_excluded?: BoolWithAggregatesFilter<"EventImage"> | boolean
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password_hash: string
    image?: string | null
    first_name: string
    last_name: string
    phone_number?: string | null
    date_of_birth?: Date | string | null
    is_active?: boolean
    email_verified?: boolean
    phone_verified?: boolean
    role?: $Enums.Role
    created?: Date | string
    updated?: Date | string
    reservations?: ReservationCreateNestedManyWithoutUserInput
    events?: EventCreateNestedManyWithoutGuideInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    card_details?: CardDetailCreateNestedManyWithoutUserInput
    transfer_details?: TransferDetailCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    sent_messages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password_hash: string
    image?: string | null
    first_name: string
    last_name: string
    phone_number?: string | null
    date_of_birth?: Date | string | null
    is_active?: boolean
    email_verified?: boolean
    phone_verified?: boolean
    role?: $Enums.Role
    created?: Date | string
    updated?: Date | string
    reservations?: ReservationUncheckedCreateNestedManyWithoutUserInput
    events?: EventUncheckedCreateNestedManyWithoutGuideInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    card_details?: CardDetailUncheckedCreateNestedManyWithoutUserInput
    transfer_details?: TransferDetailUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    sent_messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    phone_verified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUpdateManyWithoutUserNestedInput
    events?: EventUpdateManyWithoutGuideNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    card_details?: CardDetailUpdateManyWithoutUserNestedInput
    transfer_details?: TransferDetailUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    sent_messages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    phone_verified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUncheckedUpdateManyWithoutUserNestedInput
    events?: EventUncheckedUpdateManyWithoutGuideNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    card_details?: CardDetailUncheckedUpdateManyWithoutUserNestedInput
    transfer_details?: TransferDetailUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    sent_messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password_hash: string
    image?: string | null
    first_name: string
    last_name: string
    phone_number?: string | null
    date_of_birth?: Date | string | null
    is_active?: boolean
    email_verified?: boolean
    phone_verified?: boolean
    role?: $Enums.Role
    created?: Date | string
    updated?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    phone_verified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    phone_verified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: $Enums.NotificationType
    action?: $Enums.NotificationAction
    message?: string | null
    is_read?: boolean
    created?: Date | string
    updated?: Date | string
    user?: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    type: $Enums.NotificationType
    action?: $Enums.NotificationAction
    message?: string | null
    user_id?: string | null
    is_read?: boolean
    created?: Date | string
    updated?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    action?: EnumNotificationActionFieldUpdateOperationsInput | $Enums.NotificationAction
    message?: NullableStringFieldUpdateOperationsInput | string | null
    is_read?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    action?: EnumNotificationActionFieldUpdateOperationsInput | $Enums.NotificationAction
    message?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_read?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    type: $Enums.NotificationType
    action?: $Enums.NotificationAction
    message?: string | null
    user_id?: string | null
    is_read?: boolean
    created?: Date | string
    updated?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    action?: EnumNotificationActionFieldUpdateOperationsInput | $Enums.NotificationAction
    message?: NullableStringFieldUpdateOperationsInput | string | null
    is_read?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    action?: EnumNotificationActionFieldUpdateOperationsInput | $Enums.NotificationAction
    message?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_read?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    receiver_id: string
    message: string
    is_read?: boolean
    edited?: Date | string | null
    is_excluded?: boolean
    created?: Date | string
    updated?: Date | string
    sender: UserCreateNestedOneWithoutSent_messagesInput
    booking?: BookingCreateNestedOneWithoutMessagesInput
    replaces?: MessageCreateNestedOneWithoutReplaced_byInput
    replaced_by?: MessageCreateNestedManyWithoutReplacesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    sender_id: string
    receiver_id: string
    message: string
    is_read?: boolean
    booking_id?: string | null
    edited?: Date | string | null
    replace_to?: string | null
    is_excluded?: boolean
    created?: Date | string
    updated?: Date | string
    replaced_by?: MessageUncheckedCreateNestedManyWithoutReplacesInput
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiver_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    edited?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSent_messagesNestedInput
    booking?: BookingUpdateOneWithoutMessagesNestedInput
    replaces?: MessageUpdateOneWithoutReplaced_byNestedInput
    replaced_by?: MessageUpdateManyWithoutReplacesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sender_id?: StringFieldUpdateOperationsInput | string
    receiver_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    booking_id?: NullableStringFieldUpdateOperationsInput | string | null
    edited?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replace_to?: NullableStringFieldUpdateOperationsInput | string | null
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    replaced_by?: MessageUncheckedUpdateManyWithoutReplacesNestedInput
  }

  export type MessageCreateManyInput = {
    id?: string
    sender_id: string
    receiver_id: string
    message: string
    is_read?: boolean
    booking_id?: string | null
    edited?: Date | string | null
    replace_to?: string | null
    is_excluded?: boolean
    created?: Date | string
    updated?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiver_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    edited?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sender_id?: StringFieldUpdateOperationsInput | string
    receiver_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    booking_id?: NullableStringFieldUpdateOperationsInput | string | null
    edited?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replace_to?: NullableStringFieldUpdateOperationsInput | string | null
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApartmentCreateInput = {
    id?: string
    image?: string | null
    name?: string | null
    description?: string | null
    rules?: string | null
    number: number
    floor: number
    rooms_count: number
    max_capacity?: number | null
    is_available?: boolean
    is_smoking?: boolean
    is_pet_friendly?: boolean
    deposit?: number
    type: $Enums.ApartmentType
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    images?: ApartmentImageCreateNestedManyWithoutApartmentInput
    apartment_beds?: ApartmentBedCreateNestedManyWithoutApartmentInput
    apartment_amenities?: ApartmentAmenityCreateNestedManyWithoutApartmentInput
    reservations?: ReservationCreateNestedManyWithoutApartmentInput
    booking_variants?: BookingVariantCreateNestedManyWithoutApartmentInput
    reviews?: ReviewCreateNestedManyWithoutApartmentInput
  }

  export type ApartmentUncheckedCreateInput = {
    id?: string
    image?: string | null
    name?: string | null
    description?: string | null
    rules?: string | null
    number: number
    floor: number
    rooms_count: number
    max_capacity?: number | null
    is_available?: boolean
    is_smoking?: boolean
    is_pet_friendly?: boolean
    deposit?: number
    type: $Enums.ApartmentType
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    images?: ApartmentImageUncheckedCreateNestedManyWithoutApartmentInput
    apartment_beds?: ApartmentBedUncheckedCreateNestedManyWithoutApartmentInput
    apartment_amenities?: ApartmentAmenityUncheckedCreateNestedManyWithoutApartmentInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutApartmentInput
    booking_variants?: BookingVariantUncheckedCreateNestedManyWithoutApartmentInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutApartmentInput
  }

  export type ApartmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    number?: IntFieldUpdateOperationsInput | number
    floor?: IntFieldUpdateOperationsInput | number
    rooms_count?: IntFieldUpdateOperationsInput | number
    max_capacity?: NullableIntFieldUpdateOperationsInput | number | null
    is_available?: BoolFieldUpdateOperationsInput | boolean
    is_smoking?: BoolFieldUpdateOperationsInput | boolean
    is_pet_friendly?: BoolFieldUpdateOperationsInput | boolean
    deposit?: FloatFieldUpdateOperationsInput | number
    type?: EnumApartmentTypeFieldUpdateOperationsInput | $Enums.ApartmentType
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    images?: ApartmentImageUpdateManyWithoutApartmentNestedInput
    apartment_beds?: ApartmentBedUpdateManyWithoutApartmentNestedInput
    apartment_amenities?: ApartmentAmenityUpdateManyWithoutApartmentNestedInput
    reservations?: ReservationUpdateManyWithoutApartmentNestedInput
    booking_variants?: BookingVariantUpdateManyWithoutApartmentNestedInput
    reviews?: ReviewUpdateManyWithoutApartmentNestedInput
  }

  export type ApartmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    number?: IntFieldUpdateOperationsInput | number
    floor?: IntFieldUpdateOperationsInput | number
    rooms_count?: IntFieldUpdateOperationsInput | number
    max_capacity?: NullableIntFieldUpdateOperationsInput | number | null
    is_available?: BoolFieldUpdateOperationsInput | boolean
    is_smoking?: BoolFieldUpdateOperationsInput | boolean
    is_pet_friendly?: BoolFieldUpdateOperationsInput | boolean
    deposit?: FloatFieldUpdateOperationsInput | number
    type?: EnumApartmentTypeFieldUpdateOperationsInput | $Enums.ApartmentType
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    images?: ApartmentImageUncheckedUpdateManyWithoutApartmentNestedInput
    apartment_beds?: ApartmentBedUncheckedUpdateManyWithoutApartmentNestedInput
    apartment_amenities?: ApartmentAmenityUncheckedUpdateManyWithoutApartmentNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutApartmentNestedInput
    booking_variants?: BookingVariantUncheckedUpdateManyWithoutApartmentNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutApartmentNestedInput
  }

  export type ApartmentCreateManyInput = {
    id?: string
    image?: string | null
    name?: string | null
    description?: string | null
    rules?: string | null
    number: number
    floor: number
    rooms_count: number
    max_capacity?: number | null
    is_available?: boolean
    is_smoking?: boolean
    is_pet_friendly?: boolean
    deposit?: number
    type: $Enums.ApartmentType
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type ApartmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    number?: IntFieldUpdateOperationsInput | number
    floor?: IntFieldUpdateOperationsInput | number
    rooms_count?: IntFieldUpdateOperationsInput | number
    max_capacity?: NullableIntFieldUpdateOperationsInput | number | null
    is_available?: BoolFieldUpdateOperationsInput | boolean
    is_smoking?: BoolFieldUpdateOperationsInput | boolean
    is_pet_friendly?: BoolFieldUpdateOperationsInput | boolean
    deposit?: FloatFieldUpdateOperationsInput | number
    type?: EnumApartmentTypeFieldUpdateOperationsInput | $Enums.ApartmentType
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ApartmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    number?: IntFieldUpdateOperationsInput | number
    floor?: IntFieldUpdateOperationsInput | number
    rooms_count?: IntFieldUpdateOperationsInput | number
    max_capacity?: NullableIntFieldUpdateOperationsInput | number | null
    is_available?: BoolFieldUpdateOperationsInput | boolean
    is_smoking?: BoolFieldUpdateOperationsInput | boolean
    is_pet_friendly?: BoolFieldUpdateOperationsInput | boolean
    deposit?: FloatFieldUpdateOperationsInput | number
    type?: EnumApartmentTypeFieldUpdateOperationsInput | $Enums.ApartmentType
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReviewCreateInput = {
    id?: string
    rating: number
    comment?: string | null
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    user: UserCreateNestedOneWithoutReviewsInput
    apartment?: ApartmentCreateNestedOneWithoutReviewsInput
    booking?: BookingCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: string
    user_id: string
    apartment_id?: string | null
    booking_id?: string | null
    rating: number
    comment?: string | null
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type ReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
    apartment?: ApartmentUpdateOneWithoutReviewsNestedInput
    booking?: BookingUpdateOneWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    apartment_id?: NullableStringFieldUpdateOperationsInput | string | null
    booking_id?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReviewCreateManyInput = {
    id?: string
    user_id: string
    apartment_id?: string | null
    booking_id?: string | null
    rating: number
    comment?: string | null
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type ReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    apartment_id?: NullableStringFieldUpdateOperationsInput | string | null
    booking_id?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AmenityCreateInput = {
    id?: string
    name: string
    image: string
    description?: string | null
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    apartment_amenities?: ApartmentAmenityCreateNestedManyWithoutAmenityInput
  }

  export type AmenityUncheckedCreateInput = {
    id?: string
    name: string
    image: string
    description?: string | null
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    apartment_amenities?: ApartmentAmenityUncheckedCreateNestedManyWithoutAmenityInput
  }

  export type AmenityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    apartment_amenities?: ApartmentAmenityUpdateManyWithoutAmenityNestedInput
  }

  export type AmenityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    apartment_amenities?: ApartmentAmenityUncheckedUpdateManyWithoutAmenityNestedInput
  }

  export type AmenityCreateManyInput = {
    id?: string
    name: string
    image: string
    description?: string | null
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type AmenityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AmenityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ApartmentAmenityCreateInput = {
    id?: string
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    apartment: ApartmentCreateNestedOneWithoutApartment_amenitiesInput
    amenity: AmenityCreateNestedOneWithoutApartment_amenitiesInput
  }

  export type ApartmentAmenityUncheckedCreateInput = {
    id?: string
    amenity_id: string
    apartment_id: string
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type ApartmentAmenityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    apartment?: ApartmentUpdateOneRequiredWithoutApartment_amenitiesNestedInput
    amenity?: AmenityUpdateOneRequiredWithoutApartment_amenitiesNestedInput
  }

  export type ApartmentAmenityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amenity_id?: StringFieldUpdateOperationsInput | string
    apartment_id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ApartmentAmenityCreateManyInput = {
    id?: string
    amenity_id: string
    apartment_id: string
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type ApartmentAmenityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ApartmentAmenityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amenity_id?: StringFieldUpdateOperationsInput | string
    apartment_id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ApartmentImageCreateInput = {
    id?: string
    image: string
    name?: string | null
    description?: string | null
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    apartment: ApartmentCreateNestedOneWithoutImagesInput
  }

  export type ApartmentImageUncheckedCreateInput = {
    id?: string
    image: string
    name?: string | null
    description?: string | null
    apartment_id: string
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type ApartmentImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    apartment?: ApartmentUpdateOneRequiredWithoutImagesNestedInput
  }

  export type ApartmentImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    apartment_id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ApartmentImageCreateManyInput = {
    id?: string
    image: string
    name?: string | null
    description?: string | null
    apartment_id: string
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type ApartmentImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ApartmentImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    apartment_id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BedTypeCreateInput = {
    id?: string
    name: string
    image: string
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    apartment_beds?: ApartmentBedCreateNestedManyWithoutBed_typeInput
  }

  export type BedTypeUncheckedCreateInput = {
    id?: string
    name: string
    image: string
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    apartment_beds?: ApartmentBedUncheckedCreateNestedManyWithoutBed_typeInput
  }

  export type BedTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    apartment_beds?: ApartmentBedUpdateManyWithoutBed_typeNestedInput
  }

  export type BedTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    apartment_beds?: ApartmentBedUncheckedUpdateManyWithoutBed_typeNestedInput
  }

  export type BedTypeCreateManyInput = {
    id?: string
    name: string
    image: string
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type BedTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BedTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ApartmentBedCreateInput = {
    id?: string
    count: number
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    apartment: ApartmentCreateNestedOneWithoutApartment_bedsInput
    bed_type: BedTypeCreateNestedOneWithoutApartment_bedsInput
  }

  export type ApartmentBedUncheckedCreateInput = {
    id?: string
    apartment_id: string
    bed_type_id: string
    count: number
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type ApartmentBedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    apartment?: ApartmentUpdateOneRequiredWithoutApartment_bedsNestedInput
    bed_type?: BedTypeUpdateOneRequiredWithoutApartment_bedsNestedInput
  }

  export type ApartmentBedUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    apartment_id?: StringFieldUpdateOperationsInput | string
    bed_type_id?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ApartmentBedCreateManyInput = {
    id?: string
    apartment_id: string
    bed_type_id: string
    count: number
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type ApartmentBedUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ApartmentBedUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    apartment_id?: StringFieldUpdateOperationsInput | string
    bed_type_id?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BookingVariantCreateInput = {
    id?: string
    price: number
    capacity: number
    is_available?: boolean
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    apartment: ApartmentCreateNestedOneWithoutBooking_variantsInput
    bookings?: BookingCreateNestedManyWithoutBooking_variantInput
  }

  export type BookingVariantUncheckedCreateInput = {
    id?: string
    apartment_id: string
    price: number
    capacity: number
    is_available?: boolean
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    bookings?: BookingUncheckedCreateNestedManyWithoutBooking_variantInput
  }

  export type BookingVariantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    is_available?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    apartment?: ApartmentUpdateOneRequiredWithoutBooking_variantsNestedInput
    bookings?: BookingUpdateManyWithoutBooking_variantNestedInput
  }

  export type BookingVariantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    apartment_id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    is_available?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    bookings?: BookingUncheckedUpdateManyWithoutBooking_variantNestedInput
  }

  export type BookingVariantCreateManyInput = {
    id?: string
    apartment_id: string
    price: number
    capacity: number
    is_available?: boolean
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type BookingVariantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    is_available?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BookingVariantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    apartment_id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    is_available?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReservationCreateInput = {
    id?: string
    start: Date | string
    end: Date | string
    created?: Date | string
    updated?: Date | string
    apartment: ApartmentCreateNestedOneWithoutReservationsInput
    user: UserCreateNestedOneWithoutReservationsInput
  }

  export type ReservationUncheckedCreateInput = {
    id?: string
    user_id: string
    apartment_id: string
    start: Date | string
    end: Date | string
    created?: Date | string
    updated?: Date | string
  }

  export type ReservationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment?: ApartmentUpdateOneRequiredWithoutReservationsNestedInput
    user?: UserUpdateOneRequiredWithoutReservationsNestedInput
  }

  export type ReservationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    apartment_id?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationCreateManyInput = {
    id?: string
    user_id: string
    apartment_id: string
    start: Date | string
    end: Date | string
    created?: Date | string
    updated?: Date | string
  }

  export type ReservationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    apartment_id?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateInput = {
    id?: string
    message?: string | null
    status?: $Enums.BookingStatus
    start: Date | string
    end: Date | string
    created?: Date | string
    updated?: Date | string
    booking_variant: BookingVariantCreateNestedOneWithoutBookingsInput
    user: UserCreateNestedOneWithoutBookingsInput
    transaction: TransactionCreateNestedOneWithoutBookingInput
    booking_events?: BookingEventCreateNestedManyWithoutBookingInput
    booking_additional_options?: BookingAdditionalOptionCreateNestedManyWithoutBookingInput
    reviews?: ReviewCreateNestedManyWithoutBookingInput
    messages?: MessageCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateInput = {
    id?: string
    user_id: string
    booking_variant_id: string
    transaction_id: string
    message?: string | null
    status?: $Enums.BookingStatus
    start: Date | string
    end: Date | string
    created?: Date | string
    updated?: Date | string
    booking_events?: BookingEventUncheckedCreateNestedManyWithoutBookingInput
    booking_additional_options?: BookingAdditionalOptionUncheckedCreateNestedManyWithoutBookingInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBookingInput
    messages?: MessageUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_variant?: BookingVariantUpdateOneRequiredWithoutBookingsNestedInput
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutBookingNestedInput
    booking_events?: BookingEventUpdateManyWithoutBookingNestedInput
    booking_additional_options?: BookingAdditionalOptionUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUpdateManyWithoutBookingNestedInput
    messages?: MessageUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    booking_variant_id?: StringFieldUpdateOperationsInput | string
    transaction_id?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_events?: BookingEventUncheckedUpdateManyWithoutBookingNestedInput
    booking_additional_options?: BookingAdditionalOptionUncheckedUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBookingNestedInput
    messages?: MessageUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingCreateManyInput = {
    id?: string
    user_id: string
    booking_variant_id: string
    transaction_id: string
    message?: string | null
    status?: $Enums.BookingStatus
    start: Date | string
    end: Date | string
    created?: Date | string
    updated?: Date | string
  }

  export type BookingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    booking_variant_id?: StringFieldUpdateOperationsInput | string
    transaction_id?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdditionalOptionCreateInput = {
    id?: string
    name: string
    description: string
    image: string
    price: number
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    booking_additional_options?: BookingAdditionalOptionCreateNestedManyWithoutAdditional_optionInput
  }

  export type AdditionalOptionUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    image: string
    price: number
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    booking_additional_options?: BookingAdditionalOptionUncheckedCreateNestedManyWithoutAdditional_optionInput
  }

  export type AdditionalOptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    booking_additional_options?: BookingAdditionalOptionUpdateManyWithoutAdditional_optionNestedInput
  }

  export type AdditionalOptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    booking_additional_options?: BookingAdditionalOptionUncheckedUpdateManyWithoutAdditional_optionNestedInput
  }

  export type AdditionalOptionCreateManyInput = {
    id?: string
    name: string
    description: string
    image: string
    price: number
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type AdditionalOptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdditionalOptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BookingAdditionalOptionCreateInput = {
    id?: string
    amount: number
    created?: Date | string
    updated?: Date | string
    booking: BookingCreateNestedOneWithoutBooking_additional_optionsInput
    additional_option: AdditionalOptionCreateNestedOneWithoutBooking_additional_optionsInput
  }

  export type BookingAdditionalOptionUncheckedCreateInput = {
    id?: string
    amount: number
    option_id: string
    booking_id: string
    created?: Date | string
    updated?: Date | string
  }

  export type BookingAdditionalOptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutBooking_additional_optionsNestedInput
    additional_option?: AdditionalOptionUpdateOneRequiredWithoutBooking_additional_optionsNestedInput
  }

  export type BookingAdditionalOptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    option_id?: StringFieldUpdateOperationsInput | string
    booking_id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingAdditionalOptionCreateManyInput = {
    id?: string
    amount: number
    option_id: string
    booking_id: string
    created?: Date | string
    updated?: Date | string
  }

  export type BookingAdditionalOptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingAdditionalOptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    option_id?: StringFieldUpdateOperationsInput | string
    booking_id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingEventCreateInput = {
    id?: string
    number_of_people: number
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    booking: BookingCreateNestedOneWithoutBooking_eventsInput
    event: EventCreateNestedOneWithoutBooking_eventsInput
    transaction: TransactionCreateNestedOneWithoutBooking_eventInput
  }

  export type BookingEventUncheckedCreateInput = {
    id?: string
    number_of_people: number
    booking_id: string
    event_id: string
    transaction_id: string
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type BookingEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number_of_people?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    booking?: BookingUpdateOneRequiredWithoutBooking_eventsNestedInput
    event?: EventUpdateOneRequiredWithoutBooking_eventsNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutBooking_eventNestedInput
  }

  export type BookingEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number_of_people?: IntFieldUpdateOperationsInput | number
    booking_id?: StringFieldUpdateOperationsInput | string
    event_id?: StringFieldUpdateOperationsInput | string
    transaction_id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BookingEventCreateManyInput = {
    id?: string
    number_of_people: number
    booking_id: string
    event_id: string
    transaction_id: string
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type BookingEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number_of_people?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BookingEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    number_of_people?: IntFieldUpdateOperationsInput | number
    booking_id?: StringFieldUpdateOperationsInput | string
    event_id?: StringFieldUpdateOperationsInput | string
    transaction_id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TransactionCreateInput = {
    id?: string
    amount: number
    description: string
    transaction_type: $Enums.TransactionType
    transaction_status: $Enums.TransactionStatus
    payment_method: $Enums.PaymentMethod
    created?: Date | string
    updated?: Date | string
    user: UserCreateNestedOneWithoutTransactionsInput
    card_detail?: CardDetailCreateNestedOneWithoutTransactionsInput
    transfer_detail?: TransferDetailCreateNestedOneWithoutTransactionsInput
    booking?: BookingCreateNestedOneWithoutTransactionInput
    booking_event?: BookingEventCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    amount: number
    user_id: string
    description: string
    card_details_id?: string | null
    transfer_details_id?: string | null
    transaction_type: $Enums.TransactionType
    transaction_status: $Enums.TransactionStatus
    payment_method: $Enums.PaymentMethod
    created?: Date | string
    updated?: Date | string
    booking?: BookingUncheckedCreateNestedOneWithoutTransactionInput
    booking_event?: BookingEventUncheckedCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    transaction_type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transaction_status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    card_detail?: CardDetailUpdateOneWithoutTransactionsNestedInput
    transfer_detail?: TransferDetailUpdateOneWithoutTransactionsNestedInput
    booking?: BookingUpdateOneWithoutTransactionNestedInput
    booking_event?: BookingEventUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    card_details_id?: NullableStringFieldUpdateOperationsInput | string | null
    transfer_details_id?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transaction_status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUncheckedUpdateOneWithoutTransactionNestedInput
    booking_event?: BookingEventUncheckedUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionCreateManyInput = {
    id?: string
    amount: number
    user_id: string
    description: string
    card_details_id?: string | null
    transfer_details_id?: string | null
    transaction_type: $Enums.TransactionType
    transaction_status: $Enums.TransactionStatus
    payment_method: $Enums.PaymentMethod
    created?: Date | string
    updated?: Date | string
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    transaction_type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transaction_status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    card_details_id?: NullableStringFieldUpdateOperationsInput | string | null
    transfer_details_id?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transaction_status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferDetailCreateInput = {
    id?: string
    bank_name: string
    account_number: string
    swift: string
    payer_name: string
    created?: Date | string
    updated?: Date | string
    transactions?: TransactionCreateNestedManyWithoutTransfer_detailInput
    user: UserCreateNestedOneWithoutTransfer_detailsInput
  }

  export type TransferDetailUncheckedCreateInput = {
    id?: string
    bank_name: string
    account_number: string
    swift: string
    payer_name: string
    user_id: string
    created?: Date | string
    updated?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutTransfer_detailInput
  }

  export type TransferDetailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bank_name?: StringFieldUpdateOperationsInput | string
    account_number?: StringFieldUpdateOperationsInput | string
    swift?: StringFieldUpdateOperationsInput | string
    payer_name?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutTransfer_detailNestedInput
    user?: UserUpdateOneRequiredWithoutTransfer_detailsNestedInput
  }

  export type TransferDetailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bank_name?: StringFieldUpdateOperationsInput | string
    account_number?: StringFieldUpdateOperationsInput | string
    swift?: StringFieldUpdateOperationsInput | string
    payer_name?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutTransfer_detailNestedInput
  }

  export type TransferDetailCreateManyInput = {
    id?: string
    bank_name: string
    account_number: string
    swift: string
    payer_name: string
    user_id: string
    created?: Date | string
    updated?: Date | string
  }

  export type TransferDetailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bank_name?: StringFieldUpdateOperationsInput | string
    account_number?: StringFieldUpdateOperationsInput | string
    swift?: StringFieldUpdateOperationsInput | string
    payer_name?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferDetailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bank_name?: StringFieldUpdateOperationsInput | string
    account_number?: StringFieldUpdateOperationsInput | string
    swift?: StringFieldUpdateOperationsInput | string
    payer_name?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CardDetailCreateInput = {
    id?: string
    number: string
    expiry_month: number
    expiry_year: number
    holder: string
    token: string
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    transactions?: TransactionCreateNestedManyWithoutCard_detailInput
    user: UserCreateNestedOneWithoutCard_detailsInput
  }

  export type CardDetailUncheckedCreateInput = {
    id?: string
    user_id: string
    number: string
    expiry_month: number
    expiry_year: number
    holder: string
    token: string
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    transactions?: TransactionUncheckedCreateNestedManyWithoutCard_detailInput
  }

  export type CardDetailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    expiry_month?: IntFieldUpdateOperationsInput | number
    expiry_year?: IntFieldUpdateOperationsInput | number
    holder?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    transactions?: TransactionUpdateManyWithoutCard_detailNestedInput
    user?: UserUpdateOneRequiredWithoutCard_detailsNestedInput
  }

  export type CardDetailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    expiry_month?: IntFieldUpdateOperationsInput | number
    expiry_year?: IntFieldUpdateOperationsInput | number
    holder?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    transactions?: TransactionUncheckedUpdateManyWithoutCard_detailNestedInput
  }

  export type CardDetailCreateManyInput = {
    id?: string
    user_id: string
    number: string
    expiry_month: number
    expiry_year: number
    holder: string
    token: string
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type CardDetailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    expiry_month?: IntFieldUpdateOperationsInput | number
    expiry_year?: IntFieldUpdateOperationsInput | number
    holder?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CardDetailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    expiry_month?: IntFieldUpdateOperationsInput | number
    expiry_year?: IntFieldUpdateOperationsInput | number
    holder?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EventCreateInput = {
    id?: string
    name: string
    image: string
    description: string
    price: number
    capacity: number
    start: Date | string
    end: Date | string
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    guide?: UserCreateNestedOneWithoutEventsInput
    images?: EventImageCreateNestedManyWithoutEventInput
    booking_events?: BookingEventCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateInput = {
    id?: string
    name: string
    image: string
    description: string
    guide_id?: string | null
    price: number
    capacity: number
    start: Date | string
    end: Date | string
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    images?: EventImageUncheckedCreateNestedManyWithoutEventInput
    booking_events?: BookingEventUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    guide?: UserUpdateOneWithoutEventsNestedInput
    images?: EventImageUpdateManyWithoutEventNestedInput
    booking_events?: BookingEventUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    guide_id?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    images?: EventImageUncheckedUpdateManyWithoutEventNestedInput
    booking_events?: BookingEventUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventCreateManyInput = {
    id?: string
    name: string
    image: string
    description: string
    guide_id?: string | null
    price: number
    capacity: number
    start: Date | string
    end: Date | string
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type EventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    guide_id?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EventImageCreateInput = {
    id?: string
    name: string
    image?: string | null
    description?: string | null
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    event: EventCreateNestedOneWithoutImagesInput
  }

  export type EventImageUncheckedCreateInput = {
    id?: string
    name: string
    image?: string | null
    description?: string | null
    event_id: string
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type EventImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    event?: EventUpdateOneRequiredWithoutImagesNestedInput
  }

  export type EventImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    event_id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EventImageCreateManyInput = {
    id?: string
    name: string
    image?: string | null
    description?: string | null
    event_id: string
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type EventImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EventImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    event_id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ReservationListRelationFilter = {
    every?: ReservationWhereInput
    some?: ReservationWhereInput
    none?: ReservationWhereInput
  }

  export type EventListRelationFilter = {
    every?: EventWhereInput
    some?: EventWhereInput
    none?: EventWhereInput
  }

  export type BookingListRelationFilter = {
    every?: BookingWhereInput
    some?: BookingWhereInput
    none?: BookingWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type CardDetailListRelationFilter = {
    every?: CardDetailWhereInput
    some?: CardDetailWhereInput
    none?: CardDetailWhereInput
  }

  export type TransferDetailListRelationFilter = {
    every?: TransferDetailWhereInput
    some?: TransferDetailWhereInput
    none?: TransferDetailWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ReservationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CardDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransferDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    image?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    phone_number?: SortOrder
    date_of_birth?: SortOrder
    is_active?: SortOrder
    email_verified?: SortOrder
    phone_verified?: SortOrder
    role?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    image?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    phone_number?: SortOrder
    date_of_birth?: SortOrder
    is_active?: SortOrder
    email_verified?: SortOrder
    phone_verified?: SortOrder
    role?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    image?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    phone_number?: SortOrder
    date_of_birth?: SortOrder
    is_active?: SortOrder
    email_verified?: SortOrder
    phone_verified?: SortOrder
    role?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type EnumNotificationActionFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationAction | EnumNotificationActionFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationAction[] | ListEnumNotificationActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationAction[] | ListEnumNotificationActionFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationActionFilter<$PrismaModel> | $Enums.NotificationAction
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    action?: SortOrder
    message?: SortOrder
    user_id?: SortOrder
    is_read?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    action?: SortOrder
    message?: SortOrder
    user_id?: SortOrder
    is_read?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    action?: SortOrder
    message?: SortOrder
    user_id?: SortOrder
    is_read?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type EnumNotificationActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationAction | EnumNotificationActionFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationAction[] | ListEnumNotificationActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationAction[] | ListEnumNotificationActionFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationActionWithAggregatesFilter<$PrismaModel> | $Enums.NotificationAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationActionFilter<$PrismaModel>
    _max?: NestedEnumNotificationActionFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type BookingNullableScalarRelationFilter = {
    is?: BookingWhereInput | null
    isNot?: BookingWhereInput | null
  }

  export type MessageNullableScalarRelationFilter = {
    is?: MessageWhereInput | null
    isNot?: MessageWhereInput | null
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    sender_id?: SortOrder
    receiver_id?: SortOrder
    message?: SortOrder
    is_read?: SortOrder
    booking_id?: SortOrder
    edited?: SortOrder
    replace_to?: SortOrder
    is_excluded?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    sender_id?: SortOrder
    receiver_id?: SortOrder
    message?: SortOrder
    is_read?: SortOrder
    booking_id?: SortOrder
    edited?: SortOrder
    replace_to?: SortOrder
    is_excluded?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    sender_id?: SortOrder
    receiver_id?: SortOrder
    message?: SortOrder
    is_read?: SortOrder
    booking_id?: SortOrder
    edited?: SortOrder
    replace_to?: SortOrder
    is_excluded?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumApartmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ApartmentType | EnumApartmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApartmentType[] | ListEnumApartmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApartmentType[] | ListEnumApartmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApartmentTypeFilter<$PrismaModel> | $Enums.ApartmentType
  }

  export type ApartmentImageListRelationFilter = {
    every?: ApartmentImageWhereInput
    some?: ApartmentImageWhereInput
    none?: ApartmentImageWhereInput
  }

  export type ApartmentBedListRelationFilter = {
    every?: ApartmentBedWhereInput
    some?: ApartmentBedWhereInput
    none?: ApartmentBedWhereInput
  }

  export type ApartmentAmenityListRelationFilter = {
    every?: ApartmentAmenityWhereInput
    some?: ApartmentAmenityWhereInput
    none?: ApartmentAmenityWhereInput
  }

  export type BookingVariantListRelationFilter = {
    every?: BookingVariantWhereInput
    some?: BookingVariantWhereInput
    none?: BookingVariantWhereInput
  }

  export type ApartmentImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApartmentBedOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApartmentAmenityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingVariantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApartmentCountOrderByAggregateInput = {
    id?: SortOrder
    image?: SortOrder
    name?: SortOrder
    description?: SortOrder
    rules?: SortOrder
    number?: SortOrder
    floor?: SortOrder
    rooms_count?: SortOrder
    max_capacity?: SortOrder
    is_available?: SortOrder
    is_smoking?: SortOrder
    is_pet_friendly?: SortOrder
    deposit?: SortOrder
    type?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
  }

  export type ApartmentAvgOrderByAggregateInput = {
    number?: SortOrder
    floor?: SortOrder
    rooms_count?: SortOrder
    max_capacity?: SortOrder
    deposit?: SortOrder
  }

  export type ApartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    image?: SortOrder
    name?: SortOrder
    description?: SortOrder
    rules?: SortOrder
    number?: SortOrder
    floor?: SortOrder
    rooms_count?: SortOrder
    max_capacity?: SortOrder
    is_available?: SortOrder
    is_smoking?: SortOrder
    is_pet_friendly?: SortOrder
    deposit?: SortOrder
    type?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
  }

  export type ApartmentMinOrderByAggregateInput = {
    id?: SortOrder
    image?: SortOrder
    name?: SortOrder
    description?: SortOrder
    rules?: SortOrder
    number?: SortOrder
    floor?: SortOrder
    rooms_count?: SortOrder
    max_capacity?: SortOrder
    is_available?: SortOrder
    is_smoking?: SortOrder
    is_pet_friendly?: SortOrder
    deposit?: SortOrder
    type?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
  }

  export type ApartmentSumOrderByAggregateInput = {
    number?: SortOrder
    floor?: SortOrder
    rooms_count?: SortOrder
    max_capacity?: SortOrder
    deposit?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumApartmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApartmentType | EnumApartmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApartmentType[] | ListEnumApartmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApartmentType[] | ListEnumApartmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApartmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.ApartmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApartmentTypeFilter<$PrismaModel>
    _max?: NestedEnumApartmentTypeFilter<$PrismaModel>
  }

  export type ApartmentNullableScalarRelationFilter = {
    is?: ApartmentWhereInput | null
    isNot?: ApartmentWhereInput | null
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    apartment_id?: SortOrder
    booking_id?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    apartment_id?: SortOrder
    booking_id?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    apartment_id?: SortOrder
    booking_id?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type AmenityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    description?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
  }

  export type AmenityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    description?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
  }

  export type AmenityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    description?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
  }

  export type ApartmentScalarRelationFilter = {
    is?: ApartmentWhereInput
    isNot?: ApartmentWhereInput
  }

  export type AmenityScalarRelationFilter = {
    is?: AmenityWhereInput
    isNot?: AmenityWhereInput
  }

  export type ApartmentAmenityApartment_idAmenity_idCompoundUniqueInput = {
    apartment_id: string
    amenity_id: string
  }

  export type ApartmentAmenityCountOrderByAggregateInput = {
    id?: SortOrder
    amenity_id?: SortOrder
    apartment_id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
  }

  export type ApartmentAmenityMaxOrderByAggregateInput = {
    id?: SortOrder
    amenity_id?: SortOrder
    apartment_id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
  }

  export type ApartmentAmenityMinOrderByAggregateInput = {
    id?: SortOrder
    amenity_id?: SortOrder
    apartment_id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
  }

  export type ApartmentImageCountOrderByAggregateInput = {
    id?: SortOrder
    image?: SortOrder
    name?: SortOrder
    description?: SortOrder
    apartment_id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
  }

  export type ApartmentImageMaxOrderByAggregateInput = {
    id?: SortOrder
    image?: SortOrder
    name?: SortOrder
    description?: SortOrder
    apartment_id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
  }

  export type ApartmentImageMinOrderByAggregateInput = {
    id?: SortOrder
    image?: SortOrder
    name?: SortOrder
    description?: SortOrder
    apartment_id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
  }

  export type BedTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
  }

  export type BedTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
  }

  export type BedTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
  }

  export type BedTypeScalarRelationFilter = {
    is?: BedTypeWhereInput
    isNot?: BedTypeWhereInput
  }

  export type ApartmentBedApartment_idBed_type_idCompoundUniqueInput = {
    apartment_id: string
    bed_type_id: string
  }

  export type ApartmentBedCountOrderByAggregateInput = {
    id?: SortOrder
    apartment_id?: SortOrder
    bed_type_id?: SortOrder
    count?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
  }

  export type ApartmentBedAvgOrderByAggregateInput = {
    count?: SortOrder
  }

  export type ApartmentBedMaxOrderByAggregateInput = {
    id?: SortOrder
    apartment_id?: SortOrder
    bed_type_id?: SortOrder
    count?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
  }

  export type ApartmentBedMinOrderByAggregateInput = {
    id?: SortOrder
    apartment_id?: SortOrder
    bed_type_id?: SortOrder
    count?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
  }

  export type ApartmentBedSumOrderByAggregateInput = {
    count?: SortOrder
  }

  export type BookingVariantCountOrderByAggregateInput = {
    id?: SortOrder
    apartment_id?: SortOrder
    price?: SortOrder
    capacity?: SortOrder
    is_available?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
  }

  export type BookingVariantAvgOrderByAggregateInput = {
    price?: SortOrder
    capacity?: SortOrder
  }

  export type BookingVariantMaxOrderByAggregateInput = {
    id?: SortOrder
    apartment_id?: SortOrder
    price?: SortOrder
    capacity?: SortOrder
    is_available?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
  }

  export type BookingVariantMinOrderByAggregateInput = {
    id?: SortOrder
    apartment_id?: SortOrder
    price?: SortOrder
    capacity?: SortOrder
    is_available?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
  }

  export type BookingVariantSumOrderByAggregateInput = {
    price?: SortOrder
    capacity?: SortOrder
  }

  export type ReservationCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    apartment_id?: SortOrder
    start?: SortOrder
    end?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type ReservationMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    apartment_id?: SortOrder
    start?: SortOrder
    end?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type ReservationMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    apartment_id?: SortOrder
    start?: SortOrder
    end?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type EnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type BookingVariantScalarRelationFilter = {
    is?: BookingVariantWhereInput
    isNot?: BookingVariantWhereInput
  }

  export type TransactionScalarRelationFilter = {
    is?: TransactionWhereInput
    isNot?: TransactionWhereInput
  }

  export type BookingEventListRelationFilter = {
    every?: BookingEventWhereInput
    some?: BookingEventWhereInput
    none?: BookingEventWhereInput
  }

  export type BookingAdditionalOptionListRelationFilter = {
    every?: BookingAdditionalOptionWhereInput
    some?: BookingAdditionalOptionWhereInput
    none?: BookingAdditionalOptionWhereInput
  }

  export type BookingEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingAdditionalOptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    booking_variant_id?: SortOrder
    transaction_id?: SortOrder
    message?: SortOrder
    status?: SortOrder
    start?: SortOrder
    end?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type BookingMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    booking_variant_id?: SortOrder
    transaction_id?: SortOrder
    message?: SortOrder
    status?: SortOrder
    start?: SortOrder
    end?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type BookingMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    booking_variant_id?: SortOrder
    transaction_id?: SortOrder
    message?: SortOrder
    status?: SortOrder
    start?: SortOrder
    end?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type EnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type AdditionalOptionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    price?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
  }

  export type AdditionalOptionAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type AdditionalOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    price?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
  }

  export type AdditionalOptionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    price?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
  }

  export type AdditionalOptionSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type BookingScalarRelationFilter = {
    is?: BookingWhereInput
    isNot?: BookingWhereInput
  }

  export type AdditionalOptionScalarRelationFilter = {
    is?: AdditionalOptionWhereInput
    isNot?: AdditionalOptionWhereInput
  }

  export type BookingAdditionalOptionBooking_idOption_idCompoundUniqueInput = {
    booking_id: string
    option_id: string
  }

  export type BookingAdditionalOptionCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    option_id?: SortOrder
    booking_id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type BookingAdditionalOptionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type BookingAdditionalOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    option_id?: SortOrder
    booking_id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type BookingAdditionalOptionMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    option_id?: SortOrder
    booking_id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type BookingAdditionalOptionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EventScalarRelationFilter = {
    is?: EventWhereInput
    isNot?: EventWhereInput
  }

  export type BookingEventCountOrderByAggregateInput = {
    id?: SortOrder
    number_of_people?: SortOrder
    booking_id?: SortOrder
    event_id?: SortOrder
    transaction_id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
  }

  export type BookingEventAvgOrderByAggregateInput = {
    number_of_people?: SortOrder
  }

  export type BookingEventMaxOrderByAggregateInput = {
    id?: SortOrder
    number_of_people?: SortOrder
    booking_id?: SortOrder
    event_id?: SortOrder
    transaction_id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
  }

  export type BookingEventMinOrderByAggregateInput = {
    id?: SortOrder
    number_of_people?: SortOrder
    booking_id?: SortOrder
    event_id?: SortOrder
    transaction_id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
  }

  export type BookingEventSumOrderByAggregateInput = {
    number_of_people?: SortOrder
  }

  export type EnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type EnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type CardDetailNullableScalarRelationFilter = {
    is?: CardDetailWhereInput | null
    isNot?: CardDetailWhereInput | null
  }

  export type TransferDetailNullableScalarRelationFilter = {
    is?: TransferDetailWhereInput | null
    isNot?: TransferDetailWhereInput | null
  }

  export type BookingEventNullableScalarRelationFilter = {
    is?: BookingEventWhereInput | null
    isNot?: BookingEventWhereInput | null
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    user_id?: SortOrder
    description?: SortOrder
    card_details_id?: SortOrder
    transfer_details_id?: SortOrder
    transaction_type?: SortOrder
    transaction_status?: SortOrder
    payment_method?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    user_id?: SortOrder
    description?: SortOrder
    card_details_id?: SortOrder
    transfer_details_id?: SortOrder
    transaction_type?: SortOrder
    transaction_status?: SortOrder
    payment_method?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    user_id?: SortOrder
    description?: SortOrder
    card_details_id?: SortOrder
    transfer_details_id?: SortOrder
    transaction_type?: SortOrder
    transaction_status?: SortOrder
    payment_method?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type EnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type TransferDetailCountOrderByAggregateInput = {
    id?: SortOrder
    bank_name?: SortOrder
    account_number?: SortOrder
    swift?: SortOrder
    payer_name?: SortOrder
    user_id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type TransferDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    bank_name?: SortOrder
    account_number?: SortOrder
    swift?: SortOrder
    payer_name?: SortOrder
    user_id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type TransferDetailMinOrderByAggregateInput = {
    id?: SortOrder
    bank_name?: SortOrder
    account_number?: SortOrder
    swift?: SortOrder
    payer_name?: SortOrder
    user_id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type CardDetailCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    number?: SortOrder
    expiry_month?: SortOrder
    expiry_year?: SortOrder
    holder?: SortOrder
    token?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
  }

  export type CardDetailAvgOrderByAggregateInput = {
    expiry_month?: SortOrder
    expiry_year?: SortOrder
  }

  export type CardDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    number?: SortOrder
    expiry_month?: SortOrder
    expiry_year?: SortOrder
    holder?: SortOrder
    token?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
  }

  export type CardDetailMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    number?: SortOrder
    expiry_month?: SortOrder
    expiry_year?: SortOrder
    holder?: SortOrder
    token?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
  }

  export type CardDetailSumOrderByAggregateInput = {
    expiry_month?: SortOrder
    expiry_year?: SortOrder
  }

  export type EventImageListRelationFilter = {
    every?: EventImageWhereInput
    some?: EventImageWhereInput
    none?: EventImageWhereInput
  }

  export type EventImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    description?: SortOrder
    guide_id?: SortOrder
    price?: SortOrder
    capacity?: SortOrder
    start?: SortOrder
    end?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
  }

  export type EventAvgOrderByAggregateInput = {
    price?: SortOrder
    capacity?: SortOrder
  }

  export type EventMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    description?: SortOrder
    guide_id?: SortOrder
    price?: SortOrder
    capacity?: SortOrder
    start?: SortOrder
    end?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
  }

  export type EventMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    description?: SortOrder
    guide_id?: SortOrder
    price?: SortOrder
    capacity?: SortOrder
    start?: SortOrder
    end?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
  }

  export type EventSumOrderByAggregateInput = {
    price?: SortOrder
    capacity?: SortOrder
  }

  export type EventImageCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    description?: SortOrder
    event_id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
  }

  export type EventImageMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    description?: SortOrder
    event_id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
  }

  export type EventImageMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    description?: SortOrder
    event_id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    is_excluded?: SortOrder
  }

  export type ReservationCreateNestedManyWithoutUserInput = {
    create?: XOR<ReservationCreateWithoutUserInput, ReservationUncheckedCreateWithoutUserInput> | ReservationCreateWithoutUserInput[] | ReservationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutUserInput | ReservationCreateOrConnectWithoutUserInput[]
    createMany?: ReservationCreateManyUserInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type EventCreateNestedManyWithoutGuideInput = {
    create?: XOR<EventCreateWithoutGuideInput, EventUncheckedCreateWithoutGuideInput> | EventCreateWithoutGuideInput[] | EventUncheckedCreateWithoutGuideInput[]
    connectOrCreate?: EventCreateOrConnectWithoutGuideInput | EventCreateOrConnectWithoutGuideInput[]
    createMany?: EventCreateManyGuideInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutUserInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type CardDetailCreateNestedManyWithoutUserInput = {
    create?: XOR<CardDetailCreateWithoutUserInput, CardDetailUncheckedCreateWithoutUserInput> | CardDetailCreateWithoutUserInput[] | CardDetailUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CardDetailCreateOrConnectWithoutUserInput | CardDetailCreateOrConnectWithoutUserInput[]
    createMany?: CardDetailCreateManyUserInputEnvelope
    connect?: CardDetailWhereUniqueInput | CardDetailWhereUniqueInput[]
  }

  export type TransferDetailCreateNestedManyWithoutUserInput = {
    create?: XOR<TransferDetailCreateWithoutUserInput, TransferDetailUncheckedCreateWithoutUserInput> | TransferDetailCreateWithoutUserInput[] | TransferDetailUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransferDetailCreateOrConnectWithoutUserInput | TransferDetailCreateOrConnectWithoutUserInput[]
    createMany?: TransferDetailCreateManyUserInputEnvelope
    connect?: TransferDetailWhereUniqueInput | TransferDetailWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ReservationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReservationCreateWithoutUserInput, ReservationUncheckedCreateWithoutUserInput> | ReservationCreateWithoutUserInput[] | ReservationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutUserInput | ReservationCreateOrConnectWithoutUserInput[]
    createMany?: ReservationCreateManyUserInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutGuideInput = {
    create?: XOR<EventCreateWithoutGuideInput, EventUncheckedCreateWithoutGuideInput> | EventCreateWithoutGuideInput[] | EventUncheckedCreateWithoutGuideInput[]
    connectOrCreate?: EventCreateOrConnectWithoutGuideInput | EventCreateOrConnectWithoutGuideInput[]
    createMany?: EventCreateManyGuideInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type CardDetailUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CardDetailCreateWithoutUserInput, CardDetailUncheckedCreateWithoutUserInput> | CardDetailCreateWithoutUserInput[] | CardDetailUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CardDetailCreateOrConnectWithoutUserInput | CardDetailCreateOrConnectWithoutUserInput[]
    createMany?: CardDetailCreateManyUserInputEnvelope
    connect?: CardDetailWhereUniqueInput | CardDetailWhereUniqueInput[]
  }

  export type TransferDetailUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TransferDetailCreateWithoutUserInput, TransferDetailUncheckedCreateWithoutUserInput> | TransferDetailCreateWithoutUserInput[] | TransferDetailUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransferDetailCreateOrConnectWithoutUserInput | TransferDetailCreateOrConnectWithoutUserInput[]
    createMany?: TransferDetailCreateManyUserInputEnvelope
    connect?: TransferDetailWhereUniqueInput | TransferDetailWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ReservationUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReservationCreateWithoutUserInput, ReservationUncheckedCreateWithoutUserInput> | ReservationCreateWithoutUserInput[] | ReservationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutUserInput | ReservationCreateOrConnectWithoutUserInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutUserInput | ReservationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReservationCreateManyUserInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutUserInput | ReservationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutUserInput | ReservationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type EventUpdateManyWithoutGuideNestedInput = {
    create?: XOR<EventCreateWithoutGuideInput, EventUncheckedCreateWithoutGuideInput> | EventCreateWithoutGuideInput[] | EventUncheckedCreateWithoutGuideInput[]
    connectOrCreate?: EventCreateOrConnectWithoutGuideInput | EventCreateOrConnectWithoutGuideInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutGuideInput | EventUpsertWithWhereUniqueWithoutGuideInput[]
    createMany?: EventCreateManyGuideInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutGuideInput | EventUpdateWithWhereUniqueWithoutGuideInput[]
    updateMany?: EventUpdateManyWithWhereWithoutGuideInput | EventUpdateManyWithWhereWithoutGuideInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutUserInput | BookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutUserInput | BookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutUserInput | BookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type CardDetailUpdateManyWithoutUserNestedInput = {
    create?: XOR<CardDetailCreateWithoutUserInput, CardDetailUncheckedCreateWithoutUserInput> | CardDetailCreateWithoutUserInput[] | CardDetailUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CardDetailCreateOrConnectWithoutUserInput | CardDetailCreateOrConnectWithoutUserInput[]
    upsert?: CardDetailUpsertWithWhereUniqueWithoutUserInput | CardDetailUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CardDetailCreateManyUserInputEnvelope
    set?: CardDetailWhereUniqueInput | CardDetailWhereUniqueInput[]
    disconnect?: CardDetailWhereUniqueInput | CardDetailWhereUniqueInput[]
    delete?: CardDetailWhereUniqueInput | CardDetailWhereUniqueInput[]
    connect?: CardDetailWhereUniqueInput | CardDetailWhereUniqueInput[]
    update?: CardDetailUpdateWithWhereUniqueWithoutUserInput | CardDetailUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CardDetailUpdateManyWithWhereWithoutUserInput | CardDetailUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CardDetailScalarWhereInput | CardDetailScalarWhereInput[]
  }

  export type TransferDetailUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransferDetailCreateWithoutUserInput, TransferDetailUncheckedCreateWithoutUserInput> | TransferDetailCreateWithoutUserInput[] | TransferDetailUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransferDetailCreateOrConnectWithoutUserInput | TransferDetailCreateOrConnectWithoutUserInput[]
    upsert?: TransferDetailUpsertWithWhereUniqueWithoutUserInput | TransferDetailUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransferDetailCreateManyUserInputEnvelope
    set?: TransferDetailWhereUniqueInput | TransferDetailWhereUniqueInput[]
    disconnect?: TransferDetailWhereUniqueInput | TransferDetailWhereUniqueInput[]
    delete?: TransferDetailWhereUniqueInput | TransferDetailWhereUniqueInput[]
    connect?: TransferDetailWhereUniqueInput | TransferDetailWhereUniqueInput[]
    update?: TransferDetailUpdateWithWhereUniqueWithoutUserInput | TransferDetailUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransferDetailUpdateManyWithWhereWithoutUserInput | TransferDetailUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransferDetailScalarWhereInput | TransferDetailScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ReservationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReservationCreateWithoutUserInput, ReservationUncheckedCreateWithoutUserInput> | ReservationCreateWithoutUserInput[] | ReservationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutUserInput | ReservationCreateOrConnectWithoutUserInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutUserInput | ReservationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReservationCreateManyUserInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutUserInput | ReservationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutUserInput | ReservationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutGuideNestedInput = {
    create?: XOR<EventCreateWithoutGuideInput, EventUncheckedCreateWithoutGuideInput> | EventCreateWithoutGuideInput[] | EventUncheckedCreateWithoutGuideInput[]
    connectOrCreate?: EventCreateOrConnectWithoutGuideInput | EventCreateOrConnectWithoutGuideInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutGuideInput | EventUpsertWithWhereUniqueWithoutGuideInput[]
    createMany?: EventCreateManyGuideInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutGuideInput | EventUpdateWithWhereUniqueWithoutGuideInput[]
    updateMany?: EventUpdateManyWithWhereWithoutGuideInput | EventUpdateManyWithWhereWithoutGuideInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutUserInput | BookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutUserInput | BookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutUserInput | BookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type CardDetailUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CardDetailCreateWithoutUserInput, CardDetailUncheckedCreateWithoutUserInput> | CardDetailCreateWithoutUserInput[] | CardDetailUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CardDetailCreateOrConnectWithoutUserInput | CardDetailCreateOrConnectWithoutUserInput[]
    upsert?: CardDetailUpsertWithWhereUniqueWithoutUserInput | CardDetailUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CardDetailCreateManyUserInputEnvelope
    set?: CardDetailWhereUniqueInput | CardDetailWhereUniqueInput[]
    disconnect?: CardDetailWhereUniqueInput | CardDetailWhereUniqueInput[]
    delete?: CardDetailWhereUniqueInput | CardDetailWhereUniqueInput[]
    connect?: CardDetailWhereUniqueInput | CardDetailWhereUniqueInput[]
    update?: CardDetailUpdateWithWhereUniqueWithoutUserInput | CardDetailUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CardDetailUpdateManyWithWhereWithoutUserInput | CardDetailUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CardDetailScalarWhereInput | CardDetailScalarWhereInput[]
  }

  export type TransferDetailUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransferDetailCreateWithoutUserInput, TransferDetailUncheckedCreateWithoutUserInput> | TransferDetailCreateWithoutUserInput[] | TransferDetailUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransferDetailCreateOrConnectWithoutUserInput | TransferDetailCreateOrConnectWithoutUserInput[]
    upsert?: TransferDetailUpsertWithWhereUniqueWithoutUserInput | TransferDetailUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransferDetailCreateManyUserInputEnvelope
    set?: TransferDetailWhereUniqueInput | TransferDetailWhereUniqueInput[]
    disconnect?: TransferDetailWhereUniqueInput | TransferDetailWhereUniqueInput[]
    delete?: TransferDetailWhereUniqueInput | TransferDetailWhereUniqueInput[]
    connect?: TransferDetailWhereUniqueInput | TransferDetailWhereUniqueInput[]
    update?: TransferDetailUpdateWithWhereUniqueWithoutUserInput | TransferDetailUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransferDetailUpdateManyWithWhereWithoutUserInput | TransferDetailUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransferDetailScalarWhereInput | TransferDetailScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type EnumNotificationActionFieldUpdateOperationsInput = {
    set?: $Enums.NotificationAction
  }

  export type UserUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutSent_messagesInput = {
    create?: XOR<UserCreateWithoutSent_messagesInput, UserUncheckedCreateWithoutSent_messagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSent_messagesInput
    connect?: UserWhereUniqueInput
  }

  export type BookingCreateNestedOneWithoutMessagesInput = {
    create?: XOR<BookingCreateWithoutMessagesInput, BookingUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: BookingCreateOrConnectWithoutMessagesInput
    connect?: BookingWhereUniqueInput
  }

  export type MessageCreateNestedOneWithoutReplaced_byInput = {
    create?: XOR<MessageCreateWithoutReplaced_byInput, MessageUncheckedCreateWithoutReplaced_byInput>
    connectOrCreate?: MessageCreateOrConnectWithoutReplaced_byInput
    connect?: MessageWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutReplacesInput = {
    create?: XOR<MessageCreateWithoutReplacesInput, MessageUncheckedCreateWithoutReplacesInput> | MessageCreateWithoutReplacesInput[] | MessageUncheckedCreateWithoutReplacesInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReplacesInput | MessageCreateOrConnectWithoutReplacesInput[]
    createMany?: MessageCreateManyReplacesInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutReplacesInput = {
    create?: XOR<MessageCreateWithoutReplacesInput, MessageUncheckedCreateWithoutReplacesInput> | MessageCreateWithoutReplacesInput[] | MessageUncheckedCreateWithoutReplacesInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReplacesInput | MessageCreateOrConnectWithoutReplacesInput[]
    createMany?: MessageCreateManyReplacesInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutSent_messagesNestedInput = {
    create?: XOR<UserCreateWithoutSent_messagesInput, UserUncheckedCreateWithoutSent_messagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSent_messagesInput
    upsert?: UserUpsertWithoutSent_messagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSent_messagesInput, UserUpdateWithoutSent_messagesInput>, UserUncheckedUpdateWithoutSent_messagesInput>
  }

  export type BookingUpdateOneWithoutMessagesNestedInput = {
    create?: XOR<BookingCreateWithoutMessagesInput, BookingUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: BookingCreateOrConnectWithoutMessagesInput
    upsert?: BookingUpsertWithoutMessagesInput
    disconnect?: BookingWhereInput | boolean
    delete?: BookingWhereInput | boolean
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutMessagesInput, BookingUpdateWithoutMessagesInput>, BookingUncheckedUpdateWithoutMessagesInput>
  }

  export type MessageUpdateOneWithoutReplaced_byNestedInput = {
    create?: XOR<MessageCreateWithoutReplaced_byInput, MessageUncheckedCreateWithoutReplaced_byInput>
    connectOrCreate?: MessageCreateOrConnectWithoutReplaced_byInput
    upsert?: MessageUpsertWithoutReplaced_byInput
    disconnect?: MessageWhereInput | boolean
    delete?: MessageWhereInput | boolean
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutReplaced_byInput, MessageUpdateWithoutReplaced_byInput>, MessageUncheckedUpdateWithoutReplaced_byInput>
  }

  export type MessageUpdateManyWithoutReplacesNestedInput = {
    create?: XOR<MessageCreateWithoutReplacesInput, MessageUncheckedCreateWithoutReplacesInput> | MessageCreateWithoutReplacesInput[] | MessageUncheckedCreateWithoutReplacesInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReplacesInput | MessageCreateOrConnectWithoutReplacesInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutReplacesInput | MessageUpsertWithWhereUniqueWithoutReplacesInput[]
    createMany?: MessageCreateManyReplacesInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutReplacesInput | MessageUpdateWithWhereUniqueWithoutReplacesInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutReplacesInput | MessageUpdateManyWithWhereWithoutReplacesInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutReplacesNestedInput = {
    create?: XOR<MessageCreateWithoutReplacesInput, MessageUncheckedCreateWithoutReplacesInput> | MessageCreateWithoutReplacesInput[] | MessageUncheckedCreateWithoutReplacesInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReplacesInput | MessageCreateOrConnectWithoutReplacesInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutReplacesInput | MessageUpsertWithWhereUniqueWithoutReplacesInput[]
    createMany?: MessageCreateManyReplacesInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutReplacesInput | MessageUpdateWithWhereUniqueWithoutReplacesInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutReplacesInput | MessageUpdateManyWithWhereWithoutReplacesInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ApartmentImageCreateNestedManyWithoutApartmentInput = {
    create?: XOR<ApartmentImageCreateWithoutApartmentInput, ApartmentImageUncheckedCreateWithoutApartmentInput> | ApartmentImageCreateWithoutApartmentInput[] | ApartmentImageUncheckedCreateWithoutApartmentInput[]
    connectOrCreate?: ApartmentImageCreateOrConnectWithoutApartmentInput | ApartmentImageCreateOrConnectWithoutApartmentInput[]
    createMany?: ApartmentImageCreateManyApartmentInputEnvelope
    connect?: ApartmentImageWhereUniqueInput | ApartmentImageWhereUniqueInput[]
  }

  export type ApartmentBedCreateNestedManyWithoutApartmentInput = {
    create?: XOR<ApartmentBedCreateWithoutApartmentInput, ApartmentBedUncheckedCreateWithoutApartmentInput> | ApartmentBedCreateWithoutApartmentInput[] | ApartmentBedUncheckedCreateWithoutApartmentInput[]
    connectOrCreate?: ApartmentBedCreateOrConnectWithoutApartmentInput | ApartmentBedCreateOrConnectWithoutApartmentInput[]
    createMany?: ApartmentBedCreateManyApartmentInputEnvelope
    connect?: ApartmentBedWhereUniqueInput | ApartmentBedWhereUniqueInput[]
  }

  export type ApartmentAmenityCreateNestedManyWithoutApartmentInput = {
    create?: XOR<ApartmentAmenityCreateWithoutApartmentInput, ApartmentAmenityUncheckedCreateWithoutApartmentInput> | ApartmentAmenityCreateWithoutApartmentInput[] | ApartmentAmenityUncheckedCreateWithoutApartmentInput[]
    connectOrCreate?: ApartmentAmenityCreateOrConnectWithoutApartmentInput | ApartmentAmenityCreateOrConnectWithoutApartmentInput[]
    createMany?: ApartmentAmenityCreateManyApartmentInputEnvelope
    connect?: ApartmentAmenityWhereUniqueInput | ApartmentAmenityWhereUniqueInput[]
  }

  export type ReservationCreateNestedManyWithoutApartmentInput = {
    create?: XOR<ReservationCreateWithoutApartmentInput, ReservationUncheckedCreateWithoutApartmentInput> | ReservationCreateWithoutApartmentInput[] | ReservationUncheckedCreateWithoutApartmentInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutApartmentInput | ReservationCreateOrConnectWithoutApartmentInput[]
    createMany?: ReservationCreateManyApartmentInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type BookingVariantCreateNestedManyWithoutApartmentInput = {
    create?: XOR<BookingVariantCreateWithoutApartmentInput, BookingVariantUncheckedCreateWithoutApartmentInput> | BookingVariantCreateWithoutApartmentInput[] | BookingVariantUncheckedCreateWithoutApartmentInput[]
    connectOrCreate?: BookingVariantCreateOrConnectWithoutApartmentInput | BookingVariantCreateOrConnectWithoutApartmentInput[]
    createMany?: BookingVariantCreateManyApartmentInputEnvelope
    connect?: BookingVariantWhereUniqueInput | BookingVariantWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutApartmentInput = {
    create?: XOR<ReviewCreateWithoutApartmentInput, ReviewUncheckedCreateWithoutApartmentInput> | ReviewCreateWithoutApartmentInput[] | ReviewUncheckedCreateWithoutApartmentInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutApartmentInput | ReviewCreateOrConnectWithoutApartmentInput[]
    createMany?: ReviewCreateManyApartmentInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ApartmentImageUncheckedCreateNestedManyWithoutApartmentInput = {
    create?: XOR<ApartmentImageCreateWithoutApartmentInput, ApartmentImageUncheckedCreateWithoutApartmentInput> | ApartmentImageCreateWithoutApartmentInput[] | ApartmentImageUncheckedCreateWithoutApartmentInput[]
    connectOrCreate?: ApartmentImageCreateOrConnectWithoutApartmentInput | ApartmentImageCreateOrConnectWithoutApartmentInput[]
    createMany?: ApartmentImageCreateManyApartmentInputEnvelope
    connect?: ApartmentImageWhereUniqueInput | ApartmentImageWhereUniqueInput[]
  }

  export type ApartmentBedUncheckedCreateNestedManyWithoutApartmentInput = {
    create?: XOR<ApartmentBedCreateWithoutApartmentInput, ApartmentBedUncheckedCreateWithoutApartmentInput> | ApartmentBedCreateWithoutApartmentInput[] | ApartmentBedUncheckedCreateWithoutApartmentInput[]
    connectOrCreate?: ApartmentBedCreateOrConnectWithoutApartmentInput | ApartmentBedCreateOrConnectWithoutApartmentInput[]
    createMany?: ApartmentBedCreateManyApartmentInputEnvelope
    connect?: ApartmentBedWhereUniqueInput | ApartmentBedWhereUniqueInput[]
  }

  export type ApartmentAmenityUncheckedCreateNestedManyWithoutApartmentInput = {
    create?: XOR<ApartmentAmenityCreateWithoutApartmentInput, ApartmentAmenityUncheckedCreateWithoutApartmentInput> | ApartmentAmenityCreateWithoutApartmentInput[] | ApartmentAmenityUncheckedCreateWithoutApartmentInput[]
    connectOrCreate?: ApartmentAmenityCreateOrConnectWithoutApartmentInput | ApartmentAmenityCreateOrConnectWithoutApartmentInput[]
    createMany?: ApartmentAmenityCreateManyApartmentInputEnvelope
    connect?: ApartmentAmenityWhereUniqueInput | ApartmentAmenityWhereUniqueInput[]
  }

  export type ReservationUncheckedCreateNestedManyWithoutApartmentInput = {
    create?: XOR<ReservationCreateWithoutApartmentInput, ReservationUncheckedCreateWithoutApartmentInput> | ReservationCreateWithoutApartmentInput[] | ReservationUncheckedCreateWithoutApartmentInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutApartmentInput | ReservationCreateOrConnectWithoutApartmentInput[]
    createMany?: ReservationCreateManyApartmentInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type BookingVariantUncheckedCreateNestedManyWithoutApartmentInput = {
    create?: XOR<BookingVariantCreateWithoutApartmentInput, BookingVariantUncheckedCreateWithoutApartmentInput> | BookingVariantCreateWithoutApartmentInput[] | BookingVariantUncheckedCreateWithoutApartmentInput[]
    connectOrCreate?: BookingVariantCreateOrConnectWithoutApartmentInput | BookingVariantCreateOrConnectWithoutApartmentInput[]
    createMany?: BookingVariantCreateManyApartmentInputEnvelope
    connect?: BookingVariantWhereUniqueInput | BookingVariantWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutApartmentInput = {
    create?: XOR<ReviewCreateWithoutApartmentInput, ReviewUncheckedCreateWithoutApartmentInput> | ReviewCreateWithoutApartmentInput[] | ReviewUncheckedCreateWithoutApartmentInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutApartmentInput | ReviewCreateOrConnectWithoutApartmentInput[]
    createMany?: ReviewCreateManyApartmentInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumApartmentTypeFieldUpdateOperationsInput = {
    set?: $Enums.ApartmentType
  }

  export type ApartmentImageUpdateManyWithoutApartmentNestedInput = {
    create?: XOR<ApartmentImageCreateWithoutApartmentInput, ApartmentImageUncheckedCreateWithoutApartmentInput> | ApartmentImageCreateWithoutApartmentInput[] | ApartmentImageUncheckedCreateWithoutApartmentInput[]
    connectOrCreate?: ApartmentImageCreateOrConnectWithoutApartmentInput | ApartmentImageCreateOrConnectWithoutApartmentInput[]
    upsert?: ApartmentImageUpsertWithWhereUniqueWithoutApartmentInput | ApartmentImageUpsertWithWhereUniqueWithoutApartmentInput[]
    createMany?: ApartmentImageCreateManyApartmentInputEnvelope
    set?: ApartmentImageWhereUniqueInput | ApartmentImageWhereUniqueInput[]
    disconnect?: ApartmentImageWhereUniqueInput | ApartmentImageWhereUniqueInput[]
    delete?: ApartmentImageWhereUniqueInput | ApartmentImageWhereUniqueInput[]
    connect?: ApartmentImageWhereUniqueInput | ApartmentImageWhereUniqueInput[]
    update?: ApartmentImageUpdateWithWhereUniqueWithoutApartmentInput | ApartmentImageUpdateWithWhereUniqueWithoutApartmentInput[]
    updateMany?: ApartmentImageUpdateManyWithWhereWithoutApartmentInput | ApartmentImageUpdateManyWithWhereWithoutApartmentInput[]
    deleteMany?: ApartmentImageScalarWhereInput | ApartmentImageScalarWhereInput[]
  }

  export type ApartmentBedUpdateManyWithoutApartmentNestedInput = {
    create?: XOR<ApartmentBedCreateWithoutApartmentInput, ApartmentBedUncheckedCreateWithoutApartmentInput> | ApartmentBedCreateWithoutApartmentInput[] | ApartmentBedUncheckedCreateWithoutApartmentInput[]
    connectOrCreate?: ApartmentBedCreateOrConnectWithoutApartmentInput | ApartmentBedCreateOrConnectWithoutApartmentInput[]
    upsert?: ApartmentBedUpsertWithWhereUniqueWithoutApartmentInput | ApartmentBedUpsertWithWhereUniqueWithoutApartmentInput[]
    createMany?: ApartmentBedCreateManyApartmentInputEnvelope
    set?: ApartmentBedWhereUniqueInput | ApartmentBedWhereUniqueInput[]
    disconnect?: ApartmentBedWhereUniqueInput | ApartmentBedWhereUniqueInput[]
    delete?: ApartmentBedWhereUniqueInput | ApartmentBedWhereUniqueInput[]
    connect?: ApartmentBedWhereUniqueInput | ApartmentBedWhereUniqueInput[]
    update?: ApartmentBedUpdateWithWhereUniqueWithoutApartmentInput | ApartmentBedUpdateWithWhereUniqueWithoutApartmentInput[]
    updateMany?: ApartmentBedUpdateManyWithWhereWithoutApartmentInput | ApartmentBedUpdateManyWithWhereWithoutApartmentInput[]
    deleteMany?: ApartmentBedScalarWhereInput | ApartmentBedScalarWhereInput[]
  }

  export type ApartmentAmenityUpdateManyWithoutApartmentNestedInput = {
    create?: XOR<ApartmentAmenityCreateWithoutApartmentInput, ApartmentAmenityUncheckedCreateWithoutApartmentInput> | ApartmentAmenityCreateWithoutApartmentInput[] | ApartmentAmenityUncheckedCreateWithoutApartmentInput[]
    connectOrCreate?: ApartmentAmenityCreateOrConnectWithoutApartmentInput | ApartmentAmenityCreateOrConnectWithoutApartmentInput[]
    upsert?: ApartmentAmenityUpsertWithWhereUniqueWithoutApartmentInput | ApartmentAmenityUpsertWithWhereUniqueWithoutApartmentInput[]
    createMany?: ApartmentAmenityCreateManyApartmentInputEnvelope
    set?: ApartmentAmenityWhereUniqueInput | ApartmentAmenityWhereUniqueInput[]
    disconnect?: ApartmentAmenityWhereUniqueInput | ApartmentAmenityWhereUniqueInput[]
    delete?: ApartmentAmenityWhereUniqueInput | ApartmentAmenityWhereUniqueInput[]
    connect?: ApartmentAmenityWhereUniqueInput | ApartmentAmenityWhereUniqueInput[]
    update?: ApartmentAmenityUpdateWithWhereUniqueWithoutApartmentInput | ApartmentAmenityUpdateWithWhereUniqueWithoutApartmentInput[]
    updateMany?: ApartmentAmenityUpdateManyWithWhereWithoutApartmentInput | ApartmentAmenityUpdateManyWithWhereWithoutApartmentInput[]
    deleteMany?: ApartmentAmenityScalarWhereInput | ApartmentAmenityScalarWhereInput[]
  }

  export type ReservationUpdateManyWithoutApartmentNestedInput = {
    create?: XOR<ReservationCreateWithoutApartmentInput, ReservationUncheckedCreateWithoutApartmentInput> | ReservationCreateWithoutApartmentInput[] | ReservationUncheckedCreateWithoutApartmentInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutApartmentInput | ReservationCreateOrConnectWithoutApartmentInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutApartmentInput | ReservationUpsertWithWhereUniqueWithoutApartmentInput[]
    createMany?: ReservationCreateManyApartmentInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutApartmentInput | ReservationUpdateWithWhereUniqueWithoutApartmentInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutApartmentInput | ReservationUpdateManyWithWhereWithoutApartmentInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type BookingVariantUpdateManyWithoutApartmentNestedInput = {
    create?: XOR<BookingVariantCreateWithoutApartmentInput, BookingVariantUncheckedCreateWithoutApartmentInput> | BookingVariantCreateWithoutApartmentInput[] | BookingVariantUncheckedCreateWithoutApartmentInput[]
    connectOrCreate?: BookingVariantCreateOrConnectWithoutApartmentInput | BookingVariantCreateOrConnectWithoutApartmentInput[]
    upsert?: BookingVariantUpsertWithWhereUniqueWithoutApartmentInput | BookingVariantUpsertWithWhereUniqueWithoutApartmentInput[]
    createMany?: BookingVariantCreateManyApartmentInputEnvelope
    set?: BookingVariantWhereUniqueInput | BookingVariantWhereUniqueInput[]
    disconnect?: BookingVariantWhereUniqueInput | BookingVariantWhereUniqueInput[]
    delete?: BookingVariantWhereUniqueInput | BookingVariantWhereUniqueInput[]
    connect?: BookingVariantWhereUniqueInput | BookingVariantWhereUniqueInput[]
    update?: BookingVariantUpdateWithWhereUniqueWithoutApartmentInput | BookingVariantUpdateWithWhereUniqueWithoutApartmentInput[]
    updateMany?: BookingVariantUpdateManyWithWhereWithoutApartmentInput | BookingVariantUpdateManyWithWhereWithoutApartmentInput[]
    deleteMany?: BookingVariantScalarWhereInput | BookingVariantScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutApartmentNestedInput = {
    create?: XOR<ReviewCreateWithoutApartmentInput, ReviewUncheckedCreateWithoutApartmentInput> | ReviewCreateWithoutApartmentInput[] | ReviewUncheckedCreateWithoutApartmentInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutApartmentInput | ReviewCreateOrConnectWithoutApartmentInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutApartmentInput | ReviewUpsertWithWhereUniqueWithoutApartmentInput[]
    createMany?: ReviewCreateManyApartmentInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutApartmentInput | ReviewUpdateWithWhereUniqueWithoutApartmentInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutApartmentInput | ReviewUpdateManyWithWhereWithoutApartmentInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ApartmentImageUncheckedUpdateManyWithoutApartmentNestedInput = {
    create?: XOR<ApartmentImageCreateWithoutApartmentInput, ApartmentImageUncheckedCreateWithoutApartmentInput> | ApartmentImageCreateWithoutApartmentInput[] | ApartmentImageUncheckedCreateWithoutApartmentInput[]
    connectOrCreate?: ApartmentImageCreateOrConnectWithoutApartmentInput | ApartmentImageCreateOrConnectWithoutApartmentInput[]
    upsert?: ApartmentImageUpsertWithWhereUniqueWithoutApartmentInput | ApartmentImageUpsertWithWhereUniqueWithoutApartmentInput[]
    createMany?: ApartmentImageCreateManyApartmentInputEnvelope
    set?: ApartmentImageWhereUniqueInput | ApartmentImageWhereUniqueInput[]
    disconnect?: ApartmentImageWhereUniqueInput | ApartmentImageWhereUniqueInput[]
    delete?: ApartmentImageWhereUniqueInput | ApartmentImageWhereUniqueInput[]
    connect?: ApartmentImageWhereUniqueInput | ApartmentImageWhereUniqueInput[]
    update?: ApartmentImageUpdateWithWhereUniqueWithoutApartmentInput | ApartmentImageUpdateWithWhereUniqueWithoutApartmentInput[]
    updateMany?: ApartmentImageUpdateManyWithWhereWithoutApartmentInput | ApartmentImageUpdateManyWithWhereWithoutApartmentInput[]
    deleteMany?: ApartmentImageScalarWhereInput | ApartmentImageScalarWhereInput[]
  }

  export type ApartmentBedUncheckedUpdateManyWithoutApartmentNestedInput = {
    create?: XOR<ApartmentBedCreateWithoutApartmentInput, ApartmentBedUncheckedCreateWithoutApartmentInput> | ApartmentBedCreateWithoutApartmentInput[] | ApartmentBedUncheckedCreateWithoutApartmentInput[]
    connectOrCreate?: ApartmentBedCreateOrConnectWithoutApartmentInput | ApartmentBedCreateOrConnectWithoutApartmentInput[]
    upsert?: ApartmentBedUpsertWithWhereUniqueWithoutApartmentInput | ApartmentBedUpsertWithWhereUniqueWithoutApartmentInput[]
    createMany?: ApartmentBedCreateManyApartmentInputEnvelope
    set?: ApartmentBedWhereUniqueInput | ApartmentBedWhereUniqueInput[]
    disconnect?: ApartmentBedWhereUniqueInput | ApartmentBedWhereUniqueInput[]
    delete?: ApartmentBedWhereUniqueInput | ApartmentBedWhereUniqueInput[]
    connect?: ApartmentBedWhereUniqueInput | ApartmentBedWhereUniqueInput[]
    update?: ApartmentBedUpdateWithWhereUniqueWithoutApartmentInput | ApartmentBedUpdateWithWhereUniqueWithoutApartmentInput[]
    updateMany?: ApartmentBedUpdateManyWithWhereWithoutApartmentInput | ApartmentBedUpdateManyWithWhereWithoutApartmentInput[]
    deleteMany?: ApartmentBedScalarWhereInput | ApartmentBedScalarWhereInput[]
  }

  export type ApartmentAmenityUncheckedUpdateManyWithoutApartmentNestedInput = {
    create?: XOR<ApartmentAmenityCreateWithoutApartmentInput, ApartmentAmenityUncheckedCreateWithoutApartmentInput> | ApartmentAmenityCreateWithoutApartmentInput[] | ApartmentAmenityUncheckedCreateWithoutApartmentInput[]
    connectOrCreate?: ApartmentAmenityCreateOrConnectWithoutApartmentInput | ApartmentAmenityCreateOrConnectWithoutApartmentInput[]
    upsert?: ApartmentAmenityUpsertWithWhereUniqueWithoutApartmentInput | ApartmentAmenityUpsertWithWhereUniqueWithoutApartmentInput[]
    createMany?: ApartmentAmenityCreateManyApartmentInputEnvelope
    set?: ApartmentAmenityWhereUniqueInput | ApartmentAmenityWhereUniqueInput[]
    disconnect?: ApartmentAmenityWhereUniqueInput | ApartmentAmenityWhereUniqueInput[]
    delete?: ApartmentAmenityWhereUniqueInput | ApartmentAmenityWhereUniqueInput[]
    connect?: ApartmentAmenityWhereUniqueInput | ApartmentAmenityWhereUniqueInput[]
    update?: ApartmentAmenityUpdateWithWhereUniqueWithoutApartmentInput | ApartmentAmenityUpdateWithWhereUniqueWithoutApartmentInput[]
    updateMany?: ApartmentAmenityUpdateManyWithWhereWithoutApartmentInput | ApartmentAmenityUpdateManyWithWhereWithoutApartmentInput[]
    deleteMany?: ApartmentAmenityScalarWhereInput | ApartmentAmenityScalarWhereInput[]
  }

  export type ReservationUncheckedUpdateManyWithoutApartmentNestedInput = {
    create?: XOR<ReservationCreateWithoutApartmentInput, ReservationUncheckedCreateWithoutApartmentInput> | ReservationCreateWithoutApartmentInput[] | ReservationUncheckedCreateWithoutApartmentInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutApartmentInput | ReservationCreateOrConnectWithoutApartmentInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutApartmentInput | ReservationUpsertWithWhereUniqueWithoutApartmentInput[]
    createMany?: ReservationCreateManyApartmentInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutApartmentInput | ReservationUpdateWithWhereUniqueWithoutApartmentInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutApartmentInput | ReservationUpdateManyWithWhereWithoutApartmentInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type BookingVariantUncheckedUpdateManyWithoutApartmentNestedInput = {
    create?: XOR<BookingVariantCreateWithoutApartmentInput, BookingVariantUncheckedCreateWithoutApartmentInput> | BookingVariantCreateWithoutApartmentInput[] | BookingVariantUncheckedCreateWithoutApartmentInput[]
    connectOrCreate?: BookingVariantCreateOrConnectWithoutApartmentInput | BookingVariantCreateOrConnectWithoutApartmentInput[]
    upsert?: BookingVariantUpsertWithWhereUniqueWithoutApartmentInput | BookingVariantUpsertWithWhereUniqueWithoutApartmentInput[]
    createMany?: BookingVariantCreateManyApartmentInputEnvelope
    set?: BookingVariantWhereUniqueInput | BookingVariantWhereUniqueInput[]
    disconnect?: BookingVariantWhereUniqueInput | BookingVariantWhereUniqueInput[]
    delete?: BookingVariantWhereUniqueInput | BookingVariantWhereUniqueInput[]
    connect?: BookingVariantWhereUniqueInput | BookingVariantWhereUniqueInput[]
    update?: BookingVariantUpdateWithWhereUniqueWithoutApartmentInput | BookingVariantUpdateWithWhereUniqueWithoutApartmentInput[]
    updateMany?: BookingVariantUpdateManyWithWhereWithoutApartmentInput | BookingVariantUpdateManyWithWhereWithoutApartmentInput[]
    deleteMany?: BookingVariantScalarWhereInput | BookingVariantScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutApartmentNestedInput = {
    create?: XOR<ReviewCreateWithoutApartmentInput, ReviewUncheckedCreateWithoutApartmentInput> | ReviewCreateWithoutApartmentInput[] | ReviewUncheckedCreateWithoutApartmentInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutApartmentInput | ReviewCreateOrConnectWithoutApartmentInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutApartmentInput | ReviewUpsertWithWhereUniqueWithoutApartmentInput[]
    createMany?: ReviewCreateManyApartmentInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutApartmentInput | ReviewUpdateWithWhereUniqueWithoutApartmentInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutApartmentInput | ReviewUpdateManyWithWhereWithoutApartmentInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutReviewsInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type ApartmentCreateNestedOneWithoutReviewsInput = {
    create?: XOR<ApartmentCreateWithoutReviewsInput, ApartmentUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ApartmentCreateOrConnectWithoutReviewsInput
    connect?: ApartmentWhereUniqueInput
  }

  export type BookingCreateNestedOneWithoutReviewsInput = {
    create?: XOR<BookingCreateWithoutReviewsInput, BookingUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutReviewsInput
    connect?: BookingWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    upsert?: UserUpsertWithoutReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewsInput, UserUpdateWithoutReviewsInput>, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type ApartmentUpdateOneWithoutReviewsNestedInput = {
    create?: XOR<ApartmentCreateWithoutReviewsInput, ApartmentUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ApartmentCreateOrConnectWithoutReviewsInput
    upsert?: ApartmentUpsertWithoutReviewsInput
    disconnect?: ApartmentWhereInput | boolean
    delete?: ApartmentWhereInput | boolean
    connect?: ApartmentWhereUniqueInput
    update?: XOR<XOR<ApartmentUpdateToOneWithWhereWithoutReviewsInput, ApartmentUpdateWithoutReviewsInput>, ApartmentUncheckedUpdateWithoutReviewsInput>
  }

  export type BookingUpdateOneWithoutReviewsNestedInput = {
    create?: XOR<BookingCreateWithoutReviewsInput, BookingUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutReviewsInput
    upsert?: BookingUpsertWithoutReviewsInput
    disconnect?: BookingWhereInput | boolean
    delete?: BookingWhereInput | boolean
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutReviewsInput, BookingUpdateWithoutReviewsInput>, BookingUncheckedUpdateWithoutReviewsInput>
  }

  export type ApartmentAmenityCreateNestedManyWithoutAmenityInput = {
    create?: XOR<ApartmentAmenityCreateWithoutAmenityInput, ApartmentAmenityUncheckedCreateWithoutAmenityInput> | ApartmentAmenityCreateWithoutAmenityInput[] | ApartmentAmenityUncheckedCreateWithoutAmenityInput[]
    connectOrCreate?: ApartmentAmenityCreateOrConnectWithoutAmenityInput | ApartmentAmenityCreateOrConnectWithoutAmenityInput[]
    createMany?: ApartmentAmenityCreateManyAmenityInputEnvelope
    connect?: ApartmentAmenityWhereUniqueInput | ApartmentAmenityWhereUniqueInput[]
  }

  export type ApartmentAmenityUncheckedCreateNestedManyWithoutAmenityInput = {
    create?: XOR<ApartmentAmenityCreateWithoutAmenityInput, ApartmentAmenityUncheckedCreateWithoutAmenityInput> | ApartmentAmenityCreateWithoutAmenityInput[] | ApartmentAmenityUncheckedCreateWithoutAmenityInput[]
    connectOrCreate?: ApartmentAmenityCreateOrConnectWithoutAmenityInput | ApartmentAmenityCreateOrConnectWithoutAmenityInput[]
    createMany?: ApartmentAmenityCreateManyAmenityInputEnvelope
    connect?: ApartmentAmenityWhereUniqueInput | ApartmentAmenityWhereUniqueInput[]
  }

  export type ApartmentAmenityUpdateManyWithoutAmenityNestedInput = {
    create?: XOR<ApartmentAmenityCreateWithoutAmenityInput, ApartmentAmenityUncheckedCreateWithoutAmenityInput> | ApartmentAmenityCreateWithoutAmenityInput[] | ApartmentAmenityUncheckedCreateWithoutAmenityInput[]
    connectOrCreate?: ApartmentAmenityCreateOrConnectWithoutAmenityInput | ApartmentAmenityCreateOrConnectWithoutAmenityInput[]
    upsert?: ApartmentAmenityUpsertWithWhereUniqueWithoutAmenityInput | ApartmentAmenityUpsertWithWhereUniqueWithoutAmenityInput[]
    createMany?: ApartmentAmenityCreateManyAmenityInputEnvelope
    set?: ApartmentAmenityWhereUniqueInput | ApartmentAmenityWhereUniqueInput[]
    disconnect?: ApartmentAmenityWhereUniqueInput | ApartmentAmenityWhereUniqueInput[]
    delete?: ApartmentAmenityWhereUniqueInput | ApartmentAmenityWhereUniqueInput[]
    connect?: ApartmentAmenityWhereUniqueInput | ApartmentAmenityWhereUniqueInput[]
    update?: ApartmentAmenityUpdateWithWhereUniqueWithoutAmenityInput | ApartmentAmenityUpdateWithWhereUniqueWithoutAmenityInput[]
    updateMany?: ApartmentAmenityUpdateManyWithWhereWithoutAmenityInput | ApartmentAmenityUpdateManyWithWhereWithoutAmenityInput[]
    deleteMany?: ApartmentAmenityScalarWhereInput | ApartmentAmenityScalarWhereInput[]
  }

  export type ApartmentAmenityUncheckedUpdateManyWithoutAmenityNestedInput = {
    create?: XOR<ApartmentAmenityCreateWithoutAmenityInput, ApartmentAmenityUncheckedCreateWithoutAmenityInput> | ApartmentAmenityCreateWithoutAmenityInput[] | ApartmentAmenityUncheckedCreateWithoutAmenityInput[]
    connectOrCreate?: ApartmentAmenityCreateOrConnectWithoutAmenityInput | ApartmentAmenityCreateOrConnectWithoutAmenityInput[]
    upsert?: ApartmentAmenityUpsertWithWhereUniqueWithoutAmenityInput | ApartmentAmenityUpsertWithWhereUniqueWithoutAmenityInput[]
    createMany?: ApartmentAmenityCreateManyAmenityInputEnvelope
    set?: ApartmentAmenityWhereUniqueInput | ApartmentAmenityWhereUniqueInput[]
    disconnect?: ApartmentAmenityWhereUniqueInput | ApartmentAmenityWhereUniqueInput[]
    delete?: ApartmentAmenityWhereUniqueInput | ApartmentAmenityWhereUniqueInput[]
    connect?: ApartmentAmenityWhereUniqueInput | ApartmentAmenityWhereUniqueInput[]
    update?: ApartmentAmenityUpdateWithWhereUniqueWithoutAmenityInput | ApartmentAmenityUpdateWithWhereUniqueWithoutAmenityInput[]
    updateMany?: ApartmentAmenityUpdateManyWithWhereWithoutAmenityInput | ApartmentAmenityUpdateManyWithWhereWithoutAmenityInput[]
    deleteMany?: ApartmentAmenityScalarWhereInput | ApartmentAmenityScalarWhereInput[]
  }

  export type ApartmentCreateNestedOneWithoutApartment_amenitiesInput = {
    create?: XOR<ApartmentCreateWithoutApartment_amenitiesInput, ApartmentUncheckedCreateWithoutApartment_amenitiesInput>
    connectOrCreate?: ApartmentCreateOrConnectWithoutApartment_amenitiesInput
    connect?: ApartmentWhereUniqueInput
  }

  export type AmenityCreateNestedOneWithoutApartment_amenitiesInput = {
    create?: XOR<AmenityCreateWithoutApartment_amenitiesInput, AmenityUncheckedCreateWithoutApartment_amenitiesInput>
    connectOrCreate?: AmenityCreateOrConnectWithoutApartment_amenitiesInput
    connect?: AmenityWhereUniqueInput
  }

  export type ApartmentUpdateOneRequiredWithoutApartment_amenitiesNestedInput = {
    create?: XOR<ApartmentCreateWithoutApartment_amenitiesInput, ApartmentUncheckedCreateWithoutApartment_amenitiesInput>
    connectOrCreate?: ApartmentCreateOrConnectWithoutApartment_amenitiesInput
    upsert?: ApartmentUpsertWithoutApartment_amenitiesInput
    connect?: ApartmentWhereUniqueInput
    update?: XOR<XOR<ApartmentUpdateToOneWithWhereWithoutApartment_amenitiesInput, ApartmentUpdateWithoutApartment_amenitiesInput>, ApartmentUncheckedUpdateWithoutApartment_amenitiesInput>
  }

  export type AmenityUpdateOneRequiredWithoutApartment_amenitiesNestedInput = {
    create?: XOR<AmenityCreateWithoutApartment_amenitiesInput, AmenityUncheckedCreateWithoutApartment_amenitiesInput>
    connectOrCreate?: AmenityCreateOrConnectWithoutApartment_amenitiesInput
    upsert?: AmenityUpsertWithoutApartment_amenitiesInput
    connect?: AmenityWhereUniqueInput
    update?: XOR<XOR<AmenityUpdateToOneWithWhereWithoutApartment_amenitiesInput, AmenityUpdateWithoutApartment_amenitiesInput>, AmenityUncheckedUpdateWithoutApartment_amenitiesInput>
  }

  export type ApartmentCreateNestedOneWithoutImagesInput = {
    create?: XOR<ApartmentCreateWithoutImagesInput, ApartmentUncheckedCreateWithoutImagesInput>
    connectOrCreate?: ApartmentCreateOrConnectWithoutImagesInput
    connect?: ApartmentWhereUniqueInput
  }

  export type ApartmentUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<ApartmentCreateWithoutImagesInput, ApartmentUncheckedCreateWithoutImagesInput>
    connectOrCreate?: ApartmentCreateOrConnectWithoutImagesInput
    upsert?: ApartmentUpsertWithoutImagesInput
    connect?: ApartmentWhereUniqueInput
    update?: XOR<XOR<ApartmentUpdateToOneWithWhereWithoutImagesInput, ApartmentUpdateWithoutImagesInput>, ApartmentUncheckedUpdateWithoutImagesInput>
  }

  export type ApartmentBedCreateNestedManyWithoutBed_typeInput = {
    create?: XOR<ApartmentBedCreateWithoutBed_typeInput, ApartmentBedUncheckedCreateWithoutBed_typeInput> | ApartmentBedCreateWithoutBed_typeInput[] | ApartmentBedUncheckedCreateWithoutBed_typeInput[]
    connectOrCreate?: ApartmentBedCreateOrConnectWithoutBed_typeInput | ApartmentBedCreateOrConnectWithoutBed_typeInput[]
    createMany?: ApartmentBedCreateManyBed_typeInputEnvelope
    connect?: ApartmentBedWhereUniqueInput | ApartmentBedWhereUniqueInput[]
  }

  export type ApartmentBedUncheckedCreateNestedManyWithoutBed_typeInput = {
    create?: XOR<ApartmentBedCreateWithoutBed_typeInput, ApartmentBedUncheckedCreateWithoutBed_typeInput> | ApartmentBedCreateWithoutBed_typeInput[] | ApartmentBedUncheckedCreateWithoutBed_typeInput[]
    connectOrCreate?: ApartmentBedCreateOrConnectWithoutBed_typeInput | ApartmentBedCreateOrConnectWithoutBed_typeInput[]
    createMany?: ApartmentBedCreateManyBed_typeInputEnvelope
    connect?: ApartmentBedWhereUniqueInput | ApartmentBedWhereUniqueInput[]
  }

  export type ApartmentBedUpdateManyWithoutBed_typeNestedInput = {
    create?: XOR<ApartmentBedCreateWithoutBed_typeInput, ApartmentBedUncheckedCreateWithoutBed_typeInput> | ApartmentBedCreateWithoutBed_typeInput[] | ApartmentBedUncheckedCreateWithoutBed_typeInput[]
    connectOrCreate?: ApartmentBedCreateOrConnectWithoutBed_typeInput | ApartmentBedCreateOrConnectWithoutBed_typeInput[]
    upsert?: ApartmentBedUpsertWithWhereUniqueWithoutBed_typeInput | ApartmentBedUpsertWithWhereUniqueWithoutBed_typeInput[]
    createMany?: ApartmentBedCreateManyBed_typeInputEnvelope
    set?: ApartmentBedWhereUniqueInput | ApartmentBedWhereUniqueInput[]
    disconnect?: ApartmentBedWhereUniqueInput | ApartmentBedWhereUniqueInput[]
    delete?: ApartmentBedWhereUniqueInput | ApartmentBedWhereUniqueInput[]
    connect?: ApartmentBedWhereUniqueInput | ApartmentBedWhereUniqueInput[]
    update?: ApartmentBedUpdateWithWhereUniqueWithoutBed_typeInput | ApartmentBedUpdateWithWhereUniqueWithoutBed_typeInput[]
    updateMany?: ApartmentBedUpdateManyWithWhereWithoutBed_typeInput | ApartmentBedUpdateManyWithWhereWithoutBed_typeInput[]
    deleteMany?: ApartmentBedScalarWhereInput | ApartmentBedScalarWhereInput[]
  }

  export type ApartmentBedUncheckedUpdateManyWithoutBed_typeNestedInput = {
    create?: XOR<ApartmentBedCreateWithoutBed_typeInput, ApartmentBedUncheckedCreateWithoutBed_typeInput> | ApartmentBedCreateWithoutBed_typeInput[] | ApartmentBedUncheckedCreateWithoutBed_typeInput[]
    connectOrCreate?: ApartmentBedCreateOrConnectWithoutBed_typeInput | ApartmentBedCreateOrConnectWithoutBed_typeInput[]
    upsert?: ApartmentBedUpsertWithWhereUniqueWithoutBed_typeInput | ApartmentBedUpsertWithWhereUniqueWithoutBed_typeInput[]
    createMany?: ApartmentBedCreateManyBed_typeInputEnvelope
    set?: ApartmentBedWhereUniqueInput | ApartmentBedWhereUniqueInput[]
    disconnect?: ApartmentBedWhereUniqueInput | ApartmentBedWhereUniqueInput[]
    delete?: ApartmentBedWhereUniqueInput | ApartmentBedWhereUniqueInput[]
    connect?: ApartmentBedWhereUniqueInput | ApartmentBedWhereUniqueInput[]
    update?: ApartmentBedUpdateWithWhereUniqueWithoutBed_typeInput | ApartmentBedUpdateWithWhereUniqueWithoutBed_typeInput[]
    updateMany?: ApartmentBedUpdateManyWithWhereWithoutBed_typeInput | ApartmentBedUpdateManyWithWhereWithoutBed_typeInput[]
    deleteMany?: ApartmentBedScalarWhereInput | ApartmentBedScalarWhereInput[]
  }

  export type ApartmentCreateNestedOneWithoutApartment_bedsInput = {
    create?: XOR<ApartmentCreateWithoutApartment_bedsInput, ApartmentUncheckedCreateWithoutApartment_bedsInput>
    connectOrCreate?: ApartmentCreateOrConnectWithoutApartment_bedsInput
    connect?: ApartmentWhereUniqueInput
  }

  export type BedTypeCreateNestedOneWithoutApartment_bedsInput = {
    create?: XOR<BedTypeCreateWithoutApartment_bedsInput, BedTypeUncheckedCreateWithoutApartment_bedsInput>
    connectOrCreate?: BedTypeCreateOrConnectWithoutApartment_bedsInput
    connect?: BedTypeWhereUniqueInput
  }

  export type ApartmentUpdateOneRequiredWithoutApartment_bedsNestedInput = {
    create?: XOR<ApartmentCreateWithoutApartment_bedsInput, ApartmentUncheckedCreateWithoutApartment_bedsInput>
    connectOrCreate?: ApartmentCreateOrConnectWithoutApartment_bedsInput
    upsert?: ApartmentUpsertWithoutApartment_bedsInput
    connect?: ApartmentWhereUniqueInput
    update?: XOR<XOR<ApartmentUpdateToOneWithWhereWithoutApartment_bedsInput, ApartmentUpdateWithoutApartment_bedsInput>, ApartmentUncheckedUpdateWithoutApartment_bedsInput>
  }

  export type BedTypeUpdateOneRequiredWithoutApartment_bedsNestedInput = {
    create?: XOR<BedTypeCreateWithoutApartment_bedsInput, BedTypeUncheckedCreateWithoutApartment_bedsInput>
    connectOrCreate?: BedTypeCreateOrConnectWithoutApartment_bedsInput
    upsert?: BedTypeUpsertWithoutApartment_bedsInput
    connect?: BedTypeWhereUniqueInput
    update?: XOR<XOR<BedTypeUpdateToOneWithWhereWithoutApartment_bedsInput, BedTypeUpdateWithoutApartment_bedsInput>, BedTypeUncheckedUpdateWithoutApartment_bedsInput>
  }

  export type ApartmentCreateNestedOneWithoutBooking_variantsInput = {
    create?: XOR<ApartmentCreateWithoutBooking_variantsInput, ApartmentUncheckedCreateWithoutBooking_variantsInput>
    connectOrCreate?: ApartmentCreateOrConnectWithoutBooking_variantsInput
    connect?: ApartmentWhereUniqueInput
  }

  export type BookingCreateNestedManyWithoutBooking_variantInput = {
    create?: XOR<BookingCreateWithoutBooking_variantInput, BookingUncheckedCreateWithoutBooking_variantInput> | BookingCreateWithoutBooking_variantInput[] | BookingUncheckedCreateWithoutBooking_variantInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutBooking_variantInput | BookingCreateOrConnectWithoutBooking_variantInput[]
    createMany?: BookingCreateManyBooking_variantInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutBooking_variantInput = {
    create?: XOR<BookingCreateWithoutBooking_variantInput, BookingUncheckedCreateWithoutBooking_variantInput> | BookingCreateWithoutBooking_variantInput[] | BookingUncheckedCreateWithoutBooking_variantInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutBooking_variantInput | BookingCreateOrConnectWithoutBooking_variantInput[]
    createMany?: BookingCreateManyBooking_variantInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ApartmentUpdateOneRequiredWithoutBooking_variantsNestedInput = {
    create?: XOR<ApartmentCreateWithoutBooking_variantsInput, ApartmentUncheckedCreateWithoutBooking_variantsInput>
    connectOrCreate?: ApartmentCreateOrConnectWithoutBooking_variantsInput
    upsert?: ApartmentUpsertWithoutBooking_variantsInput
    connect?: ApartmentWhereUniqueInput
    update?: XOR<XOR<ApartmentUpdateToOneWithWhereWithoutBooking_variantsInput, ApartmentUpdateWithoutBooking_variantsInput>, ApartmentUncheckedUpdateWithoutBooking_variantsInput>
  }

  export type BookingUpdateManyWithoutBooking_variantNestedInput = {
    create?: XOR<BookingCreateWithoutBooking_variantInput, BookingUncheckedCreateWithoutBooking_variantInput> | BookingCreateWithoutBooking_variantInput[] | BookingUncheckedCreateWithoutBooking_variantInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutBooking_variantInput | BookingCreateOrConnectWithoutBooking_variantInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutBooking_variantInput | BookingUpsertWithWhereUniqueWithoutBooking_variantInput[]
    createMany?: BookingCreateManyBooking_variantInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutBooking_variantInput | BookingUpdateWithWhereUniqueWithoutBooking_variantInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutBooking_variantInput | BookingUpdateManyWithWhereWithoutBooking_variantInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutBooking_variantNestedInput = {
    create?: XOR<BookingCreateWithoutBooking_variantInput, BookingUncheckedCreateWithoutBooking_variantInput> | BookingCreateWithoutBooking_variantInput[] | BookingUncheckedCreateWithoutBooking_variantInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutBooking_variantInput | BookingCreateOrConnectWithoutBooking_variantInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutBooking_variantInput | BookingUpsertWithWhereUniqueWithoutBooking_variantInput[]
    createMany?: BookingCreateManyBooking_variantInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutBooking_variantInput | BookingUpdateWithWhereUniqueWithoutBooking_variantInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutBooking_variantInput | BookingUpdateManyWithWhereWithoutBooking_variantInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ApartmentCreateNestedOneWithoutReservationsInput = {
    create?: XOR<ApartmentCreateWithoutReservationsInput, ApartmentUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: ApartmentCreateOrConnectWithoutReservationsInput
    connect?: ApartmentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReservationsInput = {
    create?: XOR<UserCreateWithoutReservationsInput, UserUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReservationsInput
    connect?: UserWhereUniqueInput
  }

  export type ApartmentUpdateOneRequiredWithoutReservationsNestedInput = {
    create?: XOR<ApartmentCreateWithoutReservationsInput, ApartmentUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: ApartmentCreateOrConnectWithoutReservationsInput
    upsert?: ApartmentUpsertWithoutReservationsInput
    connect?: ApartmentWhereUniqueInput
    update?: XOR<XOR<ApartmentUpdateToOneWithWhereWithoutReservationsInput, ApartmentUpdateWithoutReservationsInput>, ApartmentUncheckedUpdateWithoutReservationsInput>
  }

  export type UserUpdateOneRequiredWithoutReservationsNestedInput = {
    create?: XOR<UserCreateWithoutReservationsInput, UserUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReservationsInput
    upsert?: UserUpsertWithoutReservationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReservationsInput, UserUpdateWithoutReservationsInput>, UserUncheckedUpdateWithoutReservationsInput>
  }

  export type BookingVariantCreateNestedOneWithoutBookingsInput = {
    create?: XOR<BookingVariantCreateWithoutBookingsInput, BookingVariantUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: BookingVariantCreateOrConnectWithoutBookingsInput
    connect?: BookingVariantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBookingsInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    connect?: UserWhereUniqueInput
  }

  export type TransactionCreateNestedOneWithoutBookingInput = {
    create?: XOR<TransactionCreateWithoutBookingInput, TransactionUncheckedCreateWithoutBookingInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutBookingInput
    connect?: TransactionWhereUniqueInput
  }

  export type BookingEventCreateNestedManyWithoutBookingInput = {
    create?: XOR<BookingEventCreateWithoutBookingInput, BookingEventUncheckedCreateWithoutBookingInput> | BookingEventCreateWithoutBookingInput[] | BookingEventUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingEventCreateOrConnectWithoutBookingInput | BookingEventCreateOrConnectWithoutBookingInput[]
    createMany?: BookingEventCreateManyBookingInputEnvelope
    connect?: BookingEventWhereUniqueInput | BookingEventWhereUniqueInput[]
  }

  export type BookingAdditionalOptionCreateNestedManyWithoutBookingInput = {
    create?: XOR<BookingAdditionalOptionCreateWithoutBookingInput, BookingAdditionalOptionUncheckedCreateWithoutBookingInput> | BookingAdditionalOptionCreateWithoutBookingInput[] | BookingAdditionalOptionUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingAdditionalOptionCreateOrConnectWithoutBookingInput | BookingAdditionalOptionCreateOrConnectWithoutBookingInput[]
    createMany?: BookingAdditionalOptionCreateManyBookingInputEnvelope
    connect?: BookingAdditionalOptionWhereUniqueInput | BookingAdditionalOptionWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutBookingInput = {
    create?: XOR<ReviewCreateWithoutBookingInput, ReviewUncheckedCreateWithoutBookingInput> | ReviewCreateWithoutBookingInput[] | ReviewUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutBookingInput | ReviewCreateOrConnectWithoutBookingInput[]
    createMany?: ReviewCreateManyBookingInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutBookingInput = {
    create?: XOR<MessageCreateWithoutBookingInput, MessageUncheckedCreateWithoutBookingInput> | MessageCreateWithoutBookingInput[] | MessageUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutBookingInput | MessageCreateOrConnectWithoutBookingInput[]
    createMany?: MessageCreateManyBookingInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type BookingEventUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<BookingEventCreateWithoutBookingInput, BookingEventUncheckedCreateWithoutBookingInput> | BookingEventCreateWithoutBookingInput[] | BookingEventUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingEventCreateOrConnectWithoutBookingInput | BookingEventCreateOrConnectWithoutBookingInput[]
    createMany?: BookingEventCreateManyBookingInputEnvelope
    connect?: BookingEventWhereUniqueInput | BookingEventWhereUniqueInput[]
  }

  export type BookingAdditionalOptionUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<BookingAdditionalOptionCreateWithoutBookingInput, BookingAdditionalOptionUncheckedCreateWithoutBookingInput> | BookingAdditionalOptionCreateWithoutBookingInput[] | BookingAdditionalOptionUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingAdditionalOptionCreateOrConnectWithoutBookingInput | BookingAdditionalOptionCreateOrConnectWithoutBookingInput[]
    createMany?: BookingAdditionalOptionCreateManyBookingInputEnvelope
    connect?: BookingAdditionalOptionWhereUniqueInput | BookingAdditionalOptionWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<ReviewCreateWithoutBookingInput, ReviewUncheckedCreateWithoutBookingInput> | ReviewCreateWithoutBookingInput[] | ReviewUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutBookingInput | ReviewCreateOrConnectWithoutBookingInput[]
    createMany?: ReviewCreateManyBookingInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<MessageCreateWithoutBookingInput, MessageUncheckedCreateWithoutBookingInput> | MessageCreateWithoutBookingInput[] | MessageUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutBookingInput | MessageCreateOrConnectWithoutBookingInput[]
    createMany?: MessageCreateManyBookingInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type EnumBookingStatusFieldUpdateOperationsInput = {
    set?: $Enums.BookingStatus
  }

  export type BookingVariantUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<BookingVariantCreateWithoutBookingsInput, BookingVariantUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: BookingVariantCreateOrConnectWithoutBookingsInput
    upsert?: BookingVariantUpsertWithoutBookingsInput
    connect?: BookingVariantWhereUniqueInput
    update?: XOR<XOR<BookingVariantUpdateToOneWithWhereWithoutBookingsInput, BookingVariantUpdateWithoutBookingsInput>, BookingVariantUncheckedUpdateWithoutBookingsInput>
  }

  export type UserUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    upsert?: UserUpsertWithoutBookingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBookingsInput, UserUpdateWithoutBookingsInput>, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type TransactionUpdateOneRequiredWithoutBookingNestedInput = {
    create?: XOR<TransactionCreateWithoutBookingInput, TransactionUncheckedCreateWithoutBookingInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutBookingInput
    upsert?: TransactionUpsertWithoutBookingInput
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutBookingInput, TransactionUpdateWithoutBookingInput>, TransactionUncheckedUpdateWithoutBookingInput>
  }

  export type BookingEventUpdateManyWithoutBookingNestedInput = {
    create?: XOR<BookingEventCreateWithoutBookingInput, BookingEventUncheckedCreateWithoutBookingInput> | BookingEventCreateWithoutBookingInput[] | BookingEventUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingEventCreateOrConnectWithoutBookingInput | BookingEventCreateOrConnectWithoutBookingInput[]
    upsert?: BookingEventUpsertWithWhereUniqueWithoutBookingInput | BookingEventUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: BookingEventCreateManyBookingInputEnvelope
    set?: BookingEventWhereUniqueInput | BookingEventWhereUniqueInput[]
    disconnect?: BookingEventWhereUniqueInput | BookingEventWhereUniqueInput[]
    delete?: BookingEventWhereUniqueInput | BookingEventWhereUniqueInput[]
    connect?: BookingEventWhereUniqueInput | BookingEventWhereUniqueInput[]
    update?: BookingEventUpdateWithWhereUniqueWithoutBookingInput | BookingEventUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: BookingEventUpdateManyWithWhereWithoutBookingInput | BookingEventUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: BookingEventScalarWhereInput | BookingEventScalarWhereInput[]
  }

  export type BookingAdditionalOptionUpdateManyWithoutBookingNestedInput = {
    create?: XOR<BookingAdditionalOptionCreateWithoutBookingInput, BookingAdditionalOptionUncheckedCreateWithoutBookingInput> | BookingAdditionalOptionCreateWithoutBookingInput[] | BookingAdditionalOptionUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingAdditionalOptionCreateOrConnectWithoutBookingInput | BookingAdditionalOptionCreateOrConnectWithoutBookingInput[]
    upsert?: BookingAdditionalOptionUpsertWithWhereUniqueWithoutBookingInput | BookingAdditionalOptionUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: BookingAdditionalOptionCreateManyBookingInputEnvelope
    set?: BookingAdditionalOptionWhereUniqueInput | BookingAdditionalOptionWhereUniqueInput[]
    disconnect?: BookingAdditionalOptionWhereUniqueInput | BookingAdditionalOptionWhereUniqueInput[]
    delete?: BookingAdditionalOptionWhereUniqueInput | BookingAdditionalOptionWhereUniqueInput[]
    connect?: BookingAdditionalOptionWhereUniqueInput | BookingAdditionalOptionWhereUniqueInput[]
    update?: BookingAdditionalOptionUpdateWithWhereUniqueWithoutBookingInput | BookingAdditionalOptionUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: BookingAdditionalOptionUpdateManyWithWhereWithoutBookingInput | BookingAdditionalOptionUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: BookingAdditionalOptionScalarWhereInput | BookingAdditionalOptionScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutBookingNestedInput = {
    create?: XOR<ReviewCreateWithoutBookingInput, ReviewUncheckedCreateWithoutBookingInput> | ReviewCreateWithoutBookingInput[] | ReviewUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutBookingInput | ReviewCreateOrConnectWithoutBookingInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutBookingInput | ReviewUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: ReviewCreateManyBookingInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutBookingInput | ReviewUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutBookingInput | ReviewUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutBookingNestedInput = {
    create?: XOR<MessageCreateWithoutBookingInput, MessageUncheckedCreateWithoutBookingInput> | MessageCreateWithoutBookingInput[] | MessageUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutBookingInput | MessageCreateOrConnectWithoutBookingInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutBookingInput | MessageUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: MessageCreateManyBookingInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutBookingInput | MessageUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutBookingInput | MessageUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type BookingEventUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<BookingEventCreateWithoutBookingInput, BookingEventUncheckedCreateWithoutBookingInput> | BookingEventCreateWithoutBookingInput[] | BookingEventUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingEventCreateOrConnectWithoutBookingInput | BookingEventCreateOrConnectWithoutBookingInput[]
    upsert?: BookingEventUpsertWithWhereUniqueWithoutBookingInput | BookingEventUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: BookingEventCreateManyBookingInputEnvelope
    set?: BookingEventWhereUniqueInput | BookingEventWhereUniqueInput[]
    disconnect?: BookingEventWhereUniqueInput | BookingEventWhereUniqueInput[]
    delete?: BookingEventWhereUniqueInput | BookingEventWhereUniqueInput[]
    connect?: BookingEventWhereUniqueInput | BookingEventWhereUniqueInput[]
    update?: BookingEventUpdateWithWhereUniqueWithoutBookingInput | BookingEventUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: BookingEventUpdateManyWithWhereWithoutBookingInput | BookingEventUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: BookingEventScalarWhereInput | BookingEventScalarWhereInput[]
  }

  export type BookingAdditionalOptionUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<BookingAdditionalOptionCreateWithoutBookingInput, BookingAdditionalOptionUncheckedCreateWithoutBookingInput> | BookingAdditionalOptionCreateWithoutBookingInput[] | BookingAdditionalOptionUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingAdditionalOptionCreateOrConnectWithoutBookingInput | BookingAdditionalOptionCreateOrConnectWithoutBookingInput[]
    upsert?: BookingAdditionalOptionUpsertWithWhereUniqueWithoutBookingInput | BookingAdditionalOptionUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: BookingAdditionalOptionCreateManyBookingInputEnvelope
    set?: BookingAdditionalOptionWhereUniqueInput | BookingAdditionalOptionWhereUniqueInput[]
    disconnect?: BookingAdditionalOptionWhereUniqueInput | BookingAdditionalOptionWhereUniqueInput[]
    delete?: BookingAdditionalOptionWhereUniqueInput | BookingAdditionalOptionWhereUniqueInput[]
    connect?: BookingAdditionalOptionWhereUniqueInput | BookingAdditionalOptionWhereUniqueInput[]
    update?: BookingAdditionalOptionUpdateWithWhereUniqueWithoutBookingInput | BookingAdditionalOptionUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: BookingAdditionalOptionUpdateManyWithWhereWithoutBookingInput | BookingAdditionalOptionUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: BookingAdditionalOptionScalarWhereInput | BookingAdditionalOptionScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<ReviewCreateWithoutBookingInput, ReviewUncheckedCreateWithoutBookingInput> | ReviewCreateWithoutBookingInput[] | ReviewUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutBookingInput | ReviewCreateOrConnectWithoutBookingInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutBookingInput | ReviewUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: ReviewCreateManyBookingInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutBookingInput | ReviewUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutBookingInput | ReviewUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<MessageCreateWithoutBookingInput, MessageUncheckedCreateWithoutBookingInput> | MessageCreateWithoutBookingInput[] | MessageUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutBookingInput | MessageCreateOrConnectWithoutBookingInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutBookingInput | MessageUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: MessageCreateManyBookingInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutBookingInput | MessageUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutBookingInput | MessageUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type BookingAdditionalOptionCreateNestedManyWithoutAdditional_optionInput = {
    create?: XOR<BookingAdditionalOptionCreateWithoutAdditional_optionInput, BookingAdditionalOptionUncheckedCreateWithoutAdditional_optionInput> | BookingAdditionalOptionCreateWithoutAdditional_optionInput[] | BookingAdditionalOptionUncheckedCreateWithoutAdditional_optionInput[]
    connectOrCreate?: BookingAdditionalOptionCreateOrConnectWithoutAdditional_optionInput | BookingAdditionalOptionCreateOrConnectWithoutAdditional_optionInput[]
    createMany?: BookingAdditionalOptionCreateManyAdditional_optionInputEnvelope
    connect?: BookingAdditionalOptionWhereUniqueInput | BookingAdditionalOptionWhereUniqueInput[]
  }

  export type BookingAdditionalOptionUncheckedCreateNestedManyWithoutAdditional_optionInput = {
    create?: XOR<BookingAdditionalOptionCreateWithoutAdditional_optionInput, BookingAdditionalOptionUncheckedCreateWithoutAdditional_optionInput> | BookingAdditionalOptionCreateWithoutAdditional_optionInput[] | BookingAdditionalOptionUncheckedCreateWithoutAdditional_optionInput[]
    connectOrCreate?: BookingAdditionalOptionCreateOrConnectWithoutAdditional_optionInput | BookingAdditionalOptionCreateOrConnectWithoutAdditional_optionInput[]
    createMany?: BookingAdditionalOptionCreateManyAdditional_optionInputEnvelope
    connect?: BookingAdditionalOptionWhereUniqueInput | BookingAdditionalOptionWhereUniqueInput[]
  }

  export type BookingAdditionalOptionUpdateManyWithoutAdditional_optionNestedInput = {
    create?: XOR<BookingAdditionalOptionCreateWithoutAdditional_optionInput, BookingAdditionalOptionUncheckedCreateWithoutAdditional_optionInput> | BookingAdditionalOptionCreateWithoutAdditional_optionInput[] | BookingAdditionalOptionUncheckedCreateWithoutAdditional_optionInput[]
    connectOrCreate?: BookingAdditionalOptionCreateOrConnectWithoutAdditional_optionInput | BookingAdditionalOptionCreateOrConnectWithoutAdditional_optionInput[]
    upsert?: BookingAdditionalOptionUpsertWithWhereUniqueWithoutAdditional_optionInput | BookingAdditionalOptionUpsertWithWhereUniqueWithoutAdditional_optionInput[]
    createMany?: BookingAdditionalOptionCreateManyAdditional_optionInputEnvelope
    set?: BookingAdditionalOptionWhereUniqueInput | BookingAdditionalOptionWhereUniqueInput[]
    disconnect?: BookingAdditionalOptionWhereUniqueInput | BookingAdditionalOptionWhereUniqueInput[]
    delete?: BookingAdditionalOptionWhereUniqueInput | BookingAdditionalOptionWhereUniqueInput[]
    connect?: BookingAdditionalOptionWhereUniqueInput | BookingAdditionalOptionWhereUniqueInput[]
    update?: BookingAdditionalOptionUpdateWithWhereUniqueWithoutAdditional_optionInput | BookingAdditionalOptionUpdateWithWhereUniqueWithoutAdditional_optionInput[]
    updateMany?: BookingAdditionalOptionUpdateManyWithWhereWithoutAdditional_optionInput | BookingAdditionalOptionUpdateManyWithWhereWithoutAdditional_optionInput[]
    deleteMany?: BookingAdditionalOptionScalarWhereInput | BookingAdditionalOptionScalarWhereInput[]
  }

  export type BookingAdditionalOptionUncheckedUpdateManyWithoutAdditional_optionNestedInput = {
    create?: XOR<BookingAdditionalOptionCreateWithoutAdditional_optionInput, BookingAdditionalOptionUncheckedCreateWithoutAdditional_optionInput> | BookingAdditionalOptionCreateWithoutAdditional_optionInput[] | BookingAdditionalOptionUncheckedCreateWithoutAdditional_optionInput[]
    connectOrCreate?: BookingAdditionalOptionCreateOrConnectWithoutAdditional_optionInput | BookingAdditionalOptionCreateOrConnectWithoutAdditional_optionInput[]
    upsert?: BookingAdditionalOptionUpsertWithWhereUniqueWithoutAdditional_optionInput | BookingAdditionalOptionUpsertWithWhereUniqueWithoutAdditional_optionInput[]
    createMany?: BookingAdditionalOptionCreateManyAdditional_optionInputEnvelope
    set?: BookingAdditionalOptionWhereUniqueInput | BookingAdditionalOptionWhereUniqueInput[]
    disconnect?: BookingAdditionalOptionWhereUniqueInput | BookingAdditionalOptionWhereUniqueInput[]
    delete?: BookingAdditionalOptionWhereUniqueInput | BookingAdditionalOptionWhereUniqueInput[]
    connect?: BookingAdditionalOptionWhereUniqueInput | BookingAdditionalOptionWhereUniqueInput[]
    update?: BookingAdditionalOptionUpdateWithWhereUniqueWithoutAdditional_optionInput | BookingAdditionalOptionUpdateWithWhereUniqueWithoutAdditional_optionInput[]
    updateMany?: BookingAdditionalOptionUpdateManyWithWhereWithoutAdditional_optionInput | BookingAdditionalOptionUpdateManyWithWhereWithoutAdditional_optionInput[]
    deleteMany?: BookingAdditionalOptionScalarWhereInput | BookingAdditionalOptionScalarWhereInput[]
  }

  export type BookingCreateNestedOneWithoutBooking_additional_optionsInput = {
    create?: XOR<BookingCreateWithoutBooking_additional_optionsInput, BookingUncheckedCreateWithoutBooking_additional_optionsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutBooking_additional_optionsInput
    connect?: BookingWhereUniqueInput
  }

  export type AdditionalOptionCreateNestedOneWithoutBooking_additional_optionsInput = {
    create?: XOR<AdditionalOptionCreateWithoutBooking_additional_optionsInput, AdditionalOptionUncheckedCreateWithoutBooking_additional_optionsInput>
    connectOrCreate?: AdditionalOptionCreateOrConnectWithoutBooking_additional_optionsInput
    connect?: AdditionalOptionWhereUniqueInput
  }

  export type BookingUpdateOneRequiredWithoutBooking_additional_optionsNestedInput = {
    create?: XOR<BookingCreateWithoutBooking_additional_optionsInput, BookingUncheckedCreateWithoutBooking_additional_optionsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutBooking_additional_optionsInput
    upsert?: BookingUpsertWithoutBooking_additional_optionsInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutBooking_additional_optionsInput, BookingUpdateWithoutBooking_additional_optionsInput>, BookingUncheckedUpdateWithoutBooking_additional_optionsInput>
  }

  export type AdditionalOptionUpdateOneRequiredWithoutBooking_additional_optionsNestedInput = {
    create?: XOR<AdditionalOptionCreateWithoutBooking_additional_optionsInput, AdditionalOptionUncheckedCreateWithoutBooking_additional_optionsInput>
    connectOrCreate?: AdditionalOptionCreateOrConnectWithoutBooking_additional_optionsInput
    upsert?: AdditionalOptionUpsertWithoutBooking_additional_optionsInput
    connect?: AdditionalOptionWhereUniqueInput
    update?: XOR<XOR<AdditionalOptionUpdateToOneWithWhereWithoutBooking_additional_optionsInput, AdditionalOptionUpdateWithoutBooking_additional_optionsInput>, AdditionalOptionUncheckedUpdateWithoutBooking_additional_optionsInput>
  }

  export type BookingCreateNestedOneWithoutBooking_eventsInput = {
    create?: XOR<BookingCreateWithoutBooking_eventsInput, BookingUncheckedCreateWithoutBooking_eventsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutBooking_eventsInput
    connect?: BookingWhereUniqueInput
  }

  export type EventCreateNestedOneWithoutBooking_eventsInput = {
    create?: XOR<EventCreateWithoutBooking_eventsInput, EventUncheckedCreateWithoutBooking_eventsInput>
    connectOrCreate?: EventCreateOrConnectWithoutBooking_eventsInput
    connect?: EventWhereUniqueInput
  }

  export type TransactionCreateNestedOneWithoutBooking_eventInput = {
    create?: XOR<TransactionCreateWithoutBooking_eventInput, TransactionUncheckedCreateWithoutBooking_eventInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutBooking_eventInput
    connect?: TransactionWhereUniqueInput
  }

  export type BookingUpdateOneRequiredWithoutBooking_eventsNestedInput = {
    create?: XOR<BookingCreateWithoutBooking_eventsInput, BookingUncheckedCreateWithoutBooking_eventsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutBooking_eventsInput
    upsert?: BookingUpsertWithoutBooking_eventsInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutBooking_eventsInput, BookingUpdateWithoutBooking_eventsInput>, BookingUncheckedUpdateWithoutBooking_eventsInput>
  }

  export type EventUpdateOneRequiredWithoutBooking_eventsNestedInput = {
    create?: XOR<EventCreateWithoutBooking_eventsInput, EventUncheckedCreateWithoutBooking_eventsInput>
    connectOrCreate?: EventCreateOrConnectWithoutBooking_eventsInput
    upsert?: EventUpsertWithoutBooking_eventsInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutBooking_eventsInput, EventUpdateWithoutBooking_eventsInput>, EventUncheckedUpdateWithoutBooking_eventsInput>
  }

  export type TransactionUpdateOneRequiredWithoutBooking_eventNestedInput = {
    create?: XOR<TransactionCreateWithoutBooking_eventInput, TransactionUncheckedCreateWithoutBooking_eventInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutBooking_eventInput
    upsert?: TransactionUpsertWithoutBooking_eventInput
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutBooking_eventInput, TransactionUpdateWithoutBooking_eventInput>, TransactionUncheckedUpdateWithoutBooking_eventInput>
  }

  export type UserCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    connect?: UserWhereUniqueInput
  }

  export type CardDetailCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<CardDetailCreateWithoutTransactionsInput, CardDetailUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CardDetailCreateOrConnectWithoutTransactionsInput
    connect?: CardDetailWhereUniqueInput
  }

  export type TransferDetailCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<TransferDetailCreateWithoutTransactionsInput, TransferDetailUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: TransferDetailCreateOrConnectWithoutTransactionsInput
    connect?: TransferDetailWhereUniqueInput
  }

  export type BookingCreateNestedOneWithoutTransactionInput = {
    create?: XOR<BookingCreateWithoutTransactionInput, BookingUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: BookingCreateOrConnectWithoutTransactionInput
    connect?: BookingWhereUniqueInput
  }

  export type BookingEventCreateNestedOneWithoutTransactionInput = {
    create?: XOR<BookingEventCreateWithoutTransactionInput, BookingEventUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: BookingEventCreateOrConnectWithoutTransactionInput
    connect?: BookingEventWhereUniqueInput
  }

  export type BookingUncheckedCreateNestedOneWithoutTransactionInput = {
    create?: XOR<BookingCreateWithoutTransactionInput, BookingUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: BookingCreateOrConnectWithoutTransactionInput
    connect?: BookingWhereUniqueInput
  }

  export type BookingEventUncheckedCreateNestedOneWithoutTransactionInput = {
    create?: XOR<BookingEventCreateWithoutTransactionInput, BookingEventUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: BookingEventCreateOrConnectWithoutTransactionInput
    connect?: BookingEventWhereUniqueInput
  }

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransactionType
  }

  export type EnumTransactionStatusFieldUpdateOperationsInput = {
    set?: $Enums.TransactionStatus
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type UserUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    upsert?: UserUpsertWithoutTransactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTransactionsInput, UserUpdateWithoutTransactionsInput>, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type CardDetailUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<CardDetailCreateWithoutTransactionsInput, CardDetailUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CardDetailCreateOrConnectWithoutTransactionsInput
    upsert?: CardDetailUpsertWithoutTransactionsInput
    disconnect?: CardDetailWhereInput | boolean
    delete?: CardDetailWhereInput | boolean
    connect?: CardDetailWhereUniqueInput
    update?: XOR<XOR<CardDetailUpdateToOneWithWhereWithoutTransactionsInput, CardDetailUpdateWithoutTransactionsInput>, CardDetailUncheckedUpdateWithoutTransactionsInput>
  }

  export type TransferDetailUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<TransferDetailCreateWithoutTransactionsInput, TransferDetailUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: TransferDetailCreateOrConnectWithoutTransactionsInput
    upsert?: TransferDetailUpsertWithoutTransactionsInput
    disconnect?: TransferDetailWhereInput | boolean
    delete?: TransferDetailWhereInput | boolean
    connect?: TransferDetailWhereUniqueInput
    update?: XOR<XOR<TransferDetailUpdateToOneWithWhereWithoutTransactionsInput, TransferDetailUpdateWithoutTransactionsInput>, TransferDetailUncheckedUpdateWithoutTransactionsInput>
  }

  export type BookingUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<BookingCreateWithoutTransactionInput, BookingUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: BookingCreateOrConnectWithoutTransactionInput
    upsert?: BookingUpsertWithoutTransactionInput
    disconnect?: BookingWhereInput | boolean
    delete?: BookingWhereInput | boolean
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutTransactionInput, BookingUpdateWithoutTransactionInput>, BookingUncheckedUpdateWithoutTransactionInput>
  }

  export type BookingEventUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<BookingEventCreateWithoutTransactionInput, BookingEventUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: BookingEventCreateOrConnectWithoutTransactionInput
    upsert?: BookingEventUpsertWithoutTransactionInput
    disconnect?: BookingEventWhereInput | boolean
    delete?: BookingEventWhereInput | boolean
    connect?: BookingEventWhereUniqueInput
    update?: XOR<XOR<BookingEventUpdateToOneWithWhereWithoutTransactionInput, BookingEventUpdateWithoutTransactionInput>, BookingEventUncheckedUpdateWithoutTransactionInput>
  }

  export type BookingUncheckedUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<BookingCreateWithoutTransactionInput, BookingUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: BookingCreateOrConnectWithoutTransactionInput
    upsert?: BookingUpsertWithoutTransactionInput
    disconnect?: BookingWhereInput | boolean
    delete?: BookingWhereInput | boolean
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutTransactionInput, BookingUpdateWithoutTransactionInput>, BookingUncheckedUpdateWithoutTransactionInput>
  }

  export type BookingEventUncheckedUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<BookingEventCreateWithoutTransactionInput, BookingEventUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: BookingEventCreateOrConnectWithoutTransactionInput
    upsert?: BookingEventUpsertWithoutTransactionInput
    disconnect?: BookingEventWhereInput | boolean
    delete?: BookingEventWhereInput | boolean
    connect?: BookingEventWhereUniqueInput
    update?: XOR<XOR<BookingEventUpdateToOneWithWhereWithoutTransactionInput, BookingEventUpdateWithoutTransactionInput>, BookingEventUncheckedUpdateWithoutTransactionInput>
  }

  export type TransactionCreateNestedManyWithoutTransfer_detailInput = {
    create?: XOR<TransactionCreateWithoutTransfer_detailInput, TransactionUncheckedCreateWithoutTransfer_detailInput> | TransactionCreateWithoutTransfer_detailInput[] | TransactionUncheckedCreateWithoutTransfer_detailInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutTransfer_detailInput | TransactionCreateOrConnectWithoutTransfer_detailInput[]
    createMany?: TransactionCreateManyTransfer_detailInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutTransfer_detailsInput = {
    create?: XOR<UserCreateWithoutTransfer_detailsInput, UserUncheckedCreateWithoutTransfer_detailsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransfer_detailsInput
    connect?: UserWhereUniqueInput
  }

  export type TransactionUncheckedCreateNestedManyWithoutTransfer_detailInput = {
    create?: XOR<TransactionCreateWithoutTransfer_detailInput, TransactionUncheckedCreateWithoutTransfer_detailInput> | TransactionCreateWithoutTransfer_detailInput[] | TransactionUncheckedCreateWithoutTransfer_detailInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutTransfer_detailInput | TransactionCreateOrConnectWithoutTransfer_detailInput[]
    createMany?: TransactionCreateManyTransfer_detailInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUpdateManyWithoutTransfer_detailNestedInput = {
    create?: XOR<TransactionCreateWithoutTransfer_detailInput, TransactionUncheckedCreateWithoutTransfer_detailInput> | TransactionCreateWithoutTransfer_detailInput[] | TransactionUncheckedCreateWithoutTransfer_detailInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutTransfer_detailInput | TransactionCreateOrConnectWithoutTransfer_detailInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutTransfer_detailInput | TransactionUpsertWithWhereUniqueWithoutTransfer_detailInput[]
    createMany?: TransactionCreateManyTransfer_detailInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutTransfer_detailInput | TransactionUpdateWithWhereUniqueWithoutTransfer_detailInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutTransfer_detailInput | TransactionUpdateManyWithWhereWithoutTransfer_detailInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutTransfer_detailsNestedInput = {
    create?: XOR<UserCreateWithoutTransfer_detailsInput, UserUncheckedCreateWithoutTransfer_detailsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransfer_detailsInput
    upsert?: UserUpsertWithoutTransfer_detailsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTransfer_detailsInput, UserUpdateWithoutTransfer_detailsInput>, UserUncheckedUpdateWithoutTransfer_detailsInput>
  }

  export type TransactionUncheckedUpdateManyWithoutTransfer_detailNestedInput = {
    create?: XOR<TransactionCreateWithoutTransfer_detailInput, TransactionUncheckedCreateWithoutTransfer_detailInput> | TransactionCreateWithoutTransfer_detailInput[] | TransactionUncheckedCreateWithoutTransfer_detailInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutTransfer_detailInput | TransactionCreateOrConnectWithoutTransfer_detailInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutTransfer_detailInput | TransactionUpsertWithWhereUniqueWithoutTransfer_detailInput[]
    createMany?: TransactionCreateManyTransfer_detailInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutTransfer_detailInput | TransactionUpdateWithWhereUniqueWithoutTransfer_detailInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutTransfer_detailInput | TransactionUpdateManyWithWhereWithoutTransfer_detailInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionCreateNestedManyWithoutCard_detailInput = {
    create?: XOR<TransactionCreateWithoutCard_detailInput, TransactionUncheckedCreateWithoutCard_detailInput> | TransactionCreateWithoutCard_detailInput[] | TransactionUncheckedCreateWithoutCard_detailInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCard_detailInput | TransactionCreateOrConnectWithoutCard_detailInput[]
    createMany?: TransactionCreateManyCard_detailInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutCard_detailsInput = {
    create?: XOR<UserCreateWithoutCard_detailsInput, UserUncheckedCreateWithoutCard_detailsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCard_detailsInput
    connect?: UserWhereUniqueInput
  }

  export type TransactionUncheckedCreateNestedManyWithoutCard_detailInput = {
    create?: XOR<TransactionCreateWithoutCard_detailInput, TransactionUncheckedCreateWithoutCard_detailInput> | TransactionCreateWithoutCard_detailInput[] | TransactionUncheckedCreateWithoutCard_detailInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCard_detailInput | TransactionCreateOrConnectWithoutCard_detailInput[]
    createMany?: TransactionCreateManyCard_detailInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUpdateManyWithoutCard_detailNestedInput = {
    create?: XOR<TransactionCreateWithoutCard_detailInput, TransactionUncheckedCreateWithoutCard_detailInput> | TransactionCreateWithoutCard_detailInput[] | TransactionUncheckedCreateWithoutCard_detailInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCard_detailInput | TransactionCreateOrConnectWithoutCard_detailInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCard_detailInput | TransactionUpsertWithWhereUniqueWithoutCard_detailInput[]
    createMany?: TransactionCreateManyCard_detailInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCard_detailInput | TransactionUpdateWithWhereUniqueWithoutCard_detailInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCard_detailInput | TransactionUpdateManyWithWhereWithoutCard_detailInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutCard_detailsNestedInput = {
    create?: XOR<UserCreateWithoutCard_detailsInput, UserUncheckedCreateWithoutCard_detailsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCard_detailsInput
    upsert?: UserUpsertWithoutCard_detailsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCard_detailsInput, UserUpdateWithoutCard_detailsInput>, UserUncheckedUpdateWithoutCard_detailsInput>
  }

  export type TransactionUncheckedUpdateManyWithoutCard_detailNestedInput = {
    create?: XOR<TransactionCreateWithoutCard_detailInput, TransactionUncheckedCreateWithoutCard_detailInput> | TransactionCreateWithoutCard_detailInput[] | TransactionUncheckedCreateWithoutCard_detailInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCard_detailInput | TransactionCreateOrConnectWithoutCard_detailInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCard_detailInput | TransactionUpsertWithWhereUniqueWithoutCard_detailInput[]
    createMany?: TransactionCreateManyCard_detailInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCard_detailInput | TransactionUpdateWithWhereUniqueWithoutCard_detailInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCard_detailInput | TransactionUpdateManyWithWhereWithoutCard_detailInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutEventsInput = {
    create?: XOR<UserCreateWithoutEventsInput, UserUncheckedCreateWithoutEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventsInput
    connect?: UserWhereUniqueInput
  }

  export type EventImageCreateNestedManyWithoutEventInput = {
    create?: XOR<EventImageCreateWithoutEventInput, EventImageUncheckedCreateWithoutEventInput> | EventImageCreateWithoutEventInput[] | EventImageUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventImageCreateOrConnectWithoutEventInput | EventImageCreateOrConnectWithoutEventInput[]
    createMany?: EventImageCreateManyEventInputEnvelope
    connect?: EventImageWhereUniqueInput | EventImageWhereUniqueInput[]
  }

  export type BookingEventCreateNestedManyWithoutEventInput = {
    create?: XOR<BookingEventCreateWithoutEventInput, BookingEventUncheckedCreateWithoutEventInput> | BookingEventCreateWithoutEventInput[] | BookingEventUncheckedCreateWithoutEventInput[]
    connectOrCreate?: BookingEventCreateOrConnectWithoutEventInput | BookingEventCreateOrConnectWithoutEventInput[]
    createMany?: BookingEventCreateManyEventInputEnvelope
    connect?: BookingEventWhereUniqueInput | BookingEventWhereUniqueInput[]
  }

  export type EventImageUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<EventImageCreateWithoutEventInput, EventImageUncheckedCreateWithoutEventInput> | EventImageCreateWithoutEventInput[] | EventImageUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventImageCreateOrConnectWithoutEventInput | EventImageCreateOrConnectWithoutEventInput[]
    createMany?: EventImageCreateManyEventInputEnvelope
    connect?: EventImageWhereUniqueInput | EventImageWhereUniqueInput[]
  }

  export type BookingEventUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<BookingEventCreateWithoutEventInput, BookingEventUncheckedCreateWithoutEventInput> | BookingEventCreateWithoutEventInput[] | BookingEventUncheckedCreateWithoutEventInput[]
    connectOrCreate?: BookingEventCreateOrConnectWithoutEventInput | BookingEventCreateOrConnectWithoutEventInput[]
    createMany?: BookingEventCreateManyEventInputEnvelope
    connect?: BookingEventWhereUniqueInput | BookingEventWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutEventsNestedInput = {
    create?: XOR<UserCreateWithoutEventsInput, UserUncheckedCreateWithoutEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventsInput
    upsert?: UserUpsertWithoutEventsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEventsInput, UserUpdateWithoutEventsInput>, UserUncheckedUpdateWithoutEventsInput>
  }

  export type EventImageUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventImageCreateWithoutEventInput, EventImageUncheckedCreateWithoutEventInput> | EventImageCreateWithoutEventInput[] | EventImageUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventImageCreateOrConnectWithoutEventInput | EventImageCreateOrConnectWithoutEventInput[]
    upsert?: EventImageUpsertWithWhereUniqueWithoutEventInput | EventImageUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventImageCreateManyEventInputEnvelope
    set?: EventImageWhereUniqueInput | EventImageWhereUniqueInput[]
    disconnect?: EventImageWhereUniqueInput | EventImageWhereUniqueInput[]
    delete?: EventImageWhereUniqueInput | EventImageWhereUniqueInput[]
    connect?: EventImageWhereUniqueInput | EventImageWhereUniqueInput[]
    update?: EventImageUpdateWithWhereUniqueWithoutEventInput | EventImageUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventImageUpdateManyWithWhereWithoutEventInput | EventImageUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventImageScalarWhereInput | EventImageScalarWhereInput[]
  }

  export type BookingEventUpdateManyWithoutEventNestedInput = {
    create?: XOR<BookingEventCreateWithoutEventInput, BookingEventUncheckedCreateWithoutEventInput> | BookingEventCreateWithoutEventInput[] | BookingEventUncheckedCreateWithoutEventInput[]
    connectOrCreate?: BookingEventCreateOrConnectWithoutEventInput | BookingEventCreateOrConnectWithoutEventInput[]
    upsert?: BookingEventUpsertWithWhereUniqueWithoutEventInput | BookingEventUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: BookingEventCreateManyEventInputEnvelope
    set?: BookingEventWhereUniqueInput | BookingEventWhereUniqueInput[]
    disconnect?: BookingEventWhereUniqueInput | BookingEventWhereUniqueInput[]
    delete?: BookingEventWhereUniqueInput | BookingEventWhereUniqueInput[]
    connect?: BookingEventWhereUniqueInput | BookingEventWhereUniqueInput[]
    update?: BookingEventUpdateWithWhereUniqueWithoutEventInput | BookingEventUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: BookingEventUpdateManyWithWhereWithoutEventInput | BookingEventUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: BookingEventScalarWhereInput | BookingEventScalarWhereInput[]
  }

  export type EventImageUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventImageCreateWithoutEventInput, EventImageUncheckedCreateWithoutEventInput> | EventImageCreateWithoutEventInput[] | EventImageUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventImageCreateOrConnectWithoutEventInput | EventImageCreateOrConnectWithoutEventInput[]
    upsert?: EventImageUpsertWithWhereUniqueWithoutEventInput | EventImageUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventImageCreateManyEventInputEnvelope
    set?: EventImageWhereUniqueInput | EventImageWhereUniqueInput[]
    disconnect?: EventImageWhereUniqueInput | EventImageWhereUniqueInput[]
    delete?: EventImageWhereUniqueInput | EventImageWhereUniqueInput[]
    connect?: EventImageWhereUniqueInput | EventImageWhereUniqueInput[]
    update?: EventImageUpdateWithWhereUniqueWithoutEventInput | EventImageUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventImageUpdateManyWithWhereWithoutEventInput | EventImageUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventImageScalarWhereInput | EventImageScalarWhereInput[]
  }

  export type BookingEventUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<BookingEventCreateWithoutEventInput, BookingEventUncheckedCreateWithoutEventInput> | BookingEventCreateWithoutEventInput[] | BookingEventUncheckedCreateWithoutEventInput[]
    connectOrCreate?: BookingEventCreateOrConnectWithoutEventInput | BookingEventCreateOrConnectWithoutEventInput[]
    upsert?: BookingEventUpsertWithWhereUniqueWithoutEventInput | BookingEventUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: BookingEventCreateManyEventInputEnvelope
    set?: BookingEventWhereUniqueInput | BookingEventWhereUniqueInput[]
    disconnect?: BookingEventWhereUniqueInput | BookingEventWhereUniqueInput[]
    delete?: BookingEventWhereUniqueInput | BookingEventWhereUniqueInput[]
    connect?: BookingEventWhereUniqueInput | BookingEventWhereUniqueInput[]
    update?: BookingEventUpdateWithWhereUniqueWithoutEventInput | BookingEventUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: BookingEventUpdateManyWithWhereWithoutEventInput | BookingEventUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: BookingEventScalarWhereInput | BookingEventScalarWhereInput[]
  }

  export type EventCreateNestedOneWithoutImagesInput = {
    create?: XOR<EventCreateWithoutImagesInput, EventUncheckedCreateWithoutImagesInput>
    connectOrCreate?: EventCreateOrConnectWithoutImagesInput
    connect?: EventWhereUniqueInput
  }

  export type EventUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<EventCreateWithoutImagesInput, EventUncheckedCreateWithoutImagesInput>
    connectOrCreate?: EventCreateOrConnectWithoutImagesInput
    upsert?: EventUpsertWithoutImagesInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutImagesInput, EventUpdateWithoutImagesInput>, EventUncheckedUpdateWithoutImagesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationActionFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationAction | EnumNotificationActionFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationAction[] | ListEnumNotificationActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationAction[] | ListEnumNotificationActionFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationActionFilter<$PrismaModel> | $Enums.NotificationAction
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumNotificationActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationAction | EnumNotificationActionFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationAction[] | ListEnumNotificationActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationAction[] | ListEnumNotificationActionFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationActionWithAggregatesFilter<$PrismaModel> | $Enums.NotificationAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationActionFilter<$PrismaModel>
    _max?: NestedEnumNotificationActionFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumApartmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ApartmentType | EnumApartmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApartmentType[] | ListEnumApartmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApartmentType[] | ListEnumApartmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApartmentTypeFilter<$PrismaModel> | $Enums.ApartmentType
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumApartmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApartmentType | EnumApartmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApartmentType[] | ListEnumApartmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApartmentType[] | ListEnumApartmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApartmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.ApartmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApartmentTypeFilter<$PrismaModel>
    _max?: NestedEnumApartmentTypeFilter<$PrismaModel>
  }

  export type NestedEnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type NestedEnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type NestedEnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type ReservationCreateWithoutUserInput = {
    id?: string
    start: Date | string
    end: Date | string
    created?: Date | string
    updated?: Date | string
    apartment: ApartmentCreateNestedOneWithoutReservationsInput
  }

  export type ReservationUncheckedCreateWithoutUserInput = {
    id?: string
    apartment_id: string
    start: Date | string
    end: Date | string
    created?: Date | string
    updated?: Date | string
  }

  export type ReservationCreateOrConnectWithoutUserInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutUserInput, ReservationUncheckedCreateWithoutUserInput>
  }

  export type ReservationCreateManyUserInputEnvelope = {
    data: ReservationCreateManyUserInput | ReservationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EventCreateWithoutGuideInput = {
    id?: string
    name: string
    image: string
    description: string
    price: number
    capacity: number
    start: Date | string
    end: Date | string
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    images?: EventImageCreateNestedManyWithoutEventInput
    booking_events?: BookingEventCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutGuideInput = {
    id?: string
    name: string
    image: string
    description: string
    price: number
    capacity: number
    start: Date | string
    end: Date | string
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    images?: EventImageUncheckedCreateNestedManyWithoutEventInput
    booking_events?: BookingEventUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutGuideInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutGuideInput, EventUncheckedCreateWithoutGuideInput>
  }

  export type EventCreateManyGuideInputEnvelope = {
    data: EventCreateManyGuideInput | EventCreateManyGuideInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutUserInput = {
    id?: string
    message?: string | null
    status?: $Enums.BookingStatus
    start: Date | string
    end: Date | string
    created?: Date | string
    updated?: Date | string
    booking_variant: BookingVariantCreateNestedOneWithoutBookingsInput
    transaction: TransactionCreateNestedOneWithoutBookingInput
    booking_events?: BookingEventCreateNestedManyWithoutBookingInput
    booking_additional_options?: BookingAdditionalOptionCreateNestedManyWithoutBookingInput
    reviews?: ReviewCreateNestedManyWithoutBookingInput
    messages?: MessageCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutUserInput = {
    id?: string
    booking_variant_id: string
    transaction_id: string
    message?: string | null
    status?: $Enums.BookingStatus
    start: Date | string
    end: Date | string
    created?: Date | string
    updated?: Date | string
    booking_events?: BookingEventUncheckedCreateNestedManyWithoutBookingInput
    booking_additional_options?: BookingAdditionalOptionUncheckedCreateNestedManyWithoutBookingInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBookingInput
    messages?: MessageUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutUserInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput>
  }

  export type BookingCreateManyUserInputEnvelope = {
    data: BookingCreateManyUserInput | BookingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutUserInput = {
    id?: string
    amount: number
    description: string
    transaction_type: $Enums.TransactionType
    transaction_status: $Enums.TransactionStatus
    payment_method: $Enums.PaymentMethod
    created?: Date | string
    updated?: Date | string
    card_detail?: CardDetailCreateNestedOneWithoutTransactionsInput
    transfer_detail?: TransferDetailCreateNestedOneWithoutTransactionsInput
    booking?: BookingCreateNestedOneWithoutTransactionInput
    booking_event?: BookingEventCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutUserInput = {
    id?: string
    amount: number
    description: string
    card_details_id?: string | null
    transfer_details_id?: string | null
    transaction_type: $Enums.TransactionType
    transaction_status: $Enums.TransactionStatus
    payment_method: $Enums.PaymentMethod
    created?: Date | string
    updated?: Date | string
    booking?: BookingUncheckedCreateNestedOneWithoutTransactionInput
    booking_event?: BookingEventUncheckedCreateNestedOneWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutUserInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionCreateManyUserInputEnvelope = {
    data: TransactionCreateManyUserInput | TransactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CardDetailCreateWithoutUserInput = {
    id?: string
    number: string
    expiry_month: number
    expiry_year: number
    holder: string
    token: string
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    transactions?: TransactionCreateNestedManyWithoutCard_detailInput
  }

  export type CardDetailUncheckedCreateWithoutUserInput = {
    id?: string
    number: string
    expiry_month: number
    expiry_year: number
    holder: string
    token: string
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    transactions?: TransactionUncheckedCreateNestedManyWithoutCard_detailInput
  }

  export type CardDetailCreateOrConnectWithoutUserInput = {
    where: CardDetailWhereUniqueInput
    create: XOR<CardDetailCreateWithoutUserInput, CardDetailUncheckedCreateWithoutUserInput>
  }

  export type CardDetailCreateManyUserInputEnvelope = {
    data: CardDetailCreateManyUserInput | CardDetailCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TransferDetailCreateWithoutUserInput = {
    id?: string
    bank_name: string
    account_number: string
    swift: string
    payer_name: string
    created?: Date | string
    updated?: Date | string
    transactions?: TransactionCreateNestedManyWithoutTransfer_detailInput
  }

  export type TransferDetailUncheckedCreateWithoutUserInput = {
    id?: string
    bank_name: string
    account_number: string
    swift: string
    payer_name: string
    created?: Date | string
    updated?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutTransfer_detailInput
  }

  export type TransferDetailCreateOrConnectWithoutUserInput = {
    where: TransferDetailWhereUniqueInput
    create: XOR<TransferDetailCreateWithoutUserInput, TransferDetailUncheckedCreateWithoutUserInput>
  }

  export type TransferDetailCreateManyUserInputEnvelope = {
    data: TransferDetailCreateManyUserInput | TransferDetailCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutUserInput = {
    id?: string
    rating: number
    comment?: string | null
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    apartment?: ApartmentCreateNestedOneWithoutReviewsInput
    booking?: BookingCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutUserInput = {
    id?: string
    apartment_id?: string | null
    booking_id?: string | null
    rating: number
    comment?: string | null
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type ReviewCreateOrConnectWithoutUserInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewCreateManyUserInputEnvelope = {
    data: ReviewCreateManyUserInput | ReviewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutSenderInput = {
    id?: string
    receiver_id: string
    message: string
    is_read?: boolean
    edited?: Date | string | null
    is_excluded?: boolean
    created?: Date | string
    updated?: Date | string
    booking?: BookingCreateNestedOneWithoutMessagesInput
    replaces?: MessageCreateNestedOneWithoutReplaced_byInput
    replaced_by?: MessageCreateNestedManyWithoutReplacesInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: string
    receiver_id: string
    message: string
    is_read?: boolean
    booking_id?: string | null
    edited?: Date | string | null
    replace_to?: string | null
    is_excluded?: boolean
    created?: Date | string
    updated?: Date | string
    replaced_by?: MessageUncheckedCreateNestedManyWithoutReplacesInput
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    action?: $Enums.NotificationAction
    message?: string | null
    is_read?: boolean
    created?: Date | string
    updated?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    action?: $Enums.NotificationAction
    message?: string | null
    is_read?: boolean
    created?: Date | string
    updated?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReservationUpsertWithWhereUniqueWithoutUserInput = {
    where: ReservationWhereUniqueInput
    update: XOR<ReservationUpdateWithoutUserInput, ReservationUncheckedUpdateWithoutUserInput>
    create: XOR<ReservationCreateWithoutUserInput, ReservationUncheckedCreateWithoutUserInput>
  }

  export type ReservationUpdateWithWhereUniqueWithoutUserInput = {
    where: ReservationWhereUniqueInput
    data: XOR<ReservationUpdateWithoutUserInput, ReservationUncheckedUpdateWithoutUserInput>
  }

  export type ReservationUpdateManyWithWhereWithoutUserInput = {
    where: ReservationScalarWhereInput
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyWithoutUserInput>
  }

  export type ReservationScalarWhereInput = {
    AND?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
    OR?: ReservationScalarWhereInput[]
    NOT?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
    id?: StringFilter<"Reservation"> | string
    user_id?: StringFilter<"Reservation"> | string
    apartment_id?: StringFilter<"Reservation"> | string
    start?: DateTimeFilter<"Reservation"> | Date | string
    end?: DateTimeFilter<"Reservation"> | Date | string
    created?: DateTimeFilter<"Reservation"> | Date | string
    updated?: DateTimeFilter<"Reservation"> | Date | string
  }

  export type EventUpsertWithWhereUniqueWithoutGuideInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutGuideInput, EventUncheckedUpdateWithoutGuideInput>
    create: XOR<EventCreateWithoutGuideInput, EventUncheckedCreateWithoutGuideInput>
  }

  export type EventUpdateWithWhereUniqueWithoutGuideInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutGuideInput, EventUncheckedUpdateWithoutGuideInput>
  }

  export type EventUpdateManyWithWhereWithoutGuideInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutGuideInput>
  }

  export type EventScalarWhereInput = {
    AND?: EventScalarWhereInput | EventScalarWhereInput[]
    OR?: EventScalarWhereInput[]
    NOT?: EventScalarWhereInput | EventScalarWhereInput[]
    id?: StringFilter<"Event"> | string
    name?: StringFilter<"Event"> | string
    image?: StringFilter<"Event"> | string
    description?: StringFilter<"Event"> | string
    guide_id?: StringNullableFilter<"Event"> | string | null
    price?: FloatFilter<"Event"> | number
    capacity?: IntFilter<"Event"> | number
    start?: DateTimeFilter<"Event"> | Date | string
    end?: DateTimeFilter<"Event"> | Date | string
    created?: DateTimeFilter<"Event"> | Date | string
    updated?: DateTimeFilter<"Event"> | Date | string
    is_excluded?: BoolFilter<"Event"> | boolean
  }

  export type BookingUpsertWithWhereUniqueWithoutUserInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutUserInput, BookingUncheckedUpdateWithoutUserInput>
    create: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutUserInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutUserInput, BookingUncheckedUpdateWithoutUserInput>
  }

  export type BookingUpdateManyWithWhereWithoutUserInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutUserInput>
  }

  export type BookingScalarWhereInput = {
    AND?: BookingScalarWhereInput | BookingScalarWhereInput[]
    OR?: BookingScalarWhereInput[]
    NOT?: BookingScalarWhereInput | BookingScalarWhereInput[]
    id?: StringFilter<"Booking"> | string
    user_id?: StringFilter<"Booking"> | string
    booking_variant_id?: StringFilter<"Booking"> | string
    transaction_id?: StringFilter<"Booking"> | string
    message?: StringNullableFilter<"Booking"> | string | null
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    start?: DateTimeFilter<"Booking"> | Date | string
    end?: DateTimeFilter<"Booking"> | Date | string
    created?: DateTimeFilter<"Booking"> | Date | string
    updated?: DateTimeFilter<"Booking"> | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
  }

  export type TransactionUpdateManyWithWhereWithoutUserInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutUserInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    amount?: FloatFilter<"Transaction"> | number
    user_id?: StringFilter<"Transaction"> | string
    description?: StringFilter<"Transaction"> | string
    card_details_id?: StringNullableFilter<"Transaction"> | string | null
    transfer_details_id?: StringNullableFilter<"Transaction"> | string | null
    transaction_type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    transaction_status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    payment_method?: EnumPaymentMethodFilter<"Transaction"> | $Enums.PaymentMethod
    created?: DateTimeFilter<"Transaction"> | Date | string
    updated?: DateTimeFilter<"Transaction"> | Date | string
  }

  export type CardDetailUpsertWithWhereUniqueWithoutUserInput = {
    where: CardDetailWhereUniqueInput
    update: XOR<CardDetailUpdateWithoutUserInput, CardDetailUncheckedUpdateWithoutUserInput>
    create: XOR<CardDetailCreateWithoutUserInput, CardDetailUncheckedCreateWithoutUserInput>
  }

  export type CardDetailUpdateWithWhereUniqueWithoutUserInput = {
    where: CardDetailWhereUniqueInput
    data: XOR<CardDetailUpdateWithoutUserInput, CardDetailUncheckedUpdateWithoutUserInput>
  }

  export type CardDetailUpdateManyWithWhereWithoutUserInput = {
    where: CardDetailScalarWhereInput
    data: XOR<CardDetailUpdateManyMutationInput, CardDetailUncheckedUpdateManyWithoutUserInput>
  }

  export type CardDetailScalarWhereInput = {
    AND?: CardDetailScalarWhereInput | CardDetailScalarWhereInput[]
    OR?: CardDetailScalarWhereInput[]
    NOT?: CardDetailScalarWhereInput | CardDetailScalarWhereInput[]
    id?: StringFilter<"CardDetail"> | string
    user_id?: StringFilter<"CardDetail"> | string
    number?: StringFilter<"CardDetail"> | string
    expiry_month?: IntFilter<"CardDetail"> | number
    expiry_year?: IntFilter<"CardDetail"> | number
    holder?: StringFilter<"CardDetail"> | string
    token?: StringFilter<"CardDetail"> | string
    created?: DateTimeFilter<"CardDetail"> | Date | string
    updated?: DateTimeFilter<"CardDetail"> | Date | string
    is_excluded?: BoolFilter<"CardDetail"> | boolean
  }

  export type TransferDetailUpsertWithWhereUniqueWithoutUserInput = {
    where: TransferDetailWhereUniqueInput
    update: XOR<TransferDetailUpdateWithoutUserInput, TransferDetailUncheckedUpdateWithoutUserInput>
    create: XOR<TransferDetailCreateWithoutUserInput, TransferDetailUncheckedCreateWithoutUserInput>
  }

  export type TransferDetailUpdateWithWhereUniqueWithoutUserInput = {
    where: TransferDetailWhereUniqueInput
    data: XOR<TransferDetailUpdateWithoutUserInput, TransferDetailUncheckedUpdateWithoutUserInput>
  }

  export type TransferDetailUpdateManyWithWhereWithoutUserInput = {
    where: TransferDetailScalarWhereInput
    data: XOR<TransferDetailUpdateManyMutationInput, TransferDetailUncheckedUpdateManyWithoutUserInput>
  }

  export type TransferDetailScalarWhereInput = {
    AND?: TransferDetailScalarWhereInput | TransferDetailScalarWhereInput[]
    OR?: TransferDetailScalarWhereInput[]
    NOT?: TransferDetailScalarWhereInput | TransferDetailScalarWhereInput[]
    id?: StringFilter<"TransferDetail"> | string
    bank_name?: StringFilter<"TransferDetail"> | string
    account_number?: StringFilter<"TransferDetail"> | string
    swift?: StringFilter<"TransferDetail"> | string
    payer_name?: StringFilter<"TransferDetail"> | string
    user_id?: StringFilter<"TransferDetail"> | string
    created?: DateTimeFilter<"TransferDetail"> | Date | string
    updated?: DateTimeFilter<"TransferDetail"> | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
  }

  export type ReviewUpdateManyWithWhereWithoutUserInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    id?: StringFilter<"Review"> | string
    user_id?: StringFilter<"Review"> | string
    apartment_id?: StringNullableFilter<"Review"> | string | null
    booking_id?: StringNullableFilter<"Review"> | string | null
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    created?: DateTimeFilter<"Review"> | Date | string
    updated?: DateTimeFilter<"Review"> | Date | string
    is_excluded?: BoolFilter<"Review"> | boolean
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    sender_id?: StringFilter<"Message"> | string
    receiver_id?: StringFilter<"Message"> | string
    message?: StringFilter<"Message"> | string
    is_read?: BoolFilter<"Message"> | boolean
    booking_id?: StringNullableFilter<"Message"> | string | null
    edited?: DateTimeNullableFilter<"Message"> | Date | string | null
    replace_to?: StringNullableFilter<"Message"> | string | null
    is_excluded?: BoolFilter<"Message"> | boolean
    created?: DateTimeFilter<"Message"> | Date | string
    updated?: DateTimeFilter<"Message"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    action?: EnumNotificationActionFilter<"Notification"> | $Enums.NotificationAction
    message?: StringNullableFilter<"Notification"> | string | null
    user_id?: StringNullableFilter<"Notification"> | string | null
    is_read?: BoolFilter<"Notification"> | boolean
    created?: DateTimeFilter<"Notification"> | Date | string
    updated?: DateTimeFilter<"Notification"> | Date | string
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password_hash: string
    image?: string | null
    first_name: string
    last_name: string
    phone_number?: string | null
    date_of_birth?: Date | string | null
    is_active?: boolean
    email_verified?: boolean
    phone_verified?: boolean
    role?: $Enums.Role
    created?: Date | string
    updated?: Date | string
    reservations?: ReservationCreateNestedManyWithoutUserInput
    events?: EventCreateNestedManyWithoutGuideInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    card_details?: CardDetailCreateNestedManyWithoutUserInput
    transfer_details?: TransferDetailCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    sent_messages?: MessageCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password_hash: string
    image?: string | null
    first_name: string
    last_name: string
    phone_number?: string | null
    date_of_birth?: Date | string | null
    is_active?: boolean
    email_verified?: boolean
    phone_verified?: boolean
    role?: $Enums.Role
    created?: Date | string
    updated?: Date | string
    reservations?: ReservationUncheckedCreateNestedManyWithoutUserInput
    events?: EventUncheckedCreateNestedManyWithoutGuideInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    card_details?: CardDetailUncheckedCreateNestedManyWithoutUserInput
    transfer_details?: TransferDetailUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    sent_messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    phone_verified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUpdateManyWithoutUserNestedInput
    events?: EventUpdateManyWithoutGuideNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    card_details?: CardDetailUpdateManyWithoutUserNestedInput
    transfer_details?: TransferDetailUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    sent_messages?: MessageUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    phone_verified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUncheckedUpdateManyWithoutUserNestedInput
    events?: EventUncheckedUpdateManyWithoutGuideNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    card_details?: CardDetailUncheckedUpdateManyWithoutUserNestedInput
    transfer_details?: TransferDetailUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    sent_messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserCreateWithoutSent_messagesInput = {
    id?: string
    email: string
    password_hash: string
    image?: string | null
    first_name: string
    last_name: string
    phone_number?: string | null
    date_of_birth?: Date | string | null
    is_active?: boolean
    email_verified?: boolean
    phone_verified?: boolean
    role?: $Enums.Role
    created?: Date | string
    updated?: Date | string
    reservations?: ReservationCreateNestedManyWithoutUserInput
    events?: EventCreateNestedManyWithoutGuideInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    card_details?: CardDetailCreateNestedManyWithoutUserInput
    transfer_details?: TransferDetailCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSent_messagesInput = {
    id?: string
    email: string
    password_hash: string
    image?: string | null
    first_name: string
    last_name: string
    phone_number?: string | null
    date_of_birth?: Date | string | null
    is_active?: boolean
    email_verified?: boolean
    phone_verified?: boolean
    role?: $Enums.Role
    created?: Date | string
    updated?: Date | string
    reservations?: ReservationUncheckedCreateNestedManyWithoutUserInput
    events?: EventUncheckedCreateNestedManyWithoutGuideInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    card_details?: CardDetailUncheckedCreateNestedManyWithoutUserInput
    transfer_details?: TransferDetailUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSent_messagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSent_messagesInput, UserUncheckedCreateWithoutSent_messagesInput>
  }

  export type BookingCreateWithoutMessagesInput = {
    id?: string
    message?: string | null
    status?: $Enums.BookingStatus
    start: Date | string
    end: Date | string
    created?: Date | string
    updated?: Date | string
    booking_variant: BookingVariantCreateNestedOneWithoutBookingsInput
    user: UserCreateNestedOneWithoutBookingsInput
    transaction: TransactionCreateNestedOneWithoutBookingInput
    booking_events?: BookingEventCreateNestedManyWithoutBookingInput
    booking_additional_options?: BookingAdditionalOptionCreateNestedManyWithoutBookingInput
    reviews?: ReviewCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutMessagesInput = {
    id?: string
    user_id: string
    booking_variant_id: string
    transaction_id: string
    message?: string | null
    status?: $Enums.BookingStatus
    start: Date | string
    end: Date | string
    created?: Date | string
    updated?: Date | string
    booking_events?: BookingEventUncheckedCreateNestedManyWithoutBookingInput
    booking_additional_options?: BookingAdditionalOptionUncheckedCreateNestedManyWithoutBookingInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutMessagesInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutMessagesInput, BookingUncheckedCreateWithoutMessagesInput>
  }

  export type MessageCreateWithoutReplaced_byInput = {
    id?: string
    receiver_id: string
    message: string
    is_read?: boolean
    edited?: Date | string | null
    is_excluded?: boolean
    created?: Date | string
    updated?: Date | string
    sender: UserCreateNestedOneWithoutSent_messagesInput
    booking?: BookingCreateNestedOneWithoutMessagesInput
    replaces?: MessageCreateNestedOneWithoutReplaced_byInput
  }

  export type MessageUncheckedCreateWithoutReplaced_byInput = {
    id?: string
    sender_id: string
    receiver_id: string
    message: string
    is_read?: boolean
    booking_id?: string | null
    edited?: Date | string | null
    replace_to?: string | null
    is_excluded?: boolean
    created?: Date | string
    updated?: Date | string
  }

  export type MessageCreateOrConnectWithoutReplaced_byInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutReplaced_byInput, MessageUncheckedCreateWithoutReplaced_byInput>
  }

  export type MessageCreateWithoutReplacesInput = {
    id?: string
    receiver_id: string
    message: string
    is_read?: boolean
    edited?: Date | string | null
    is_excluded?: boolean
    created?: Date | string
    updated?: Date | string
    sender: UserCreateNestedOneWithoutSent_messagesInput
    booking?: BookingCreateNestedOneWithoutMessagesInput
    replaced_by?: MessageCreateNestedManyWithoutReplacesInput
  }

  export type MessageUncheckedCreateWithoutReplacesInput = {
    id?: string
    sender_id: string
    receiver_id: string
    message: string
    is_read?: boolean
    booking_id?: string | null
    edited?: Date | string | null
    is_excluded?: boolean
    created?: Date | string
    updated?: Date | string
    replaced_by?: MessageUncheckedCreateNestedManyWithoutReplacesInput
  }

  export type MessageCreateOrConnectWithoutReplacesInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutReplacesInput, MessageUncheckedCreateWithoutReplacesInput>
  }

  export type MessageCreateManyReplacesInputEnvelope = {
    data: MessageCreateManyReplacesInput | MessageCreateManyReplacesInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSent_messagesInput = {
    update: XOR<UserUpdateWithoutSent_messagesInput, UserUncheckedUpdateWithoutSent_messagesInput>
    create: XOR<UserCreateWithoutSent_messagesInput, UserUncheckedCreateWithoutSent_messagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSent_messagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSent_messagesInput, UserUncheckedUpdateWithoutSent_messagesInput>
  }

  export type UserUpdateWithoutSent_messagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    phone_verified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUpdateManyWithoutUserNestedInput
    events?: EventUpdateManyWithoutGuideNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    card_details?: CardDetailUpdateManyWithoutUserNestedInput
    transfer_details?: TransferDetailUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSent_messagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    phone_verified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUncheckedUpdateManyWithoutUserNestedInput
    events?: EventUncheckedUpdateManyWithoutGuideNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    card_details?: CardDetailUncheckedUpdateManyWithoutUserNestedInput
    transfer_details?: TransferDetailUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BookingUpsertWithoutMessagesInput = {
    update: XOR<BookingUpdateWithoutMessagesInput, BookingUncheckedUpdateWithoutMessagesInput>
    create: XOR<BookingCreateWithoutMessagesInput, BookingUncheckedCreateWithoutMessagesInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutMessagesInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutMessagesInput, BookingUncheckedUpdateWithoutMessagesInput>
  }

  export type BookingUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_variant?: BookingVariantUpdateOneRequiredWithoutBookingsNestedInput
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutBookingNestedInput
    booking_events?: BookingEventUpdateManyWithoutBookingNestedInput
    booking_additional_options?: BookingAdditionalOptionUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    booking_variant_id?: StringFieldUpdateOperationsInput | string
    transaction_id?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_events?: BookingEventUncheckedUpdateManyWithoutBookingNestedInput
    booking_additional_options?: BookingAdditionalOptionUncheckedUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type MessageUpsertWithoutReplaced_byInput = {
    update: XOR<MessageUpdateWithoutReplaced_byInput, MessageUncheckedUpdateWithoutReplaced_byInput>
    create: XOR<MessageCreateWithoutReplaced_byInput, MessageUncheckedCreateWithoutReplaced_byInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutReplaced_byInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutReplaced_byInput, MessageUncheckedUpdateWithoutReplaced_byInput>
  }

  export type MessageUpdateWithoutReplaced_byInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiver_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    edited?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSent_messagesNestedInput
    booking?: BookingUpdateOneWithoutMessagesNestedInput
    replaces?: MessageUpdateOneWithoutReplaced_byNestedInput
  }

  export type MessageUncheckedUpdateWithoutReplaced_byInput = {
    id?: StringFieldUpdateOperationsInput | string
    sender_id?: StringFieldUpdateOperationsInput | string
    receiver_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    booking_id?: NullableStringFieldUpdateOperationsInput | string | null
    edited?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replace_to?: NullableStringFieldUpdateOperationsInput | string | null
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutReplacesInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutReplacesInput, MessageUncheckedUpdateWithoutReplacesInput>
    create: XOR<MessageCreateWithoutReplacesInput, MessageUncheckedCreateWithoutReplacesInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutReplacesInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutReplacesInput, MessageUncheckedUpdateWithoutReplacesInput>
  }

  export type MessageUpdateManyWithWhereWithoutReplacesInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutReplacesInput>
  }

  export type ApartmentImageCreateWithoutApartmentInput = {
    id?: string
    image: string
    name?: string | null
    description?: string | null
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type ApartmentImageUncheckedCreateWithoutApartmentInput = {
    id?: string
    image: string
    name?: string | null
    description?: string | null
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type ApartmentImageCreateOrConnectWithoutApartmentInput = {
    where: ApartmentImageWhereUniqueInput
    create: XOR<ApartmentImageCreateWithoutApartmentInput, ApartmentImageUncheckedCreateWithoutApartmentInput>
  }

  export type ApartmentImageCreateManyApartmentInputEnvelope = {
    data: ApartmentImageCreateManyApartmentInput | ApartmentImageCreateManyApartmentInput[]
    skipDuplicates?: boolean
  }

  export type ApartmentBedCreateWithoutApartmentInput = {
    id?: string
    count: number
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    bed_type: BedTypeCreateNestedOneWithoutApartment_bedsInput
  }

  export type ApartmentBedUncheckedCreateWithoutApartmentInput = {
    id?: string
    bed_type_id: string
    count: number
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type ApartmentBedCreateOrConnectWithoutApartmentInput = {
    where: ApartmentBedWhereUniqueInput
    create: XOR<ApartmentBedCreateWithoutApartmentInput, ApartmentBedUncheckedCreateWithoutApartmentInput>
  }

  export type ApartmentBedCreateManyApartmentInputEnvelope = {
    data: ApartmentBedCreateManyApartmentInput | ApartmentBedCreateManyApartmentInput[]
    skipDuplicates?: boolean
  }

  export type ApartmentAmenityCreateWithoutApartmentInput = {
    id?: string
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    amenity: AmenityCreateNestedOneWithoutApartment_amenitiesInput
  }

  export type ApartmentAmenityUncheckedCreateWithoutApartmentInput = {
    id?: string
    amenity_id: string
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type ApartmentAmenityCreateOrConnectWithoutApartmentInput = {
    where: ApartmentAmenityWhereUniqueInput
    create: XOR<ApartmentAmenityCreateWithoutApartmentInput, ApartmentAmenityUncheckedCreateWithoutApartmentInput>
  }

  export type ApartmentAmenityCreateManyApartmentInputEnvelope = {
    data: ApartmentAmenityCreateManyApartmentInput | ApartmentAmenityCreateManyApartmentInput[]
    skipDuplicates?: boolean
  }

  export type ReservationCreateWithoutApartmentInput = {
    id?: string
    start: Date | string
    end: Date | string
    created?: Date | string
    updated?: Date | string
    user: UserCreateNestedOneWithoutReservationsInput
  }

  export type ReservationUncheckedCreateWithoutApartmentInput = {
    id?: string
    user_id: string
    start: Date | string
    end: Date | string
    created?: Date | string
    updated?: Date | string
  }

  export type ReservationCreateOrConnectWithoutApartmentInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutApartmentInput, ReservationUncheckedCreateWithoutApartmentInput>
  }

  export type ReservationCreateManyApartmentInputEnvelope = {
    data: ReservationCreateManyApartmentInput | ReservationCreateManyApartmentInput[]
    skipDuplicates?: boolean
  }

  export type BookingVariantCreateWithoutApartmentInput = {
    id?: string
    price: number
    capacity: number
    is_available?: boolean
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    bookings?: BookingCreateNestedManyWithoutBooking_variantInput
  }

  export type BookingVariantUncheckedCreateWithoutApartmentInput = {
    id?: string
    price: number
    capacity: number
    is_available?: boolean
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    bookings?: BookingUncheckedCreateNestedManyWithoutBooking_variantInput
  }

  export type BookingVariantCreateOrConnectWithoutApartmentInput = {
    where: BookingVariantWhereUniqueInput
    create: XOR<BookingVariantCreateWithoutApartmentInput, BookingVariantUncheckedCreateWithoutApartmentInput>
  }

  export type BookingVariantCreateManyApartmentInputEnvelope = {
    data: BookingVariantCreateManyApartmentInput | BookingVariantCreateManyApartmentInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutApartmentInput = {
    id?: string
    rating: number
    comment?: string | null
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    user: UserCreateNestedOneWithoutReviewsInput
    booking?: BookingCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutApartmentInput = {
    id?: string
    user_id: string
    booking_id?: string | null
    rating: number
    comment?: string | null
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type ReviewCreateOrConnectWithoutApartmentInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutApartmentInput, ReviewUncheckedCreateWithoutApartmentInput>
  }

  export type ReviewCreateManyApartmentInputEnvelope = {
    data: ReviewCreateManyApartmentInput | ReviewCreateManyApartmentInput[]
    skipDuplicates?: boolean
  }

  export type ApartmentImageUpsertWithWhereUniqueWithoutApartmentInput = {
    where: ApartmentImageWhereUniqueInput
    update: XOR<ApartmentImageUpdateWithoutApartmentInput, ApartmentImageUncheckedUpdateWithoutApartmentInput>
    create: XOR<ApartmentImageCreateWithoutApartmentInput, ApartmentImageUncheckedCreateWithoutApartmentInput>
  }

  export type ApartmentImageUpdateWithWhereUniqueWithoutApartmentInput = {
    where: ApartmentImageWhereUniqueInput
    data: XOR<ApartmentImageUpdateWithoutApartmentInput, ApartmentImageUncheckedUpdateWithoutApartmentInput>
  }

  export type ApartmentImageUpdateManyWithWhereWithoutApartmentInput = {
    where: ApartmentImageScalarWhereInput
    data: XOR<ApartmentImageUpdateManyMutationInput, ApartmentImageUncheckedUpdateManyWithoutApartmentInput>
  }

  export type ApartmentImageScalarWhereInput = {
    AND?: ApartmentImageScalarWhereInput | ApartmentImageScalarWhereInput[]
    OR?: ApartmentImageScalarWhereInput[]
    NOT?: ApartmentImageScalarWhereInput | ApartmentImageScalarWhereInput[]
    id?: StringFilter<"ApartmentImage"> | string
    image?: StringFilter<"ApartmentImage"> | string
    name?: StringNullableFilter<"ApartmentImage"> | string | null
    description?: StringNullableFilter<"ApartmentImage"> | string | null
    apartment_id?: StringFilter<"ApartmentImage"> | string
    created?: DateTimeFilter<"ApartmentImage"> | Date | string
    updated?: DateTimeFilter<"ApartmentImage"> | Date | string
    is_excluded?: BoolFilter<"ApartmentImage"> | boolean
  }

  export type ApartmentBedUpsertWithWhereUniqueWithoutApartmentInput = {
    where: ApartmentBedWhereUniqueInput
    update: XOR<ApartmentBedUpdateWithoutApartmentInput, ApartmentBedUncheckedUpdateWithoutApartmentInput>
    create: XOR<ApartmentBedCreateWithoutApartmentInput, ApartmentBedUncheckedCreateWithoutApartmentInput>
  }

  export type ApartmentBedUpdateWithWhereUniqueWithoutApartmentInput = {
    where: ApartmentBedWhereUniqueInput
    data: XOR<ApartmentBedUpdateWithoutApartmentInput, ApartmentBedUncheckedUpdateWithoutApartmentInput>
  }

  export type ApartmentBedUpdateManyWithWhereWithoutApartmentInput = {
    where: ApartmentBedScalarWhereInput
    data: XOR<ApartmentBedUpdateManyMutationInput, ApartmentBedUncheckedUpdateManyWithoutApartmentInput>
  }

  export type ApartmentBedScalarWhereInput = {
    AND?: ApartmentBedScalarWhereInput | ApartmentBedScalarWhereInput[]
    OR?: ApartmentBedScalarWhereInput[]
    NOT?: ApartmentBedScalarWhereInput | ApartmentBedScalarWhereInput[]
    id?: StringFilter<"ApartmentBed"> | string
    apartment_id?: StringFilter<"ApartmentBed"> | string
    bed_type_id?: StringFilter<"ApartmentBed"> | string
    count?: IntFilter<"ApartmentBed"> | number
    created?: DateTimeFilter<"ApartmentBed"> | Date | string
    updated?: DateTimeFilter<"ApartmentBed"> | Date | string
    is_excluded?: BoolFilter<"ApartmentBed"> | boolean
  }

  export type ApartmentAmenityUpsertWithWhereUniqueWithoutApartmentInput = {
    where: ApartmentAmenityWhereUniqueInput
    update: XOR<ApartmentAmenityUpdateWithoutApartmentInput, ApartmentAmenityUncheckedUpdateWithoutApartmentInput>
    create: XOR<ApartmentAmenityCreateWithoutApartmentInput, ApartmentAmenityUncheckedCreateWithoutApartmentInput>
  }

  export type ApartmentAmenityUpdateWithWhereUniqueWithoutApartmentInput = {
    where: ApartmentAmenityWhereUniqueInput
    data: XOR<ApartmentAmenityUpdateWithoutApartmentInput, ApartmentAmenityUncheckedUpdateWithoutApartmentInput>
  }

  export type ApartmentAmenityUpdateManyWithWhereWithoutApartmentInput = {
    where: ApartmentAmenityScalarWhereInput
    data: XOR<ApartmentAmenityUpdateManyMutationInput, ApartmentAmenityUncheckedUpdateManyWithoutApartmentInput>
  }

  export type ApartmentAmenityScalarWhereInput = {
    AND?: ApartmentAmenityScalarWhereInput | ApartmentAmenityScalarWhereInput[]
    OR?: ApartmentAmenityScalarWhereInput[]
    NOT?: ApartmentAmenityScalarWhereInput | ApartmentAmenityScalarWhereInput[]
    id?: StringFilter<"ApartmentAmenity"> | string
    amenity_id?: StringFilter<"ApartmentAmenity"> | string
    apartment_id?: StringFilter<"ApartmentAmenity"> | string
    created?: DateTimeFilter<"ApartmentAmenity"> | Date | string
    updated?: DateTimeFilter<"ApartmentAmenity"> | Date | string
    is_excluded?: BoolFilter<"ApartmentAmenity"> | boolean
  }

  export type ReservationUpsertWithWhereUniqueWithoutApartmentInput = {
    where: ReservationWhereUniqueInput
    update: XOR<ReservationUpdateWithoutApartmentInput, ReservationUncheckedUpdateWithoutApartmentInput>
    create: XOR<ReservationCreateWithoutApartmentInput, ReservationUncheckedCreateWithoutApartmentInput>
  }

  export type ReservationUpdateWithWhereUniqueWithoutApartmentInput = {
    where: ReservationWhereUniqueInput
    data: XOR<ReservationUpdateWithoutApartmentInput, ReservationUncheckedUpdateWithoutApartmentInput>
  }

  export type ReservationUpdateManyWithWhereWithoutApartmentInput = {
    where: ReservationScalarWhereInput
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyWithoutApartmentInput>
  }

  export type BookingVariantUpsertWithWhereUniqueWithoutApartmentInput = {
    where: BookingVariantWhereUniqueInput
    update: XOR<BookingVariantUpdateWithoutApartmentInput, BookingVariantUncheckedUpdateWithoutApartmentInput>
    create: XOR<BookingVariantCreateWithoutApartmentInput, BookingVariantUncheckedCreateWithoutApartmentInput>
  }

  export type BookingVariantUpdateWithWhereUniqueWithoutApartmentInput = {
    where: BookingVariantWhereUniqueInput
    data: XOR<BookingVariantUpdateWithoutApartmentInput, BookingVariantUncheckedUpdateWithoutApartmentInput>
  }

  export type BookingVariantUpdateManyWithWhereWithoutApartmentInput = {
    where: BookingVariantScalarWhereInput
    data: XOR<BookingVariantUpdateManyMutationInput, BookingVariantUncheckedUpdateManyWithoutApartmentInput>
  }

  export type BookingVariantScalarWhereInput = {
    AND?: BookingVariantScalarWhereInput | BookingVariantScalarWhereInput[]
    OR?: BookingVariantScalarWhereInput[]
    NOT?: BookingVariantScalarWhereInput | BookingVariantScalarWhereInput[]
    id?: StringFilter<"BookingVariant"> | string
    apartment_id?: StringFilter<"BookingVariant"> | string
    price?: FloatFilter<"BookingVariant"> | number
    capacity?: IntFilter<"BookingVariant"> | number
    is_available?: BoolFilter<"BookingVariant"> | boolean
    created?: DateTimeFilter<"BookingVariant"> | Date | string
    updated?: DateTimeFilter<"BookingVariant"> | Date | string
    is_excluded?: BoolFilter<"BookingVariant"> | boolean
  }

  export type ReviewUpsertWithWhereUniqueWithoutApartmentInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutApartmentInput, ReviewUncheckedUpdateWithoutApartmentInput>
    create: XOR<ReviewCreateWithoutApartmentInput, ReviewUncheckedCreateWithoutApartmentInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutApartmentInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutApartmentInput, ReviewUncheckedUpdateWithoutApartmentInput>
  }

  export type ReviewUpdateManyWithWhereWithoutApartmentInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutApartmentInput>
  }

  export type UserCreateWithoutReviewsInput = {
    id?: string
    email: string
    password_hash: string
    image?: string | null
    first_name: string
    last_name: string
    phone_number?: string | null
    date_of_birth?: Date | string | null
    is_active?: boolean
    email_verified?: boolean
    phone_verified?: boolean
    role?: $Enums.Role
    created?: Date | string
    updated?: Date | string
    reservations?: ReservationCreateNestedManyWithoutUserInput
    events?: EventCreateNestedManyWithoutGuideInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    card_details?: CardDetailCreateNestedManyWithoutUserInput
    transfer_details?: TransferDetailCreateNestedManyWithoutUserInput
    sent_messages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewsInput = {
    id?: string
    email: string
    password_hash: string
    image?: string | null
    first_name: string
    last_name: string
    phone_number?: string | null
    date_of_birth?: Date | string | null
    is_active?: boolean
    email_verified?: boolean
    phone_verified?: boolean
    role?: $Enums.Role
    created?: Date | string
    updated?: Date | string
    reservations?: ReservationUncheckedCreateNestedManyWithoutUserInput
    events?: EventUncheckedCreateNestedManyWithoutGuideInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    card_details?: CardDetailUncheckedCreateNestedManyWithoutUserInput
    transfer_details?: TransferDetailUncheckedCreateNestedManyWithoutUserInput
    sent_messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
  }

  export type ApartmentCreateWithoutReviewsInput = {
    id?: string
    image?: string | null
    name?: string | null
    description?: string | null
    rules?: string | null
    number: number
    floor: number
    rooms_count: number
    max_capacity?: number | null
    is_available?: boolean
    is_smoking?: boolean
    is_pet_friendly?: boolean
    deposit?: number
    type: $Enums.ApartmentType
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    images?: ApartmentImageCreateNestedManyWithoutApartmentInput
    apartment_beds?: ApartmentBedCreateNestedManyWithoutApartmentInput
    apartment_amenities?: ApartmentAmenityCreateNestedManyWithoutApartmentInput
    reservations?: ReservationCreateNestedManyWithoutApartmentInput
    booking_variants?: BookingVariantCreateNestedManyWithoutApartmentInput
  }

  export type ApartmentUncheckedCreateWithoutReviewsInput = {
    id?: string
    image?: string | null
    name?: string | null
    description?: string | null
    rules?: string | null
    number: number
    floor: number
    rooms_count: number
    max_capacity?: number | null
    is_available?: boolean
    is_smoking?: boolean
    is_pet_friendly?: boolean
    deposit?: number
    type: $Enums.ApartmentType
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    images?: ApartmentImageUncheckedCreateNestedManyWithoutApartmentInput
    apartment_beds?: ApartmentBedUncheckedCreateNestedManyWithoutApartmentInput
    apartment_amenities?: ApartmentAmenityUncheckedCreateNestedManyWithoutApartmentInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutApartmentInput
    booking_variants?: BookingVariantUncheckedCreateNestedManyWithoutApartmentInput
  }

  export type ApartmentCreateOrConnectWithoutReviewsInput = {
    where: ApartmentWhereUniqueInput
    create: XOR<ApartmentCreateWithoutReviewsInput, ApartmentUncheckedCreateWithoutReviewsInput>
  }

  export type BookingCreateWithoutReviewsInput = {
    id?: string
    message?: string | null
    status?: $Enums.BookingStatus
    start: Date | string
    end: Date | string
    created?: Date | string
    updated?: Date | string
    booking_variant: BookingVariantCreateNestedOneWithoutBookingsInput
    user: UserCreateNestedOneWithoutBookingsInput
    transaction: TransactionCreateNestedOneWithoutBookingInput
    booking_events?: BookingEventCreateNestedManyWithoutBookingInput
    booking_additional_options?: BookingAdditionalOptionCreateNestedManyWithoutBookingInput
    messages?: MessageCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutReviewsInput = {
    id?: string
    user_id: string
    booking_variant_id: string
    transaction_id: string
    message?: string | null
    status?: $Enums.BookingStatus
    start: Date | string
    end: Date | string
    created?: Date | string
    updated?: Date | string
    booking_events?: BookingEventUncheckedCreateNestedManyWithoutBookingInput
    booking_additional_options?: BookingAdditionalOptionUncheckedCreateNestedManyWithoutBookingInput
    messages?: MessageUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutReviewsInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutReviewsInput, BookingUncheckedCreateWithoutReviewsInput>
  }

  export type UserUpsertWithoutReviewsInput = {
    update: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    phone_verified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUpdateManyWithoutUserNestedInput
    events?: EventUpdateManyWithoutGuideNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    card_details?: CardDetailUpdateManyWithoutUserNestedInput
    transfer_details?: TransferDetailUpdateManyWithoutUserNestedInput
    sent_messages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    phone_verified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUncheckedUpdateManyWithoutUserNestedInput
    events?: EventUncheckedUpdateManyWithoutGuideNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    card_details?: CardDetailUncheckedUpdateManyWithoutUserNestedInput
    transfer_details?: TransferDetailUncheckedUpdateManyWithoutUserNestedInput
    sent_messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ApartmentUpsertWithoutReviewsInput = {
    update: XOR<ApartmentUpdateWithoutReviewsInput, ApartmentUncheckedUpdateWithoutReviewsInput>
    create: XOR<ApartmentCreateWithoutReviewsInput, ApartmentUncheckedCreateWithoutReviewsInput>
    where?: ApartmentWhereInput
  }

  export type ApartmentUpdateToOneWithWhereWithoutReviewsInput = {
    where?: ApartmentWhereInput
    data: XOR<ApartmentUpdateWithoutReviewsInput, ApartmentUncheckedUpdateWithoutReviewsInput>
  }

  export type ApartmentUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    number?: IntFieldUpdateOperationsInput | number
    floor?: IntFieldUpdateOperationsInput | number
    rooms_count?: IntFieldUpdateOperationsInput | number
    max_capacity?: NullableIntFieldUpdateOperationsInput | number | null
    is_available?: BoolFieldUpdateOperationsInput | boolean
    is_smoking?: BoolFieldUpdateOperationsInput | boolean
    is_pet_friendly?: BoolFieldUpdateOperationsInput | boolean
    deposit?: FloatFieldUpdateOperationsInput | number
    type?: EnumApartmentTypeFieldUpdateOperationsInput | $Enums.ApartmentType
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    images?: ApartmentImageUpdateManyWithoutApartmentNestedInput
    apartment_beds?: ApartmentBedUpdateManyWithoutApartmentNestedInput
    apartment_amenities?: ApartmentAmenityUpdateManyWithoutApartmentNestedInput
    reservations?: ReservationUpdateManyWithoutApartmentNestedInput
    booking_variants?: BookingVariantUpdateManyWithoutApartmentNestedInput
  }

  export type ApartmentUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    number?: IntFieldUpdateOperationsInput | number
    floor?: IntFieldUpdateOperationsInput | number
    rooms_count?: IntFieldUpdateOperationsInput | number
    max_capacity?: NullableIntFieldUpdateOperationsInput | number | null
    is_available?: BoolFieldUpdateOperationsInput | boolean
    is_smoking?: BoolFieldUpdateOperationsInput | boolean
    is_pet_friendly?: BoolFieldUpdateOperationsInput | boolean
    deposit?: FloatFieldUpdateOperationsInput | number
    type?: EnumApartmentTypeFieldUpdateOperationsInput | $Enums.ApartmentType
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    images?: ApartmentImageUncheckedUpdateManyWithoutApartmentNestedInput
    apartment_beds?: ApartmentBedUncheckedUpdateManyWithoutApartmentNestedInput
    apartment_amenities?: ApartmentAmenityUncheckedUpdateManyWithoutApartmentNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutApartmentNestedInput
    booking_variants?: BookingVariantUncheckedUpdateManyWithoutApartmentNestedInput
  }

  export type BookingUpsertWithoutReviewsInput = {
    update: XOR<BookingUpdateWithoutReviewsInput, BookingUncheckedUpdateWithoutReviewsInput>
    create: XOR<BookingCreateWithoutReviewsInput, BookingUncheckedCreateWithoutReviewsInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutReviewsInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutReviewsInput, BookingUncheckedUpdateWithoutReviewsInput>
  }

  export type BookingUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_variant?: BookingVariantUpdateOneRequiredWithoutBookingsNestedInput
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutBookingNestedInput
    booking_events?: BookingEventUpdateManyWithoutBookingNestedInput
    booking_additional_options?: BookingAdditionalOptionUpdateManyWithoutBookingNestedInput
    messages?: MessageUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    booking_variant_id?: StringFieldUpdateOperationsInput | string
    transaction_id?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_events?: BookingEventUncheckedUpdateManyWithoutBookingNestedInput
    booking_additional_options?: BookingAdditionalOptionUncheckedUpdateManyWithoutBookingNestedInput
    messages?: MessageUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type ApartmentAmenityCreateWithoutAmenityInput = {
    id?: string
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    apartment: ApartmentCreateNestedOneWithoutApartment_amenitiesInput
  }

  export type ApartmentAmenityUncheckedCreateWithoutAmenityInput = {
    id?: string
    apartment_id: string
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type ApartmentAmenityCreateOrConnectWithoutAmenityInput = {
    where: ApartmentAmenityWhereUniqueInput
    create: XOR<ApartmentAmenityCreateWithoutAmenityInput, ApartmentAmenityUncheckedCreateWithoutAmenityInput>
  }

  export type ApartmentAmenityCreateManyAmenityInputEnvelope = {
    data: ApartmentAmenityCreateManyAmenityInput | ApartmentAmenityCreateManyAmenityInput[]
    skipDuplicates?: boolean
  }

  export type ApartmentAmenityUpsertWithWhereUniqueWithoutAmenityInput = {
    where: ApartmentAmenityWhereUniqueInput
    update: XOR<ApartmentAmenityUpdateWithoutAmenityInput, ApartmentAmenityUncheckedUpdateWithoutAmenityInput>
    create: XOR<ApartmentAmenityCreateWithoutAmenityInput, ApartmentAmenityUncheckedCreateWithoutAmenityInput>
  }

  export type ApartmentAmenityUpdateWithWhereUniqueWithoutAmenityInput = {
    where: ApartmentAmenityWhereUniqueInput
    data: XOR<ApartmentAmenityUpdateWithoutAmenityInput, ApartmentAmenityUncheckedUpdateWithoutAmenityInput>
  }

  export type ApartmentAmenityUpdateManyWithWhereWithoutAmenityInput = {
    where: ApartmentAmenityScalarWhereInput
    data: XOR<ApartmentAmenityUpdateManyMutationInput, ApartmentAmenityUncheckedUpdateManyWithoutAmenityInput>
  }

  export type ApartmentCreateWithoutApartment_amenitiesInput = {
    id?: string
    image?: string | null
    name?: string | null
    description?: string | null
    rules?: string | null
    number: number
    floor: number
    rooms_count: number
    max_capacity?: number | null
    is_available?: boolean
    is_smoking?: boolean
    is_pet_friendly?: boolean
    deposit?: number
    type: $Enums.ApartmentType
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    images?: ApartmentImageCreateNestedManyWithoutApartmentInput
    apartment_beds?: ApartmentBedCreateNestedManyWithoutApartmentInput
    reservations?: ReservationCreateNestedManyWithoutApartmentInput
    booking_variants?: BookingVariantCreateNestedManyWithoutApartmentInput
    reviews?: ReviewCreateNestedManyWithoutApartmentInput
  }

  export type ApartmentUncheckedCreateWithoutApartment_amenitiesInput = {
    id?: string
    image?: string | null
    name?: string | null
    description?: string | null
    rules?: string | null
    number: number
    floor: number
    rooms_count: number
    max_capacity?: number | null
    is_available?: boolean
    is_smoking?: boolean
    is_pet_friendly?: boolean
    deposit?: number
    type: $Enums.ApartmentType
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    images?: ApartmentImageUncheckedCreateNestedManyWithoutApartmentInput
    apartment_beds?: ApartmentBedUncheckedCreateNestedManyWithoutApartmentInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutApartmentInput
    booking_variants?: BookingVariantUncheckedCreateNestedManyWithoutApartmentInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutApartmentInput
  }

  export type ApartmentCreateOrConnectWithoutApartment_amenitiesInput = {
    where: ApartmentWhereUniqueInput
    create: XOR<ApartmentCreateWithoutApartment_amenitiesInput, ApartmentUncheckedCreateWithoutApartment_amenitiesInput>
  }

  export type AmenityCreateWithoutApartment_amenitiesInput = {
    id?: string
    name: string
    image: string
    description?: string | null
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type AmenityUncheckedCreateWithoutApartment_amenitiesInput = {
    id?: string
    name: string
    image: string
    description?: string | null
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type AmenityCreateOrConnectWithoutApartment_amenitiesInput = {
    where: AmenityWhereUniqueInput
    create: XOR<AmenityCreateWithoutApartment_amenitiesInput, AmenityUncheckedCreateWithoutApartment_amenitiesInput>
  }

  export type ApartmentUpsertWithoutApartment_amenitiesInput = {
    update: XOR<ApartmentUpdateWithoutApartment_amenitiesInput, ApartmentUncheckedUpdateWithoutApartment_amenitiesInput>
    create: XOR<ApartmentCreateWithoutApartment_amenitiesInput, ApartmentUncheckedCreateWithoutApartment_amenitiesInput>
    where?: ApartmentWhereInput
  }

  export type ApartmentUpdateToOneWithWhereWithoutApartment_amenitiesInput = {
    where?: ApartmentWhereInput
    data: XOR<ApartmentUpdateWithoutApartment_amenitiesInput, ApartmentUncheckedUpdateWithoutApartment_amenitiesInput>
  }

  export type ApartmentUpdateWithoutApartment_amenitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    number?: IntFieldUpdateOperationsInput | number
    floor?: IntFieldUpdateOperationsInput | number
    rooms_count?: IntFieldUpdateOperationsInput | number
    max_capacity?: NullableIntFieldUpdateOperationsInput | number | null
    is_available?: BoolFieldUpdateOperationsInput | boolean
    is_smoking?: BoolFieldUpdateOperationsInput | boolean
    is_pet_friendly?: BoolFieldUpdateOperationsInput | boolean
    deposit?: FloatFieldUpdateOperationsInput | number
    type?: EnumApartmentTypeFieldUpdateOperationsInput | $Enums.ApartmentType
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    images?: ApartmentImageUpdateManyWithoutApartmentNestedInput
    apartment_beds?: ApartmentBedUpdateManyWithoutApartmentNestedInput
    reservations?: ReservationUpdateManyWithoutApartmentNestedInput
    booking_variants?: BookingVariantUpdateManyWithoutApartmentNestedInput
    reviews?: ReviewUpdateManyWithoutApartmentNestedInput
  }

  export type ApartmentUncheckedUpdateWithoutApartment_amenitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    number?: IntFieldUpdateOperationsInput | number
    floor?: IntFieldUpdateOperationsInput | number
    rooms_count?: IntFieldUpdateOperationsInput | number
    max_capacity?: NullableIntFieldUpdateOperationsInput | number | null
    is_available?: BoolFieldUpdateOperationsInput | boolean
    is_smoking?: BoolFieldUpdateOperationsInput | boolean
    is_pet_friendly?: BoolFieldUpdateOperationsInput | boolean
    deposit?: FloatFieldUpdateOperationsInput | number
    type?: EnumApartmentTypeFieldUpdateOperationsInput | $Enums.ApartmentType
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    images?: ApartmentImageUncheckedUpdateManyWithoutApartmentNestedInput
    apartment_beds?: ApartmentBedUncheckedUpdateManyWithoutApartmentNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutApartmentNestedInput
    booking_variants?: BookingVariantUncheckedUpdateManyWithoutApartmentNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutApartmentNestedInput
  }

  export type AmenityUpsertWithoutApartment_amenitiesInput = {
    update: XOR<AmenityUpdateWithoutApartment_amenitiesInput, AmenityUncheckedUpdateWithoutApartment_amenitiesInput>
    create: XOR<AmenityCreateWithoutApartment_amenitiesInput, AmenityUncheckedCreateWithoutApartment_amenitiesInput>
    where?: AmenityWhereInput
  }

  export type AmenityUpdateToOneWithWhereWithoutApartment_amenitiesInput = {
    where?: AmenityWhereInput
    data: XOR<AmenityUpdateWithoutApartment_amenitiesInput, AmenityUncheckedUpdateWithoutApartment_amenitiesInput>
  }

  export type AmenityUpdateWithoutApartment_amenitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AmenityUncheckedUpdateWithoutApartment_amenitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ApartmentCreateWithoutImagesInput = {
    id?: string
    image?: string | null
    name?: string | null
    description?: string | null
    rules?: string | null
    number: number
    floor: number
    rooms_count: number
    max_capacity?: number | null
    is_available?: boolean
    is_smoking?: boolean
    is_pet_friendly?: boolean
    deposit?: number
    type: $Enums.ApartmentType
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    apartment_beds?: ApartmentBedCreateNestedManyWithoutApartmentInput
    apartment_amenities?: ApartmentAmenityCreateNestedManyWithoutApartmentInput
    reservations?: ReservationCreateNestedManyWithoutApartmentInput
    booking_variants?: BookingVariantCreateNestedManyWithoutApartmentInput
    reviews?: ReviewCreateNestedManyWithoutApartmentInput
  }

  export type ApartmentUncheckedCreateWithoutImagesInput = {
    id?: string
    image?: string | null
    name?: string | null
    description?: string | null
    rules?: string | null
    number: number
    floor: number
    rooms_count: number
    max_capacity?: number | null
    is_available?: boolean
    is_smoking?: boolean
    is_pet_friendly?: boolean
    deposit?: number
    type: $Enums.ApartmentType
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    apartment_beds?: ApartmentBedUncheckedCreateNestedManyWithoutApartmentInput
    apartment_amenities?: ApartmentAmenityUncheckedCreateNestedManyWithoutApartmentInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutApartmentInput
    booking_variants?: BookingVariantUncheckedCreateNestedManyWithoutApartmentInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutApartmentInput
  }

  export type ApartmentCreateOrConnectWithoutImagesInput = {
    where: ApartmentWhereUniqueInput
    create: XOR<ApartmentCreateWithoutImagesInput, ApartmentUncheckedCreateWithoutImagesInput>
  }

  export type ApartmentUpsertWithoutImagesInput = {
    update: XOR<ApartmentUpdateWithoutImagesInput, ApartmentUncheckedUpdateWithoutImagesInput>
    create: XOR<ApartmentCreateWithoutImagesInput, ApartmentUncheckedCreateWithoutImagesInput>
    where?: ApartmentWhereInput
  }

  export type ApartmentUpdateToOneWithWhereWithoutImagesInput = {
    where?: ApartmentWhereInput
    data: XOR<ApartmentUpdateWithoutImagesInput, ApartmentUncheckedUpdateWithoutImagesInput>
  }

  export type ApartmentUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    number?: IntFieldUpdateOperationsInput | number
    floor?: IntFieldUpdateOperationsInput | number
    rooms_count?: IntFieldUpdateOperationsInput | number
    max_capacity?: NullableIntFieldUpdateOperationsInput | number | null
    is_available?: BoolFieldUpdateOperationsInput | boolean
    is_smoking?: BoolFieldUpdateOperationsInput | boolean
    is_pet_friendly?: BoolFieldUpdateOperationsInput | boolean
    deposit?: FloatFieldUpdateOperationsInput | number
    type?: EnumApartmentTypeFieldUpdateOperationsInput | $Enums.ApartmentType
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    apartment_beds?: ApartmentBedUpdateManyWithoutApartmentNestedInput
    apartment_amenities?: ApartmentAmenityUpdateManyWithoutApartmentNestedInput
    reservations?: ReservationUpdateManyWithoutApartmentNestedInput
    booking_variants?: BookingVariantUpdateManyWithoutApartmentNestedInput
    reviews?: ReviewUpdateManyWithoutApartmentNestedInput
  }

  export type ApartmentUncheckedUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    number?: IntFieldUpdateOperationsInput | number
    floor?: IntFieldUpdateOperationsInput | number
    rooms_count?: IntFieldUpdateOperationsInput | number
    max_capacity?: NullableIntFieldUpdateOperationsInput | number | null
    is_available?: BoolFieldUpdateOperationsInput | boolean
    is_smoking?: BoolFieldUpdateOperationsInput | boolean
    is_pet_friendly?: BoolFieldUpdateOperationsInput | boolean
    deposit?: FloatFieldUpdateOperationsInput | number
    type?: EnumApartmentTypeFieldUpdateOperationsInput | $Enums.ApartmentType
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    apartment_beds?: ApartmentBedUncheckedUpdateManyWithoutApartmentNestedInput
    apartment_amenities?: ApartmentAmenityUncheckedUpdateManyWithoutApartmentNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutApartmentNestedInput
    booking_variants?: BookingVariantUncheckedUpdateManyWithoutApartmentNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutApartmentNestedInput
  }

  export type ApartmentBedCreateWithoutBed_typeInput = {
    id?: string
    count: number
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    apartment: ApartmentCreateNestedOneWithoutApartment_bedsInput
  }

  export type ApartmentBedUncheckedCreateWithoutBed_typeInput = {
    id?: string
    apartment_id: string
    count: number
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type ApartmentBedCreateOrConnectWithoutBed_typeInput = {
    where: ApartmentBedWhereUniqueInput
    create: XOR<ApartmentBedCreateWithoutBed_typeInput, ApartmentBedUncheckedCreateWithoutBed_typeInput>
  }

  export type ApartmentBedCreateManyBed_typeInputEnvelope = {
    data: ApartmentBedCreateManyBed_typeInput | ApartmentBedCreateManyBed_typeInput[]
    skipDuplicates?: boolean
  }

  export type ApartmentBedUpsertWithWhereUniqueWithoutBed_typeInput = {
    where: ApartmentBedWhereUniqueInput
    update: XOR<ApartmentBedUpdateWithoutBed_typeInput, ApartmentBedUncheckedUpdateWithoutBed_typeInput>
    create: XOR<ApartmentBedCreateWithoutBed_typeInput, ApartmentBedUncheckedCreateWithoutBed_typeInput>
  }

  export type ApartmentBedUpdateWithWhereUniqueWithoutBed_typeInput = {
    where: ApartmentBedWhereUniqueInput
    data: XOR<ApartmentBedUpdateWithoutBed_typeInput, ApartmentBedUncheckedUpdateWithoutBed_typeInput>
  }

  export type ApartmentBedUpdateManyWithWhereWithoutBed_typeInput = {
    where: ApartmentBedScalarWhereInput
    data: XOR<ApartmentBedUpdateManyMutationInput, ApartmentBedUncheckedUpdateManyWithoutBed_typeInput>
  }

  export type ApartmentCreateWithoutApartment_bedsInput = {
    id?: string
    image?: string | null
    name?: string | null
    description?: string | null
    rules?: string | null
    number: number
    floor: number
    rooms_count: number
    max_capacity?: number | null
    is_available?: boolean
    is_smoking?: boolean
    is_pet_friendly?: boolean
    deposit?: number
    type: $Enums.ApartmentType
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    images?: ApartmentImageCreateNestedManyWithoutApartmentInput
    apartment_amenities?: ApartmentAmenityCreateNestedManyWithoutApartmentInput
    reservations?: ReservationCreateNestedManyWithoutApartmentInput
    booking_variants?: BookingVariantCreateNestedManyWithoutApartmentInput
    reviews?: ReviewCreateNestedManyWithoutApartmentInput
  }

  export type ApartmentUncheckedCreateWithoutApartment_bedsInput = {
    id?: string
    image?: string | null
    name?: string | null
    description?: string | null
    rules?: string | null
    number: number
    floor: number
    rooms_count: number
    max_capacity?: number | null
    is_available?: boolean
    is_smoking?: boolean
    is_pet_friendly?: boolean
    deposit?: number
    type: $Enums.ApartmentType
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    images?: ApartmentImageUncheckedCreateNestedManyWithoutApartmentInput
    apartment_amenities?: ApartmentAmenityUncheckedCreateNestedManyWithoutApartmentInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutApartmentInput
    booking_variants?: BookingVariantUncheckedCreateNestedManyWithoutApartmentInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutApartmentInput
  }

  export type ApartmentCreateOrConnectWithoutApartment_bedsInput = {
    where: ApartmentWhereUniqueInput
    create: XOR<ApartmentCreateWithoutApartment_bedsInput, ApartmentUncheckedCreateWithoutApartment_bedsInput>
  }

  export type BedTypeCreateWithoutApartment_bedsInput = {
    id?: string
    name: string
    image: string
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type BedTypeUncheckedCreateWithoutApartment_bedsInput = {
    id?: string
    name: string
    image: string
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type BedTypeCreateOrConnectWithoutApartment_bedsInput = {
    where: BedTypeWhereUniqueInput
    create: XOR<BedTypeCreateWithoutApartment_bedsInput, BedTypeUncheckedCreateWithoutApartment_bedsInput>
  }

  export type ApartmentUpsertWithoutApartment_bedsInput = {
    update: XOR<ApartmentUpdateWithoutApartment_bedsInput, ApartmentUncheckedUpdateWithoutApartment_bedsInput>
    create: XOR<ApartmentCreateWithoutApartment_bedsInput, ApartmentUncheckedCreateWithoutApartment_bedsInput>
    where?: ApartmentWhereInput
  }

  export type ApartmentUpdateToOneWithWhereWithoutApartment_bedsInput = {
    where?: ApartmentWhereInput
    data: XOR<ApartmentUpdateWithoutApartment_bedsInput, ApartmentUncheckedUpdateWithoutApartment_bedsInput>
  }

  export type ApartmentUpdateWithoutApartment_bedsInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    number?: IntFieldUpdateOperationsInput | number
    floor?: IntFieldUpdateOperationsInput | number
    rooms_count?: IntFieldUpdateOperationsInput | number
    max_capacity?: NullableIntFieldUpdateOperationsInput | number | null
    is_available?: BoolFieldUpdateOperationsInput | boolean
    is_smoking?: BoolFieldUpdateOperationsInput | boolean
    is_pet_friendly?: BoolFieldUpdateOperationsInput | boolean
    deposit?: FloatFieldUpdateOperationsInput | number
    type?: EnumApartmentTypeFieldUpdateOperationsInput | $Enums.ApartmentType
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    images?: ApartmentImageUpdateManyWithoutApartmentNestedInput
    apartment_amenities?: ApartmentAmenityUpdateManyWithoutApartmentNestedInput
    reservations?: ReservationUpdateManyWithoutApartmentNestedInput
    booking_variants?: BookingVariantUpdateManyWithoutApartmentNestedInput
    reviews?: ReviewUpdateManyWithoutApartmentNestedInput
  }

  export type ApartmentUncheckedUpdateWithoutApartment_bedsInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    number?: IntFieldUpdateOperationsInput | number
    floor?: IntFieldUpdateOperationsInput | number
    rooms_count?: IntFieldUpdateOperationsInput | number
    max_capacity?: NullableIntFieldUpdateOperationsInput | number | null
    is_available?: BoolFieldUpdateOperationsInput | boolean
    is_smoking?: BoolFieldUpdateOperationsInput | boolean
    is_pet_friendly?: BoolFieldUpdateOperationsInput | boolean
    deposit?: FloatFieldUpdateOperationsInput | number
    type?: EnumApartmentTypeFieldUpdateOperationsInput | $Enums.ApartmentType
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    images?: ApartmentImageUncheckedUpdateManyWithoutApartmentNestedInput
    apartment_amenities?: ApartmentAmenityUncheckedUpdateManyWithoutApartmentNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutApartmentNestedInput
    booking_variants?: BookingVariantUncheckedUpdateManyWithoutApartmentNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutApartmentNestedInput
  }

  export type BedTypeUpsertWithoutApartment_bedsInput = {
    update: XOR<BedTypeUpdateWithoutApartment_bedsInput, BedTypeUncheckedUpdateWithoutApartment_bedsInput>
    create: XOR<BedTypeCreateWithoutApartment_bedsInput, BedTypeUncheckedCreateWithoutApartment_bedsInput>
    where?: BedTypeWhereInput
  }

  export type BedTypeUpdateToOneWithWhereWithoutApartment_bedsInput = {
    where?: BedTypeWhereInput
    data: XOR<BedTypeUpdateWithoutApartment_bedsInput, BedTypeUncheckedUpdateWithoutApartment_bedsInput>
  }

  export type BedTypeUpdateWithoutApartment_bedsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BedTypeUncheckedUpdateWithoutApartment_bedsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ApartmentCreateWithoutBooking_variantsInput = {
    id?: string
    image?: string | null
    name?: string | null
    description?: string | null
    rules?: string | null
    number: number
    floor: number
    rooms_count: number
    max_capacity?: number | null
    is_available?: boolean
    is_smoking?: boolean
    is_pet_friendly?: boolean
    deposit?: number
    type: $Enums.ApartmentType
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    images?: ApartmentImageCreateNestedManyWithoutApartmentInput
    apartment_beds?: ApartmentBedCreateNestedManyWithoutApartmentInput
    apartment_amenities?: ApartmentAmenityCreateNestedManyWithoutApartmentInput
    reservations?: ReservationCreateNestedManyWithoutApartmentInput
    reviews?: ReviewCreateNestedManyWithoutApartmentInput
  }

  export type ApartmentUncheckedCreateWithoutBooking_variantsInput = {
    id?: string
    image?: string | null
    name?: string | null
    description?: string | null
    rules?: string | null
    number: number
    floor: number
    rooms_count: number
    max_capacity?: number | null
    is_available?: boolean
    is_smoking?: boolean
    is_pet_friendly?: boolean
    deposit?: number
    type: $Enums.ApartmentType
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    images?: ApartmentImageUncheckedCreateNestedManyWithoutApartmentInput
    apartment_beds?: ApartmentBedUncheckedCreateNestedManyWithoutApartmentInput
    apartment_amenities?: ApartmentAmenityUncheckedCreateNestedManyWithoutApartmentInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutApartmentInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutApartmentInput
  }

  export type ApartmentCreateOrConnectWithoutBooking_variantsInput = {
    where: ApartmentWhereUniqueInput
    create: XOR<ApartmentCreateWithoutBooking_variantsInput, ApartmentUncheckedCreateWithoutBooking_variantsInput>
  }

  export type BookingCreateWithoutBooking_variantInput = {
    id?: string
    message?: string | null
    status?: $Enums.BookingStatus
    start: Date | string
    end: Date | string
    created?: Date | string
    updated?: Date | string
    user: UserCreateNestedOneWithoutBookingsInput
    transaction: TransactionCreateNestedOneWithoutBookingInput
    booking_events?: BookingEventCreateNestedManyWithoutBookingInput
    booking_additional_options?: BookingAdditionalOptionCreateNestedManyWithoutBookingInput
    reviews?: ReviewCreateNestedManyWithoutBookingInput
    messages?: MessageCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutBooking_variantInput = {
    id?: string
    user_id: string
    transaction_id: string
    message?: string | null
    status?: $Enums.BookingStatus
    start: Date | string
    end: Date | string
    created?: Date | string
    updated?: Date | string
    booking_events?: BookingEventUncheckedCreateNestedManyWithoutBookingInput
    booking_additional_options?: BookingAdditionalOptionUncheckedCreateNestedManyWithoutBookingInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBookingInput
    messages?: MessageUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutBooking_variantInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutBooking_variantInput, BookingUncheckedCreateWithoutBooking_variantInput>
  }

  export type BookingCreateManyBooking_variantInputEnvelope = {
    data: BookingCreateManyBooking_variantInput | BookingCreateManyBooking_variantInput[]
    skipDuplicates?: boolean
  }

  export type ApartmentUpsertWithoutBooking_variantsInput = {
    update: XOR<ApartmentUpdateWithoutBooking_variantsInput, ApartmentUncheckedUpdateWithoutBooking_variantsInput>
    create: XOR<ApartmentCreateWithoutBooking_variantsInput, ApartmentUncheckedCreateWithoutBooking_variantsInput>
    where?: ApartmentWhereInput
  }

  export type ApartmentUpdateToOneWithWhereWithoutBooking_variantsInput = {
    where?: ApartmentWhereInput
    data: XOR<ApartmentUpdateWithoutBooking_variantsInput, ApartmentUncheckedUpdateWithoutBooking_variantsInput>
  }

  export type ApartmentUpdateWithoutBooking_variantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    number?: IntFieldUpdateOperationsInput | number
    floor?: IntFieldUpdateOperationsInput | number
    rooms_count?: IntFieldUpdateOperationsInput | number
    max_capacity?: NullableIntFieldUpdateOperationsInput | number | null
    is_available?: BoolFieldUpdateOperationsInput | boolean
    is_smoking?: BoolFieldUpdateOperationsInput | boolean
    is_pet_friendly?: BoolFieldUpdateOperationsInput | boolean
    deposit?: FloatFieldUpdateOperationsInput | number
    type?: EnumApartmentTypeFieldUpdateOperationsInput | $Enums.ApartmentType
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    images?: ApartmentImageUpdateManyWithoutApartmentNestedInput
    apartment_beds?: ApartmentBedUpdateManyWithoutApartmentNestedInput
    apartment_amenities?: ApartmentAmenityUpdateManyWithoutApartmentNestedInput
    reservations?: ReservationUpdateManyWithoutApartmentNestedInput
    reviews?: ReviewUpdateManyWithoutApartmentNestedInput
  }

  export type ApartmentUncheckedUpdateWithoutBooking_variantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    number?: IntFieldUpdateOperationsInput | number
    floor?: IntFieldUpdateOperationsInput | number
    rooms_count?: IntFieldUpdateOperationsInput | number
    max_capacity?: NullableIntFieldUpdateOperationsInput | number | null
    is_available?: BoolFieldUpdateOperationsInput | boolean
    is_smoking?: BoolFieldUpdateOperationsInput | boolean
    is_pet_friendly?: BoolFieldUpdateOperationsInput | boolean
    deposit?: FloatFieldUpdateOperationsInput | number
    type?: EnumApartmentTypeFieldUpdateOperationsInput | $Enums.ApartmentType
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    images?: ApartmentImageUncheckedUpdateManyWithoutApartmentNestedInput
    apartment_beds?: ApartmentBedUncheckedUpdateManyWithoutApartmentNestedInput
    apartment_amenities?: ApartmentAmenityUncheckedUpdateManyWithoutApartmentNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutApartmentNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutApartmentNestedInput
  }

  export type BookingUpsertWithWhereUniqueWithoutBooking_variantInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutBooking_variantInput, BookingUncheckedUpdateWithoutBooking_variantInput>
    create: XOR<BookingCreateWithoutBooking_variantInput, BookingUncheckedCreateWithoutBooking_variantInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutBooking_variantInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutBooking_variantInput, BookingUncheckedUpdateWithoutBooking_variantInput>
  }

  export type BookingUpdateManyWithWhereWithoutBooking_variantInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutBooking_variantInput>
  }

  export type ApartmentCreateWithoutReservationsInput = {
    id?: string
    image?: string | null
    name?: string | null
    description?: string | null
    rules?: string | null
    number: number
    floor: number
    rooms_count: number
    max_capacity?: number | null
    is_available?: boolean
    is_smoking?: boolean
    is_pet_friendly?: boolean
    deposit?: number
    type: $Enums.ApartmentType
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    images?: ApartmentImageCreateNestedManyWithoutApartmentInput
    apartment_beds?: ApartmentBedCreateNestedManyWithoutApartmentInput
    apartment_amenities?: ApartmentAmenityCreateNestedManyWithoutApartmentInput
    booking_variants?: BookingVariantCreateNestedManyWithoutApartmentInput
    reviews?: ReviewCreateNestedManyWithoutApartmentInput
  }

  export type ApartmentUncheckedCreateWithoutReservationsInput = {
    id?: string
    image?: string | null
    name?: string | null
    description?: string | null
    rules?: string | null
    number: number
    floor: number
    rooms_count: number
    max_capacity?: number | null
    is_available?: boolean
    is_smoking?: boolean
    is_pet_friendly?: boolean
    deposit?: number
    type: $Enums.ApartmentType
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    images?: ApartmentImageUncheckedCreateNestedManyWithoutApartmentInput
    apartment_beds?: ApartmentBedUncheckedCreateNestedManyWithoutApartmentInput
    apartment_amenities?: ApartmentAmenityUncheckedCreateNestedManyWithoutApartmentInput
    booking_variants?: BookingVariantUncheckedCreateNestedManyWithoutApartmentInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutApartmentInput
  }

  export type ApartmentCreateOrConnectWithoutReservationsInput = {
    where: ApartmentWhereUniqueInput
    create: XOR<ApartmentCreateWithoutReservationsInput, ApartmentUncheckedCreateWithoutReservationsInput>
  }

  export type UserCreateWithoutReservationsInput = {
    id?: string
    email: string
    password_hash: string
    image?: string | null
    first_name: string
    last_name: string
    phone_number?: string | null
    date_of_birth?: Date | string | null
    is_active?: boolean
    email_verified?: boolean
    phone_verified?: boolean
    role?: $Enums.Role
    created?: Date | string
    updated?: Date | string
    events?: EventCreateNestedManyWithoutGuideInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    card_details?: CardDetailCreateNestedManyWithoutUserInput
    transfer_details?: TransferDetailCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    sent_messages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReservationsInput = {
    id?: string
    email: string
    password_hash: string
    image?: string | null
    first_name: string
    last_name: string
    phone_number?: string | null
    date_of_birth?: Date | string | null
    is_active?: boolean
    email_verified?: boolean
    phone_verified?: boolean
    role?: $Enums.Role
    created?: Date | string
    updated?: Date | string
    events?: EventUncheckedCreateNestedManyWithoutGuideInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    card_details?: CardDetailUncheckedCreateNestedManyWithoutUserInput
    transfer_details?: TransferDetailUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    sent_messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReservationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReservationsInput, UserUncheckedCreateWithoutReservationsInput>
  }

  export type ApartmentUpsertWithoutReservationsInput = {
    update: XOR<ApartmentUpdateWithoutReservationsInput, ApartmentUncheckedUpdateWithoutReservationsInput>
    create: XOR<ApartmentCreateWithoutReservationsInput, ApartmentUncheckedCreateWithoutReservationsInput>
    where?: ApartmentWhereInput
  }

  export type ApartmentUpdateToOneWithWhereWithoutReservationsInput = {
    where?: ApartmentWhereInput
    data: XOR<ApartmentUpdateWithoutReservationsInput, ApartmentUncheckedUpdateWithoutReservationsInput>
  }

  export type ApartmentUpdateWithoutReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    number?: IntFieldUpdateOperationsInput | number
    floor?: IntFieldUpdateOperationsInput | number
    rooms_count?: IntFieldUpdateOperationsInput | number
    max_capacity?: NullableIntFieldUpdateOperationsInput | number | null
    is_available?: BoolFieldUpdateOperationsInput | boolean
    is_smoking?: BoolFieldUpdateOperationsInput | boolean
    is_pet_friendly?: BoolFieldUpdateOperationsInput | boolean
    deposit?: FloatFieldUpdateOperationsInput | number
    type?: EnumApartmentTypeFieldUpdateOperationsInput | $Enums.ApartmentType
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    images?: ApartmentImageUpdateManyWithoutApartmentNestedInput
    apartment_beds?: ApartmentBedUpdateManyWithoutApartmentNestedInput
    apartment_amenities?: ApartmentAmenityUpdateManyWithoutApartmentNestedInput
    booking_variants?: BookingVariantUpdateManyWithoutApartmentNestedInput
    reviews?: ReviewUpdateManyWithoutApartmentNestedInput
  }

  export type ApartmentUncheckedUpdateWithoutReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    number?: IntFieldUpdateOperationsInput | number
    floor?: IntFieldUpdateOperationsInput | number
    rooms_count?: IntFieldUpdateOperationsInput | number
    max_capacity?: NullableIntFieldUpdateOperationsInput | number | null
    is_available?: BoolFieldUpdateOperationsInput | boolean
    is_smoking?: BoolFieldUpdateOperationsInput | boolean
    is_pet_friendly?: BoolFieldUpdateOperationsInput | boolean
    deposit?: FloatFieldUpdateOperationsInput | number
    type?: EnumApartmentTypeFieldUpdateOperationsInput | $Enums.ApartmentType
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    images?: ApartmentImageUncheckedUpdateManyWithoutApartmentNestedInput
    apartment_beds?: ApartmentBedUncheckedUpdateManyWithoutApartmentNestedInput
    apartment_amenities?: ApartmentAmenityUncheckedUpdateManyWithoutApartmentNestedInput
    booking_variants?: BookingVariantUncheckedUpdateManyWithoutApartmentNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutApartmentNestedInput
  }

  export type UserUpsertWithoutReservationsInput = {
    update: XOR<UserUpdateWithoutReservationsInput, UserUncheckedUpdateWithoutReservationsInput>
    create: XOR<UserCreateWithoutReservationsInput, UserUncheckedCreateWithoutReservationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReservationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReservationsInput, UserUncheckedUpdateWithoutReservationsInput>
  }

  export type UserUpdateWithoutReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    phone_verified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUpdateManyWithoutGuideNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    card_details?: CardDetailUpdateManyWithoutUserNestedInput
    transfer_details?: TransferDetailUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    sent_messages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    phone_verified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUncheckedUpdateManyWithoutGuideNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    card_details?: CardDetailUncheckedUpdateManyWithoutUserNestedInput
    transfer_details?: TransferDetailUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    sent_messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BookingVariantCreateWithoutBookingsInput = {
    id?: string
    price: number
    capacity: number
    is_available?: boolean
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    apartment: ApartmentCreateNestedOneWithoutBooking_variantsInput
  }

  export type BookingVariantUncheckedCreateWithoutBookingsInput = {
    id?: string
    apartment_id: string
    price: number
    capacity: number
    is_available?: boolean
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type BookingVariantCreateOrConnectWithoutBookingsInput = {
    where: BookingVariantWhereUniqueInput
    create: XOR<BookingVariantCreateWithoutBookingsInput, BookingVariantUncheckedCreateWithoutBookingsInput>
  }

  export type UserCreateWithoutBookingsInput = {
    id?: string
    email: string
    password_hash: string
    image?: string | null
    first_name: string
    last_name: string
    phone_number?: string | null
    date_of_birth?: Date | string | null
    is_active?: boolean
    email_verified?: boolean
    phone_verified?: boolean
    role?: $Enums.Role
    created?: Date | string
    updated?: Date | string
    reservations?: ReservationCreateNestedManyWithoutUserInput
    events?: EventCreateNestedManyWithoutGuideInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    card_details?: CardDetailCreateNestedManyWithoutUserInput
    transfer_details?: TransferDetailCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    sent_messages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBookingsInput = {
    id?: string
    email: string
    password_hash: string
    image?: string | null
    first_name: string
    last_name: string
    phone_number?: string | null
    date_of_birth?: Date | string | null
    is_active?: boolean
    email_verified?: boolean
    phone_verified?: boolean
    role?: $Enums.Role
    created?: Date | string
    updated?: Date | string
    reservations?: ReservationUncheckedCreateNestedManyWithoutUserInput
    events?: EventUncheckedCreateNestedManyWithoutGuideInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    card_details?: CardDetailUncheckedCreateNestedManyWithoutUserInput
    transfer_details?: TransferDetailUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    sent_messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBookingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
  }

  export type TransactionCreateWithoutBookingInput = {
    id?: string
    amount: number
    description: string
    transaction_type: $Enums.TransactionType
    transaction_status: $Enums.TransactionStatus
    payment_method: $Enums.PaymentMethod
    created?: Date | string
    updated?: Date | string
    user: UserCreateNestedOneWithoutTransactionsInput
    card_detail?: CardDetailCreateNestedOneWithoutTransactionsInput
    transfer_detail?: TransferDetailCreateNestedOneWithoutTransactionsInput
    booking_event?: BookingEventCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutBookingInput = {
    id?: string
    amount: number
    user_id: string
    description: string
    card_details_id?: string | null
    transfer_details_id?: string | null
    transaction_type: $Enums.TransactionType
    transaction_status: $Enums.TransactionStatus
    payment_method: $Enums.PaymentMethod
    created?: Date | string
    updated?: Date | string
    booking_event?: BookingEventUncheckedCreateNestedOneWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutBookingInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutBookingInput, TransactionUncheckedCreateWithoutBookingInput>
  }

  export type BookingEventCreateWithoutBookingInput = {
    id?: string
    number_of_people: number
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    event: EventCreateNestedOneWithoutBooking_eventsInput
    transaction: TransactionCreateNestedOneWithoutBooking_eventInput
  }

  export type BookingEventUncheckedCreateWithoutBookingInput = {
    id?: string
    number_of_people: number
    event_id: string
    transaction_id: string
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type BookingEventCreateOrConnectWithoutBookingInput = {
    where: BookingEventWhereUniqueInput
    create: XOR<BookingEventCreateWithoutBookingInput, BookingEventUncheckedCreateWithoutBookingInput>
  }

  export type BookingEventCreateManyBookingInputEnvelope = {
    data: BookingEventCreateManyBookingInput | BookingEventCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type BookingAdditionalOptionCreateWithoutBookingInput = {
    id?: string
    amount: number
    created?: Date | string
    updated?: Date | string
    additional_option: AdditionalOptionCreateNestedOneWithoutBooking_additional_optionsInput
  }

  export type BookingAdditionalOptionUncheckedCreateWithoutBookingInput = {
    id?: string
    amount: number
    option_id: string
    created?: Date | string
    updated?: Date | string
  }

  export type BookingAdditionalOptionCreateOrConnectWithoutBookingInput = {
    where: BookingAdditionalOptionWhereUniqueInput
    create: XOR<BookingAdditionalOptionCreateWithoutBookingInput, BookingAdditionalOptionUncheckedCreateWithoutBookingInput>
  }

  export type BookingAdditionalOptionCreateManyBookingInputEnvelope = {
    data: BookingAdditionalOptionCreateManyBookingInput | BookingAdditionalOptionCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutBookingInput = {
    id?: string
    rating: number
    comment?: string | null
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    user: UserCreateNestedOneWithoutReviewsInput
    apartment?: ApartmentCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutBookingInput = {
    id?: string
    user_id: string
    apartment_id?: string | null
    rating: number
    comment?: string | null
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type ReviewCreateOrConnectWithoutBookingInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutBookingInput, ReviewUncheckedCreateWithoutBookingInput>
  }

  export type ReviewCreateManyBookingInputEnvelope = {
    data: ReviewCreateManyBookingInput | ReviewCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutBookingInput = {
    id?: string
    receiver_id: string
    message: string
    is_read?: boolean
    edited?: Date | string | null
    is_excluded?: boolean
    created?: Date | string
    updated?: Date | string
    sender: UserCreateNestedOneWithoutSent_messagesInput
    replaces?: MessageCreateNestedOneWithoutReplaced_byInput
    replaced_by?: MessageCreateNestedManyWithoutReplacesInput
  }

  export type MessageUncheckedCreateWithoutBookingInput = {
    id?: string
    sender_id: string
    receiver_id: string
    message: string
    is_read?: boolean
    edited?: Date | string | null
    replace_to?: string | null
    is_excluded?: boolean
    created?: Date | string
    updated?: Date | string
    replaced_by?: MessageUncheckedCreateNestedManyWithoutReplacesInput
  }

  export type MessageCreateOrConnectWithoutBookingInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutBookingInput, MessageUncheckedCreateWithoutBookingInput>
  }

  export type MessageCreateManyBookingInputEnvelope = {
    data: MessageCreateManyBookingInput | MessageCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type BookingVariantUpsertWithoutBookingsInput = {
    update: XOR<BookingVariantUpdateWithoutBookingsInput, BookingVariantUncheckedUpdateWithoutBookingsInput>
    create: XOR<BookingVariantCreateWithoutBookingsInput, BookingVariantUncheckedCreateWithoutBookingsInput>
    where?: BookingVariantWhereInput
  }

  export type BookingVariantUpdateToOneWithWhereWithoutBookingsInput = {
    where?: BookingVariantWhereInput
    data: XOR<BookingVariantUpdateWithoutBookingsInput, BookingVariantUncheckedUpdateWithoutBookingsInput>
  }

  export type BookingVariantUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    is_available?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    apartment?: ApartmentUpdateOneRequiredWithoutBooking_variantsNestedInput
  }

  export type BookingVariantUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    apartment_id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    is_available?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUpsertWithoutBookingsInput = {
    update: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBookingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type UserUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    phone_verified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUpdateManyWithoutUserNestedInput
    events?: EventUpdateManyWithoutGuideNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    card_details?: CardDetailUpdateManyWithoutUserNestedInput
    transfer_details?: TransferDetailUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    sent_messages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    phone_verified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUncheckedUpdateManyWithoutUserNestedInput
    events?: EventUncheckedUpdateManyWithoutGuideNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    card_details?: CardDetailUncheckedUpdateManyWithoutUserNestedInput
    transfer_details?: TransferDetailUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    sent_messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TransactionUpsertWithoutBookingInput = {
    update: XOR<TransactionUpdateWithoutBookingInput, TransactionUncheckedUpdateWithoutBookingInput>
    create: XOR<TransactionCreateWithoutBookingInput, TransactionUncheckedCreateWithoutBookingInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutBookingInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutBookingInput, TransactionUncheckedUpdateWithoutBookingInput>
  }

  export type TransactionUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    transaction_type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transaction_status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    card_detail?: CardDetailUpdateOneWithoutTransactionsNestedInput
    transfer_detail?: TransferDetailUpdateOneWithoutTransactionsNestedInput
    booking_event?: BookingEventUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    card_details_id?: NullableStringFieldUpdateOperationsInput | string | null
    transfer_details_id?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transaction_status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_event?: BookingEventUncheckedUpdateOneWithoutTransactionNestedInput
  }

  export type BookingEventUpsertWithWhereUniqueWithoutBookingInput = {
    where: BookingEventWhereUniqueInput
    update: XOR<BookingEventUpdateWithoutBookingInput, BookingEventUncheckedUpdateWithoutBookingInput>
    create: XOR<BookingEventCreateWithoutBookingInput, BookingEventUncheckedCreateWithoutBookingInput>
  }

  export type BookingEventUpdateWithWhereUniqueWithoutBookingInput = {
    where: BookingEventWhereUniqueInput
    data: XOR<BookingEventUpdateWithoutBookingInput, BookingEventUncheckedUpdateWithoutBookingInput>
  }

  export type BookingEventUpdateManyWithWhereWithoutBookingInput = {
    where: BookingEventScalarWhereInput
    data: XOR<BookingEventUpdateManyMutationInput, BookingEventUncheckedUpdateManyWithoutBookingInput>
  }

  export type BookingEventScalarWhereInput = {
    AND?: BookingEventScalarWhereInput | BookingEventScalarWhereInput[]
    OR?: BookingEventScalarWhereInput[]
    NOT?: BookingEventScalarWhereInput | BookingEventScalarWhereInput[]
    id?: StringFilter<"BookingEvent"> | string
    number_of_people?: IntFilter<"BookingEvent"> | number
    booking_id?: StringFilter<"BookingEvent"> | string
    event_id?: StringFilter<"BookingEvent"> | string
    transaction_id?: StringFilter<"BookingEvent"> | string
    created?: DateTimeFilter<"BookingEvent"> | Date | string
    updated?: DateTimeFilter<"BookingEvent"> | Date | string
    is_excluded?: BoolFilter<"BookingEvent"> | boolean
  }

  export type BookingAdditionalOptionUpsertWithWhereUniqueWithoutBookingInput = {
    where: BookingAdditionalOptionWhereUniqueInput
    update: XOR<BookingAdditionalOptionUpdateWithoutBookingInput, BookingAdditionalOptionUncheckedUpdateWithoutBookingInput>
    create: XOR<BookingAdditionalOptionCreateWithoutBookingInput, BookingAdditionalOptionUncheckedCreateWithoutBookingInput>
  }

  export type BookingAdditionalOptionUpdateWithWhereUniqueWithoutBookingInput = {
    where: BookingAdditionalOptionWhereUniqueInput
    data: XOR<BookingAdditionalOptionUpdateWithoutBookingInput, BookingAdditionalOptionUncheckedUpdateWithoutBookingInput>
  }

  export type BookingAdditionalOptionUpdateManyWithWhereWithoutBookingInput = {
    where: BookingAdditionalOptionScalarWhereInput
    data: XOR<BookingAdditionalOptionUpdateManyMutationInput, BookingAdditionalOptionUncheckedUpdateManyWithoutBookingInput>
  }

  export type BookingAdditionalOptionScalarWhereInput = {
    AND?: BookingAdditionalOptionScalarWhereInput | BookingAdditionalOptionScalarWhereInput[]
    OR?: BookingAdditionalOptionScalarWhereInput[]
    NOT?: BookingAdditionalOptionScalarWhereInput | BookingAdditionalOptionScalarWhereInput[]
    id?: StringFilter<"BookingAdditionalOption"> | string
    amount?: IntFilter<"BookingAdditionalOption"> | number
    option_id?: StringFilter<"BookingAdditionalOption"> | string
    booking_id?: StringFilter<"BookingAdditionalOption"> | string
    created?: DateTimeFilter<"BookingAdditionalOption"> | Date | string
    updated?: DateTimeFilter<"BookingAdditionalOption"> | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutBookingInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutBookingInput, ReviewUncheckedUpdateWithoutBookingInput>
    create: XOR<ReviewCreateWithoutBookingInput, ReviewUncheckedCreateWithoutBookingInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutBookingInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutBookingInput, ReviewUncheckedUpdateWithoutBookingInput>
  }

  export type ReviewUpdateManyWithWhereWithoutBookingInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutBookingInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutBookingInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutBookingInput, MessageUncheckedUpdateWithoutBookingInput>
    create: XOR<MessageCreateWithoutBookingInput, MessageUncheckedCreateWithoutBookingInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutBookingInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutBookingInput, MessageUncheckedUpdateWithoutBookingInput>
  }

  export type MessageUpdateManyWithWhereWithoutBookingInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutBookingInput>
  }

  export type BookingAdditionalOptionCreateWithoutAdditional_optionInput = {
    id?: string
    amount: number
    created?: Date | string
    updated?: Date | string
    booking: BookingCreateNestedOneWithoutBooking_additional_optionsInput
  }

  export type BookingAdditionalOptionUncheckedCreateWithoutAdditional_optionInput = {
    id?: string
    amount: number
    booking_id: string
    created?: Date | string
    updated?: Date | string
  }

  export type BookingAdditionalOptionCreateOrConnectWithoutAdditional_optionInput = {
    where: BookingAdditionalOptionWhereUniqueInput
    create: XOR<BookingAdditionalOptionCreateWithoutAdditional_optionInput, BookingAdditionalOptionUncheckedCreateWithoutAdditional_optionInput>
  }

  export type BookingAdditionalOptionCreateManyAdditional_optionInputEnvelope = {
    data: BookingAdditionalOptionCreateManyAdditional_optionInput | BookingAdditionalOptionCreateManyAdditional_optionInput[]
    skipDuplicates?: boolean
  }

  export type BookingAdditionalOptionUpsertWithWhereUniqueWithoutAdditional_optionInput = {
    where: BookingAdditionalOptionWhereUniqueInput
    update: XOR<BookingAdditionalOptionUpdateWithoutAdditional_optionInput, BookingAdditionalOptionUncheckedUpdateWithoutAdditional_optionInput>
    create: XOR<BookingAdditionalOptionCreateWithoutAdditional_optionInput, BookingAdditionalOptionUncheckedCreateWithoutAdditional_optionInput>
  }

  export type BookingAdditionalOptionUpdateWithWhereUniqueWithoutAdditional_optionInput = {
    where: BookingAdditionalOptionWhereUniqueInput
    data: XOR<BookingAdditionalOptionUpdateWithoutAdditional_optionInput, BookingAdditionalOptionUncheckedUpdateWithoutAdditional_optionInput>
  }

  export type BookingAdditionalOptionUpdateManyWithWhereWithoutAdditional_optionInput = {
    where: BookingAdditionalOptionScalarWhereInput
    data: XOR<BookingAdditionalOptionUpdateManyMutationInput, BookingAdditionalOptionUncheckedUpdateManyWithoutAdditional_optionInput>
  }

  export type BookingCreateWithoutBooking_additional_optionsInput = {
    id?: string
    message?: string | null
    status?: $Enums.BookingStatus
    start: Date | string
    end: Date | string
    created?: Date | string
    updated?: Date | string
    booking_variant: BookingVariantCreateNestedOneWithoutBookingsInput
    user: UserCreateNestedOneWithoutBookingsInput
    transaction: TransactionCreateNestedOneWithoutBookingInput
    booking_events?: BookingEventCreateNestedManyWithoutBookingInput
    reviews?: ReviewCreateNestedManyWithoutBookingInput
    messages?: MessageCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutBooking_additional_optionsInput = {
    id?: string
    user_id: string
    booking_variant_id: string
    transaction_id: string
    message?: string | null
    status?: $Enums.BookingStatus
    start: Date | string
    end: Date | string
    created?: Date | string
    updated?: Date | string
    booking_events?: BookingEventUncheckedCreateNestedManyWithoutBookingInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBookingInput
    messages?: MessageUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutBooking_additional_optionsInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutBooking_additional_optionsInput, BookingUncheckedCreateWithoutBooking_additional_optionsInput>
  }

  export type AdditionalOptionCreateWithoutBooking_additional_optionsInput = {
    id?: string
    name: string
    description: string
    image: string
    price: number
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type AdditionalOptionUncheckedCreateWithoutBooking_additional_optionsInput = {
    id?: string
    name: string
    description: string
    image: string
    price: number
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type AdditionalOptionCreateOrConnectWithoutBooking_additional_optionsInput = {
    where: AdditionalOptionWhereUniqueInput
    create: XOR<AdditionalOptionCreateWithoutBooking_additional_optionsInput, AdditionalOptionUncheckedCreateWithoutBooking_additional_optionsInput>
  }

  export type BookingUpsertWithoutBooking_additional_optionsInput = {
    update: XOR<BookingUpdateWithoutBooking_additional_optionsInput, BookingUncheckedUpdateWithoutBooking_additional_optionsInput>
    create: XOR<BookingCreateWithoutBooking_additional_optionsInput, BookingUncheckedCreateWithoutBooking_additional_optionsInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutBooking_additional_optionsInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutBooking_additional_optionsInput, BookingUncheckedUpdateWithoutBooking_additional_optionsInput>
  }

  export type BookingUpdateWithoutBooking_additional_optionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_variant?: BookingVariantUpdateOneRequiredWithoutBookingsNestedInput
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutBookingNestedInput
    booking_events?: BookingEventUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUpdateManyWithoutBookingNestedInput
    messages?: MessageUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutBooking_additional_optionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    booking_variant_id?: StringFieldUpdateOperationsInput | string
    transaction_id?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_events?: BookingEventUncheckedUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBookingNestedInput
    messages?: MessageUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type AdditionalOptionUpsertWithoutBooking_additional_optionsInput = {
    update: XOR<AdditionalOptionUpdateWithoutBooking_additional_optionsInput, AdditionalOptionUncheckedUpdateWithoutBooking_additional_optionsInput>
    create: XOR<AdditionalOptionCreateWithoutBooking_additional_optionsInput, AdditionalOptionUncheckedCreateWithoutBooking_additional_optionsInput>
    where?: AdditionalOptionWhereInput
  }

  export type AdditionalOptionUpdateToOneWithWhereWithoutBooking_additional_optionsInput = {
    where?: AdditionalOptionWhereInput
    data: XOR<AdditionalOptionUpdateWithoutBooking_additional_optionsInput, AdditionalOptionUncheckedUpdateWithoutBooking_additional_optionsInput>
  }

  export type AdditionalOptionUpdateWithoutBooking_additional_optionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdditionalOptionUncheckedUpdateWithoutBooking_additional_optionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BookingCreateWithoutBooking_eventsInput = {
    id?: string
    message?: string | null
    status?: $Enums.BookingStatus
    start: Date | string
    end: Date | string
    created?: Date | string
    updated?: Date | string
    booking_variant: BookingVariantCreateNestedOneWithoutBookingsInput
    user: UserCreateNestedOneWithoutBookingsInput
    transaction: TransactionCreateNestedOneWithoutBookingInput
    booking_additional_options?: BookingAdditionalOptionCreateNestedManyWithoutBookingInput
    reviews?: ReviewCreateNestedManyWithoutBookingInput
    messages?: MessageCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutBooking_eventsInput = {
    id?: string
    user_id: string
    booking_variant_id: string
    transaction_id: string
    message?: string | null
    status?: $Enums.BookingStatus
    start: Date | string
    end: Date | string
    created?: Date | string
    updated?: Date | string
    booking_additional_options?: BookingAdditionalOptionUncheckedCreateNestedManyWithoutBookingInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBookingInput
    messages?: MessageUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutBooking_eventsInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutBooking_eventsInput, BookingUncheckedCreateWithoutBooking_eventsInput>
  }

  export type EventCreateWithoutBooking_eventsInput = {
    id?: string
    name: string
    image: string
    description: string
    price: number
    capacity: number
    start: Date | string
    end: Date | string
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    guide?: UserCreateNestedOneWithoutEventsInput
    images?: EventImageCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutBooking_eventsInput = {
    id?: string
    name: string
    image: string
    description: string
    guide_id?: string | null
    price: number
    capacity: number
    start: Date | string
    end: Date | string
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    images?: EventImageUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutBooking_eventsInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutBooking_eventsInput, EventUncheckedCreateWithoutBooking_eventsInput>
  }

  export type TransactionCreateWithoutBooking_eventInput = {
    id?: string
    amount: number
    description: string
    transaction_type: $Enums.TransactionType
    transaction_status: $Enums.TransactionStatus
    payment_method: $Enums.PaymentMethod
    created?: Date | string
    updated?: Date | string
    user: UserCreateNestedOneWithoutTransactionsInput
    card_detail?: CardDetailCreateNestedOneWithoutTransactionsInput
    transfer_detail?: TransferDetailCreateNestedOneWithoutTransactionsInput
    booking?: BookingCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutBooking_eventInput = {
    id?: string
    amount: number
    user_id: string
    description: string
    card_details_id?: string | null
    transfer_details_id?: string | null
    transaction_type: $Enums.TransactionType
    transaction_status: $Enums.TransactionStatus
    payment_method: $Enums.PaymentMethod
    created?: Date | string
    updated?: Date | string
    booking?: BookingUncheckedCreateNestedOneWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutBooking_eventInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutBooking_eventInput, TransactionUncheckedCreateWithoutBooking_eventInput>
  }

  export type BookingUpsertWithoutBooking_eventsInput = {
    update: XOR<BookingUpdateWithoutBooking_eventsInput, BookingUncheckedUpdateWithoutBooking_eventsInput>
    create: XOR<BookingCreateWithoutBooking_eventsInput, BookingUncheckedCreateWithoutBooking_eventsInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutBooking_eventsInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutBooking_eventsInput, BookingUncheckedUpdateWithoutBooking_eventsInput>
  }

  export type BookingUpdateWithoutBooking_eventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_variant?: BookingVariantUpdateOneRequiredWithoutBookingsNestedInput
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutBookingNestedInput
    booking_additional_options?: BookingAdditionalOptionUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUpdateManyWithoutBookingNestedInput
    messages?: MessageUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutBooking_eventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    booking_variant_id?: StringFieldUpdateOperationsInput | string
    transaction_id?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_additional_options?: BookingAdditionalOptionUncheckedUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBookingNestedInput
    messages?: MessageUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type EventUpsertWithoutBooking_eventsInput = {
    update: XOR<EventUpdateWithoutBooking_eventsInput, EventUncheckedUpdateWithoutBooking_eventsInput>
    create: XOR<EventCreateWithoutBooking_eventsInput, EventUncheckedCreateWithoutBooking_eventsInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutBooking_eventsInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutBooking_eventsInput, EventUncheckedUpdateWithoutBooking_eventsInput>
  }

  export type EventUpdateWithoutBooking_eventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    guide?: UserUpdateOneWithoutEventsNestedInput
    images?: EventImageUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutBooking_eventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    guide_id?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    images?: EventImageUncheckedUpdateManyWithoutEventNestedInput
  }

  export type TransactionUpsertWithoutBooking_eventInput = {
    update: XOR<TransactionUpdateWithoutBooking_eventInput, TransactionUncheckedUpdateWithoutBooking_eventInput>
    create: XOR<TransactionCreateWithoutBooking_eventInput, TransactionUncheckedCreateWithoutBooking_eventInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutBooking_eventInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutBooking_eventInput, TransactionUncheckedUpdateWithoutBooking_eventInput>
  }

  export type TransactionUpdateWithoutBooking_eventInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    transaction_type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transaction_status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    card_detail?: CardDetailUpdateOneWithoutTransactionsNestedInput
    transfer_detail?: TransferDetailUpdateOneWithoutTransactionsNestedInput
    booking?: BookingUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutBooking_eventInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    card_details_id?: NullableStringFieldUpdateOperationsInput | string | null
    transfer_details_id?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transaction_status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUncheckedUpdateOneWithoutTransactionNestedInput
  }

  export type UserCreateWithoutTransactionsInput = {
    id?: string
    email: string
    password_hash: string
    image?: string | null
    first_name: string
    last_name: string
    phone_number?: string | null
    date_of_birth?: Date | string | null
    is_active?: boolean
    email_verified?: boolean
    phone_verified?: boolean
    role?: $Enums.Role
    created?: Date | string
    updated?: Date | string
    reservations?: ReservationCreateNestedManyWithoutUserInput
    events?: EventCreateNestedManyWithoutGuideInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    card_details?: CardDetailCreateNestedManyWithoutUserInput
    transfer_details?: TransferDetailCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    sent_messages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTransactionsInput = {
    id?: string
    email: string
    password_hash: string
    image?: string | null
    first_name: string
    last_name: string
    phone_number?: string | null
    date_of_birth?: Date | string | null
    is_active?: boolean
    email_verified?: boolean
    phone_verified?: boolean
    role?: $Enums.Role
    created?: Date | string
    updated?: Date | string
    reservations?: ReservationUncheckedCreateNestedManyWithoutUserInput
    events?: EventUncheckedCreateNestedManyWithoutGuideInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    card_details?: CardDetailUncheckedCreateNestedManyWithoutUserInput
    transfer_details?: TransferDetailUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    sent_messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTransactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
  }

  export type CardDetailCreateWithoutTransactionsInput = {
    id?: string
    number: string
    expiry_month: number
    expiry_year: number
    holder: string
    token: string
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    user: UserCreateNestedOneWithoutCard_detailsInput
  }

  export type CardDetailUncheckedCreateWithoutTransactionsInput = {
    id?: string
    user_id: string
    number: string
    expiry_month: number
    expiry_year: number
    holder: string
    token: string
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type CardDetailCreateOrConnectWithoutTransactionsInput = {
    where: CardDetailWhereUniqueInput
    create: XOR<CardDetailCreateWithoutTransactionsInput, CardDetailUncheckedCreateWithoutTransactionsInput>
  }

  export type TransferDetailCreateWithoutTransactionsInput = {
    id?: string
    bank_name: string
    account_number: string
    swift: string
    payer_name: string
    created?: Date | string
    updated?: Date | string
    user: UserCreateNestedOneWithoutTransfer_detailsInput
  }

  export type TransferDetailUncheckedCreateWithoutTransactionsInput = {
    id?: string
    bank_name: string
    account_number: string
    swift: string
    payer_name: string
    user_id: string
    created?: Date | string
    updated?: Date | string
  }

  export type TransferDetailCreateOrConnectWithoutTransactionsInput = {
    where: TransferDetailWhereUniqueInput
    create: XOR<TransferDetailCreateWithoutTransactionsInput, TransferDetailUncheckedCreateWithoutTransactionsInput>
  }

  export type BookingCreateWithoutTransactionInput = {
    id?: string
    message?: string | null
    status?: $Enums.BookingStatus
    start: Date | string
    end: Date | string
    created?: Date | string
    updated?: Date | string
    booking_variant: BookingVariantCreateNestedOneWithoutBookingsInput
    user: UserCreateNestedOneWithoutBookingsInput
    booking_events?: BookingEventCreateNestedManyWithoutBookingInput
    booking_additional_options?: BookingAdditionalOptionCreateNestedManyWithoutBookingInput
    reviews?: ReviewCreateNestedManyWithoutBookingInput
    messages?: MessageCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutTransactionInput = {
    id?: string
    user_id: string
    booking_variant_id: string
    message?: string | null
    status?: $Enums.BookingStatus
    start: Date | string
    end: Date | string
    created?: Date | string
    updated?: Date | string
    booking_events?: BookingEventUncheckedCreateNestedManyWithoutBookingInput
    booking_additional_options?: BookingAdditionalOptionUncheckedCreateNestedManyWithoutBookingInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBookingInput
    messages?: MessageUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutTransactionInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutTransactionInput, BookingUncheckedCreateWithoutTransactionInput>
  }

  export type BookingEventCreateWithoutTransactionInput = {
    id?: string
    number_of_people: number
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    booking: BookingCreateNestedOneWithoutBooking_eventsInput
    event: EventCreateNestedOneWithoutBooking_eventsInput
  }

  export type BookingEventUncheckedCreateWithoutTransactionInput = {
    id?: string
    number_of_people: number
    booking_id: string
    event_id: string
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type BookingEventCreateOrConnectWithoutTransactionInput = {
    where: BookingEventWhereUniqueInput
    create: XOR<BookingEventCreateWithoutTransactionInput, BookingEventUncheckedCreateWithoutTransactionInput>
  }

  export type UserUpsertWithoutTransactionsInput = {
    update: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    phone_verified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUpdateManyWithoutUserNestedInput
    events?: EventUpdateManyWithoutGuideNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    card_details?: CardDetailUpdateManyWithoutUserNestedInput
    transfer_details?: TransferDetailUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    sent_messages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    phone_verified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUncheckedUpdateManyWithoutUserNestedInput
    events?: EventUncheckedUpdateManyWithoutGuideNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    card_details?: CardDetailUncheckedUpdateManyWithoutUserNestedInput
    transfer_details?: TransferDetailUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    sent_messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CardDetailUpsertWithoutTransactionsInput = {
    update: XOR<CardDetailUpdateWithoutTransactionsInput, CardDetailUncheckedUpdateWithoutTransactionsInput>
    create: XOR<CardDetailCreateWithoutTransactionsInput, CardDetailUncheckedCreateWithoutTransactionsInput>
    where?: CardDetailWhereInput
  }

  export type CardDetailUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: CardDetailWhereInput
    data: XOR<CardDetailUpdateWithoutTransactionsInput, CardDetailUncheckedUpdateWithoutTransactionsInput>
  }

  export type CardDetailUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    expiry_month?: IntFieldUpdateOperationsInput | number
    expiry_year?: IntFieldUpdateOperationsInput | number
    holder?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutCard_detailsNestedInput
  }

  export type CardDetailUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    expiry_month?: IntFieldUpdateOperationsInput | number
    expiry_year?: IntFieldUpdateOperationsInput | number
    holder?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TransferDetailUpsertWithoutTransactionsInput = {
    update: XOR<TransferDetailUpdateWithoutTransactionsInput, TransferDetailUncheckedUpdateWithoutTransactionsInput>
    create: XOR<TransferDetailCreateWithoutTransactionsInput, TransferDetailUncheckedCreateWithoutTransactionsInput>
    where?: TransferDetailWhereInput
  }

  export type TransferDetailUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: TransferDetailWhereInput
    data: XOR<TransferDetailUpdateWithoutTransactionsInput, TransferDetailUncheckedUpdateWithoutTransactionsInput>
  }

  export type TransferDetailUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bank_name?: StringFieldUpdateOperationsInput | string
    account_number?: StringFieldUpdateOperationsInput | string
    swift?: StringFieldUpdateOperationsInput | string
    payer_name?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTransfer_detailsNestedInput
  }

  export type TransferDetailUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bank_name?: StringFieldUpdateOperationsInput | string
    account_number?: StringFieldUpdateOperationsInput | string
    swift?: StringFieldUpdateOperationsInput | string
    payer_name?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUpsertWithoutTransactionInput = {
    update: XOR<BookingUpdateWithoutTransactionInput, BookingUncheckedUpdateWithoutTransactionInput>
    create: XOR<BookingCreateWithoutTransactionInput, BookingUncheckedCreateWithoutTransactionInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutTransactionInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutTransactionInput, BookingUncheckedUpdateWithoutTransactionInput>
  }

  export type BookingUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_variant?: BookingVariantUpdateOneRequiredWithoutBookingsNestedInput
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    booking_events?: BookingEventUpdateManyWithoutBookingNestedInput
    booking_additional_options?: BookingAdditionalOptionUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUpdateManyWithoutBookingNestedInput
    messages?: MessageUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    booking_variant_id?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_events?: BookingEventUncheckedUpdateManyWithoutBookingNestedInput
    booking_additional_options?: BookingAdditionalOptionUncheckedUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBookingNestedInput
    messages?: MessageUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingEventUpsertWithoutTransactionInput = {
    update: XOR<BookingEventUpdateWithoutTransactionInput, BookingEventUncheckedUpdateWithoutTransactionInput>
    create: XOR<BookingEventCreateWithoutTransactionInput, BookingEventUncheckedCreateWithoutTransactionInput>
    where?: BookingEventWhereInput
  }

  export type BookingEventUpdateToOneWithWhereWithoutTransactionInput = {
    where?: BookingEventWhereInput
    data: XOR<BookingEventUpdateWithoutTransactionInput, BookingEventUncheckedUpdateWithoutTransactionInput>
  }

  export type BookingEventUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    number_of_people?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    booking?: BookingUpdateOneRequiredWithoutBooking_eventsNestedInput
    event?: EventUpdateOneRequiredWithoutBooking_eventsNestedInput
  }

  export type BookingEventUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    number_of_people?: IntFieldUpdateOperationsInput | number
    booking_id?: StringFieldUpdateOperationsInput | string
    event_id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TransactionCreateWithoutTransfer_detailInput = {
    id?: string
    amount: number
    description: string
    transaction_type: $Enums.TransactionType
    transaction_status: $Enums.TransactionStatus
    payment_method: $Enums.PaymentMethod
    created?: Date | string
    updated?: Date | string
    user: UserCreateNestedOneWithoutTransactionsInput
    card_detail?: CardDetailCreateNestedOneWithoutTransactionsInput
    booking?: BookingCreateNestedOneWithoutTransactionInput
    booking_event?: BookingEventCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutTransfer_detailInput = {
    id?: string
    amount: number
    user_id: string
    description: string
    card_details_id?: string | null
    transaction_type: $Enums.TransactionType
    transaction_status: $Enums.TransactionStatus
    payment_method: $Enums.PaymentMethod
    created?: Date | string
    updated?: Date | string
    booking?: BookingUncheckedCreateNestedOneWithoutTransactionInput
    booking_event?: BookingEventUncheckedCreateNestedOneWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutTransfer_detailInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutTransfer_detailInput, TransactionUncheckedCreateWithoutTransfer_detailInput>
  }

  export type TransactionCreateManyTransfer_detailInputEnvelope = {
    data: TransactionCreateManyTransfer_detailInput | TransactionCreateManyTransfer_detailInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutTransfer_detailsInput = {
    id?: string
    email: string
    password_hash: string
    image?: string | null
    first_name: string
    last_name: string
    phone_number?: string | null
    date_of_birth?: Date | string | null
    is_active?: boolean
    email_verified?: boolean
    phone_verified?: boolean
    role?: $Enums.Role
    created?: Date | string
    updated?: Date | string
    reservations?: ReservationCreateNestedManyWithoutUserInput
    events?: EventCreateNestedManyWithoutGuideInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    card_details?: CardDetailCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    sent_messages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTransfer_detailsInput = {
    id?: string
    email: string
    password_hash: string
    image?: string | null
    first_name: string
    last_name: string
    phone_number?: string | null
    date_of_birth?: Date | string | null
    is_active?: boolean
    email_verified?: boolean
    phone_verified?: boolean
    role?: $Enums.Role
    created?: Date | string
    updated?: Date | string
    reservations?: ReservationUncheckedCreateNestedManyWithoutUserInput
    events?: EventUncheckedCreateNestedManyWithoutGuideInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    card_details?: CardDetailUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    sent_messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTransfer_detailsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransfer_detailsInput, UserUncheckedCreateWithoutTransfer_detailsInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutTransfer_detailInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutTransfer_detailInput, TransactionUncheckedUpdateWithoutTransfer_detailInput>
    create: XOR<TransactionCreateWithoutTransfer_detailInput, TransactionUncheckedCreateWithoutTransfer_detailInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutTransfer_detailInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutTransfer_detailInput, TransactionUncheckedUpdateWithoutTransfer_detailInput>
  }

  export type TransactionUpdateManyWithWhereWithoutTransfer_detailInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutTransfer_detailInput>
  }

  export type UserUpsertWithoutTransfer_detailsInput = {
    update: XOR<UserUpdateWithoutTransfer_detailsInput, UserUncheckedUpdateWithoutTransfer_detailsInput>
    create: XOR<UserCreateWithoutTransfer_detailsInput, UserUncheckedCreateWithoutTransfer_detailsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTransfer_detailsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTransfer_detailsInput, UserUncheckedUpdateWithoutTransfer_detailsInput>
  }

  export type UserUpdateWithoutTransfer_detailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    phone_verified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUpdateManyWithoutUserNestedInput
    events?: EventUpdateManyWithoutGuideNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    card_details?: CardDetailUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    sent_messages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTransfer_detailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    phone_verified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUncheckedUpdateManyWithoutUserNestedInput
    events?: EventUncheckedUpdateManyWithoutGuideNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    card_details?: CardDetailUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    sent_messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TransactionCreateWithoutCard_detailInput = {
    id?: string
    amount: number
    description: string
    transaction_type: $Enums.TransactionType
    transaction_status: $Enums.TransactionStatus
    payment_method: $Enums.PaymentMethod
    created?: Date | string
    updated?: Date | string
    user: UserCreateNestedOneWithoutTransactionsInput
    transfer_detail?: TransferDetailCreateNestedOneWithoutTransactionsInput
    booking?: BookingCreateNestedOneWithoutTransactionInput
    booking_event?: BookingEventCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutCard_detailInput = {
    id?: string
    amount: number
    user_id: string
    description: string
    transfer_details_id?: string | null
    transaction_type: $Enums.TransactionType
    transaction_status: $Enums.TransactionStatus
    payment_method: $Enums.PaymentMethod
    created?: Date | string
    updated?: Date | string
    booking?: BookingUncheckedCreateNestedOneWithoutTransactionInput
    booking_event?: BookingEventUncheckedCreateNestedOneWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutCard_detailInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutCard_detailInput, TransactionUncheckedCreateWithoutCard_detailInput>
  }

  export type TransactionCreateManyCard_detailInputEnvelope = {
    data: TransactionCreateManyCard_detailInput | TransactionCreateManyCard_detailInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCard_detailsInput = {
    id?: string
    email: string
    password_hash: string
    image?: string | null
    first_name: string
    last_name: string
    phone_number?: string | null
    date_of_birth?: Date | string | null
    is_active?: boolean
    email_verified?: boolean
    phone_verified?: boolean
    role?: $Enums.Role
    created?: Date | string
    updated?: Date | string
    reservations?: ReservationCreateNestedManyWithoutUserInput
    events?: EventCreateNestedManyWithoutGuideInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    transfer_details?: TransferDetailCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    sent_messages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCard_detailsInput = {
    id?: string
    email: string
    password_hash: string
    image?: string | null
    first_name: string
    last_name: string
    phone_number?: string | null
    date_of_birth?: Date | string | null
    is_active?: boolean
    email_verified?: boolean
    phone_verified?: boolean
    role?: $Enums.Role
    created?: Date | string
    updated?: Date | string
    reservations?: ReservationUncheckedCreateNestedManyWithoutUserInput
    events?: EventUncheckedCreateNestedManyWithoutGuideInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    transfer_details?: TransferDetailUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    sent_messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCard_detailsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCard_detailsInput, UserUncheckedCreateWithoutCard_detailsInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutCard_detailInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutCard_detailInput, TransactionUncheckedUpdateWithoutCard_detailInput>
    create: XOR<TransactionCreateWithoutCard_detailInput, TransactionUncheckedCreateWithoutCard_detailInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutCard_detailInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutCard_detailInput, TransactionUncheckedUpdateWithoutCard_detailInput>
  }

  export type TransactionUpdateManyWithWhereWithoutCard_detailInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutCard_detailInput>
  }

  export type UserUpsertWithoutCard_detailsInput = {
    update: XOR<UserUpdateWithoutCard_detailsInput, UserUncheckedUpdateWithoutCard_detailsInput>
    create: XOR<UserCreateWithoutCard_detailsInput, UserUncheckedCreateWithoutCard_detailsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCard_detailsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCard_detailsInput, UserUncheckedUpdateWithoutCard_detailsInput>
  }

  export type UserUpdateWithoutCard_detailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    phone_verified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUpdateManyWithoutUserNestedInput
    events?: EventUpdateManyWithoutGuideNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    transfer_details?: TransferDetailUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    sent_messages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCard_detailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    phone_verified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUncheckedUpdateManyWithoutUserNestedInput
    events?: EventUncheckedUpdateManyWithoutGuideNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    transfer_details?: TransferDetailUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    sent_messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutEventsInput = {
    id?: string
    email: string
    password_hash: string
    image?: string | null
    first_name: string
    last_name: string
    phone_number?: string | null
    date_of_birth?: Date | string | null
    is_active?: boolean
    email_verified?: boolean
    phone_verified?: boolean
    role?: $Enums.Role
    created?: Date | string
    updated?: Date | string
    reservations?: ReservationCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    card_details?: CardDetailCreateNestedManyWithoutUserInput
    transfer_details?: TransferDetailCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    sent_messages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEventsInput = {
    id?: string
    email: string
    password_hash: string
    image?: string | null
    first_name: string
    last_name: string
    phone_number?: string | null
    date_of_birth?: Date | string | null
    is_active?: boolean
    email_verified?: boolean
    phone_verified?: boolean
    role?: $Enums.Role
    created?: Date | string
    updated?: Date | string
    reservations?: ReservationUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    card_details?: CardDetailUncheckedCreateNestedManyWithoutUserInput
    transfer_details?: TransferDetailUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    sent_messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEventsInput, UserUncheckedCreateWithoutEventsInput>
  }

  export type EventImageCreateWithoutEventInput = {
    id?: string
    name: string
    image?: string | null
    description?: string | null
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type EventImageUncheckedCreateWithoutEventInput = {
    id?: string
    name: string
    image?: string | null
    description?: string | null
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type EventImageCreateOrConnectWithoutEventInput = {
    where: EventImageWhereUniqueInput
    create: XOR<EventImageCreateWithoutEventInput, EventImageUncheckedCreateWithoutEventInput>
  }

  export type EventImageCreateManyEventInputEnvelope = {
    data: EventImageCreateManyEventInput | EventImageCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type BookingEventCreateWithoutEventInput = {
    id?: string
    number_of_people: number
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    booking: BookingCreateNestedOneWithoutBooking_eventsInput
    transaction: TransactionCreateNestedOneWithoutBooking_eventInput
  }

  export type BookingEventUncheckedCreateWithoutEventInput = {
    id?: string
    number_of_people: number
    booking_id: string
    transaction_id: string
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type BookingEventCreateOrConnectWithoutEventInput = {
    where: BookingEventWhereUniqueInput
    create: XOR<BookingEventCreateWithoutEventInput, BookingEventUncheckedCreateWithoutEventInput>
  }

  export type BookingEventCreateManyEventInputEnvelope = {
    data: BookingEventCreateManyEventInput | BookingEventCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutEventsInput = {
    update: XOR<UserUpdateWithoutEventsInput, UserUncheckedUpdateWithoutEventsInput>
    create: XOR<UserCreateWithoutEventsInput, UserUncheckedCreateWithoutEventsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEventsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEventsInput, UserUncheckedUpdateWithoutEventsInput>
  }

  export type UserUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    phone_verified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    card_details?: CardDetailUpdateManyWithoutUserNestedInput
    transfer_details?: TransferDetailUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    sent_messages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    phone_verified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    card_details?: CardDetailUncheckedUpdateManyWithoutUserNestedInput
    transfer_details?: TransferDetailUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    sent_messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EventImageUpsertWithWhereUniqueWithoutEventInput = {
    where: EventImageWhereUniqueInput
    update: XOR<EventImageUpdateWithoutEventInput, EventImageUncheckedUpdateWithoutEventInput>
    create: XOR<EventImageCreateWithoutEventInput, EventImageUncheckedCreateWithoutEventInput>
  }

  export type EventImageUpdateWithWhereUniqueWithoutEventInput = {
    where: EventImageWhereUniqueInput
    data: XOR<EventImageUpdateWithoutEventInput, EventImageUncheckedUpdateWithoutEventInput>
  }

  export type EventImageUpdateManyWithWhereWithoutEventInput = {
    where: EventImageScalarWhereInput
    data: XOR<EventImageUpdateManyMutationInput, EventImageUncheckedUpdateManyWithoutEventInput>
  }

  export type EventImageScalarWhereInput = {
    AND?: EventImageScalarWhereInput | EventImageScalarWhereInput[]
    OR?: EventImageScalarWhereInput[]
    NOT?: EventImageScalarWhereInput | EventImageScalarWhereInput[]
    id?: StringFilter<"EventImage"> | string
    name?: StringFilter<"EventImage"> | string
    image?: StringNullableFilter<"EventImage"> | string | null
    description?: StringNullableFilter<"EventImage"> | string | null
    event_id?: StringFilter<"EventImage"> | string
    created?: DateTimeFilter<"EventImage"> | Date | string
    updated?: DateTimeFilter<"EventImage"> | Date | string
    is_excluded?: BoolFilter<"EventImage"> | boolean
  }

  export type BookingEventUpsertWithWhereUniqueWithoutEventInput = {
    where: BookingEventWhereUniqueInput
    update: XOR<BookingEventUpdateWithoutEventInput, BookingEventUncheckedUpdateWithoutEventInput>
    create: XOR<BookingEventCreateWithoutEventInput, BookingEventUncheckedCreateWithoutEventInput>
  }

  export type BookingEventUpdateWithWhereUniqueWithoutEventInput = {
    where: BookingEventWhereUniqueInput
    data: XOR<BookingEventUpdateWithoutEventInput, BookingEventUncheckedUpdateWithoutEventInput>
  }

  export type BookingEventUpdateManyWithWhereWithoutEventInput = {
    where: BookingEventScalarWhereInput
    data: XOR<BookingEventUpdateManyMutationInput, BookingEventUncheckedUpdateManyWithoutEventInput>
  }

  export type EventCreateWithoutImagesInput = {
    id?: string
    name: string
    image: string
    description: string
    price: number
    capacity: number
    start: Date | string
    end: Date | string
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    guide?: UserCreateNestedOneWithoutEventsInput
    booking_events?: BookingEventCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutImagesInput = {
    id?: string
    name: string
    image: string
    description: string
    guide_id?: string | null
    price: number
    capacity: number
    start: Date | string
    end: Date | string
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
    booking_events?: BookingEventUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutImagesInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutImagesInput, EventUncheckedCreateWithoutImagesInput>
  }

  export type EventUpsertWithoutImagesInput = {
    update: XOR<EventUpdateWithoutImagesInput, EventUncheckedUpdateWithoutImagesInput>
    create: XOR<EventCreateWithoutImagesInput, EventUncheckedCreateWithoutImagesInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutImagesInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutImagesInput, EventUncheckedUpdateWithoutImagesInput>
  }

  export type EventUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    guide?: UserUpdateOneWithoutEventsNestedInput
    booking_events?: BookingEventUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    guide_id?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    booking_events?: BookingEventUncheckedUpdateManyWithoutEventNestedInput
  }

  export type ReservationCreateManyUserInput = {
    id?: string
    apartment_id: string
    start: Date | string
    end: Date | string
    created?: Date | string
    updated?: Date | string
  }

  export type EventCreateManyGuideInput = {
    id?: string
    name: string
    image: string
    description: string
    price: number
    capacity: number
    start: Date | string
    end: Date | string
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type BookingCreateManyUserInput = {
    id?: string
    booking_variant_id: string
    transaction_id: string
    message?: string | null
    status?: $Enums.BookingStatus
    start: Date | string
    end: Date | string
    created?: Date | string
    updated?: Date | string
  }

  export type TransactionCreateManyUserInput = {
    id?: string
    amount: number
    description: string
    card_details_id?: string | null
    transfer_details_id?: string | null
    transaction_type: $Enums.TransactionType
    transaction_status: $Enums.TransactionStatus
    payment_method: $Enums.PaymentMethod
    created?: Date | string
    updated?: Date | string
  }

  export type CardDetailCreateManyUserInput = {
    id?: string
    number: string
    expiry_month: number
    expiry_year: number
    holder: string
    token: string
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type TransferDetailCreateManyUserInput = {
    id?: string
    bank_name: string
    account_number: string
    swift: string
    payer_name: string
    created?: Date | string
    updated?: Date | string
  }

  export type ReviewCreateManyUserInput = {
    id?: string
    apartment_id?: string | null
    booking_id?: string | null
    rating: number
    comment?: string | null
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type MessageCreateManySenderInput = {
    id?: string
    receiver_id: string
    message: string
    is_read?: boolean
    booking_id?: string | null
    edited?: Date | string | null
    replace_to?: string | null
    is_excluded?: boolean
    created?: Date | string
    updated?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type: $Enums.NotificationType
    action?: $Enums.NotificationAction
    message?: string | null
    is_read?: boolean
    created?: Date | string
    updated?: Date | string
  }

  export type ReservationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment?: ApartmentUpdateOneRequiredWithoutReservationsNestedInput
  }

  export type ReservationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    apartment_id?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    apartment_id?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUpdateWithoutGuideInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    images?: EventImageUpdateManyWithoutEventNestedInput
    booking_events?: BookingEventUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutGuideInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    images?: EventImageUncheckedUpdateManyWithoutEventNestedInput
    booking_events?: BookingEventUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateManyWithoutGuideInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BookingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_variant?: BookingVariantUpdateOneRequiredWithoutBookingsNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutBookingNestedInput
    booking_events?: BookingEventUpdateManyWithoutBookingNestedInput
    booking_additional_options?: BookingAdditionalOptionUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUpdateManyWithoutBookingNestedInput
    messages?: MessageUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    booking_variant_id?: StringFieldUpdateOperationsInput | string
    transaction_id?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_events?: BookingEventUncheckedUpdateManyWithoutBookingNestedInput
    booking_additional_options?: BookingAdditionalOptionUncheckedUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBookingNestedInput
    messages?: MessageUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    booking_variant_id?: StringFieldUpdateOperationsInput | string
    transaction_id?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    transaction_type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transaction_status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    card_detail?: CardDetailUpdateOneWithoutTransactionsNestedInput
    transfer_detail?: TransferDetailUpdateOneWithoutTransactionsNestedInput
    booking?: BookingUpdateOneWithoutTransactionNestedInput
    booking_event?: BookingEventUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    card_details_id?: NullableStringFieldUpdateOperationsInput | string | null
    transfer_details_id?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transaction_status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUncheckedUpdateOneWithoutTransactionNestedInput
    booking_event?: BookingEventUncheckedUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    card_details_id?: NullableStringFieldUpdateOperationsInput | string | null
    transfer_details_id?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transaction_status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CardDetailUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    expiry_month?: IntFieldUpdateOperationsInput | number
    expiry_year?: IntFieldUpdateOperationsInput | number
    holder?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    transactions?: TransactionUpdateManyWithoutCard_detailNestedInput
  }

  export type CardDetailUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    expiry_month?: IntFieldUpdateOperationsInput | number
    expiry_year?: IntFieldUpdateOperationsInput | number
    holder?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    transactions?: TransactionUncheckedUpdateManyWithoutCard_detailNestedInput
  }

  export type CardDetailUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    expiry_month?: IntFieldUpdateOperationsInput | number
    expiry_year?: IntFieldUpdateOperationsInput | number
    holder?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TransferDetailUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bank_name?: StringFieldUpdateOperationsInput | string
    account_number?: StringFieldUpdateOperationsInput | string
    swift?: StringFieldUpdateOperationsInput | string
    payer_name?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutTransfer_detailNestedInput
  }

  export type TransferDetailUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bank_name?: StringFieldUpdateOperationsInput | string
    account_number?: StringFieldUpdateOperationsInput | string
    swift?: StringFieldUpdateOperationsInput | string
    payer_name?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutTransfer_detailNestedInput
  }

  export type TransferDetailUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bank_name?: StringFieldUpdateOperationsInput | string
    account_number?: StringFieldUpdateOperationsInput | string
    swift?: StringFieldUpdateOperationsInput | string
    payer_name?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    apartment?: ApartmentUpdateOneWithoutReviewsNestedInput
    booking?: BookingUpdateOneWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    apartment_id?: NullableStringFieldUpdateOperationsInput | string | null
    booking_id?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReviewUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    apartment_id?: NullableStringFieldUpdateOperationsInput | string | null
    booking_id?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiver_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    edited?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneWithoutMessagesNestedInput
    replaces?: MessageUpdateOneWithoutReplaced_byNestedInput
    replaced_by?: MessageUpdateManyWithoutReplacesNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiver_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    booking_id?: NullableStringFieldUpdateOperationsInput | string | null
    edited?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replace_to?: NullableStringFieldUpdateOperationsInput | string | null
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    replaced_by?: MessageUncheckedUpdateManyWithoutReplacesNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiver_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    booking_id?: NullableStringFieldUpdateOperationsInput | string | null
    edited?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replace_to?: NullableStringFieldUpdateOperationsInput | string | null
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    action?: EnumNotificationActionFieldUpdateOperationsInput | $Enums.NotificationAction
    message?: NullableStringFieldUpdateOperationsInput | string | null
    is_read?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    action?: EnumNotificationActionFieldUpdateOperationsInput | $Enums.NotificationAction
    message?: NullableStringFieldUpdateOperationsInput | string | null
    is_read?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    action?: EnumNotificationActionFieldUpdateOperationsInput | $Enums.NotificationAction
    message?: NullableStringFieldUpdateOperationsInput | string | null
    is_read?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyReplacesInput = {
    id?: string
    sender_id: string
    receiver_id: string
    message: string
    is_read?: boolean
    booking_id?: string | null
    edited?: Date | string | null
    is_excluded?: boolean
    created?: Date | string
    updated?: Date | string
  }

  export type MessageUpdateWithoutReplacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiver_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    edited?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSent_messagesNestedInput
    booking?: BookingUpdateOneWithoutMessagesNestedInput
    replaced_by?: MessageUpdateManyWithoutReplacesNestedInput
  }

  export type MessageUncheckedUpdateWithoutReplacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sender_id?: StringFieldUpdateOperationsInput | string
    receiver_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    booking_id?: NullableStringFieldUpdateOperationsInput | string | null
    edited?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    replaced_by?: MessageUncheckedUpdateManyWithoutReplacesNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutReplacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sender_id?: StringFieldUpdateOperationsInput | string
    receiver_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    booking_id?: NullableStringFieldUpdateOperationsInput | string | null
    edited?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApartmentImageCreateManyApartmentInput = {
    id?: string
    image: string
    name?: string | null
    description?: string | null
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type ApartmentBedCreateManyApartmentInput = {
    id?: string
    bed_type_id: string
    count: number
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type ApartmentAmenityCreateManyApartmentInput = {
    id?: string
    amenity_id: string
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type ReservationCreateManyApartmentInput = {
    id?: string
    user_id: string
    start: Date | string
    end: Date | string
    created?: Date | string
    updated?: Date | string
  }

  export type BookingVariantCreateManyApartmentInput = {
    id?: string
    price: number
    capacity: number
    is_available?: boolean
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type ReviewCreateManyApartmentInput = {
    id?: string
    user_id: string
    booking_id?: string | null
    rating: number
    comment?: string | null
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type ApartmentImageUpdateWithoutApartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ApartmentImageUncheckedUpdateWithoutApartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ApartmentImageUncheckedUpdateManyWithoutApartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ApartmentBedUpdateWithoutApartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    bed_type?: BedTypeUpdateOneRequiredWithoutApartment_bedsNestedInput
  }

  export type ApartmentBedUncheckedUpdateWithoutApartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    bed_type_id?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ApartmentBedUncheckedUpdateManyWithoutApartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    bed_type_id?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ApartmentAmenityUpdateWithoutApartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    amenity?: AmenityUpdateOneRequiredWithoutApartment_amenitiesNestedInput
  }

  export type ApartmentAmenityUncheckedUpdateWithoutApartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    amenity_id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ApartmentAmenityUncheckedUpdateManyWithoutApartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    amenity_id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReservationUpdateWithoutApartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReservationsNestedInput
  }

  export type ReservationUncheckedUpdateWithoutApartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationUncheckedUpdateManyWithoutApartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingVariantUpdateWithoutApartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    is_available?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    bookings?: BookingUpdateManyWithoutBooking_variantNestedInput
  }

  export type BookingVariantUncheckedUpdateWithoutApartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    is_available?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    bookings?: BookingUncheckedUpdateManyWithoutBooking_variantNestedInput
  }

  export type BookingVariantUncheckedUpdateManyWithoutApartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    is_available?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReviewUpdateWithoutApartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
    booking?: BookingUpdateOneWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutApartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    booking_id?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReviewUncheckedUpdateManyWithoutApartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    booking_id?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ApartmentAmenityCreateManyAmenityInput = {
    id?: string
    apartment_id: string
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type ApartmentAmenityUpdateWithoutAmenityInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    apartment?: ApartmentUpdateOneRequiredWithoutApartment_amenitiesNestedInput
  }

  export type ApartmentAmenityUncheckedUpdateWithoutAmenityInput = {
    id?: StringFieldUpdateOperationsInput | string
    apartment_id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ApartmentAmenityUncheckedUpdateManyWithoutAmenityInput = {
    id?: StringFieldUpdateOperationsInput | string
    apartment_id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ApartmentBedCreateManyBed_typeInput = {
    id?: string
    apartment_id: string
    count: number
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type ApartmentBedUpdateWithoutBed_typeInput = {
    id?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    apartment?: ApartmentUpdateOneRequiredWithoutApartment_bedsNestedInput
  }

  export type ApartmentBedUncheckedUpdateWithoutBed_typeInput = {
    id?: StringFieldUpdateOperationsInput | string
    apartment_id?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ApartmentBedUncheckedUpdateManyWithoutBed_typeInput = {
    id?: StringFieldUpdateOperationsInput | string
    apartment_id?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BookingCreateManyBooking_variantInput = {
    id?: string
    user_id: string
    transaction_id: string
    message?: string | null
    status?: $Enums.BookingStatus
    start: Date | string
    end: Date | string
    created?: Date | string
    updated?: Date | string
  }

  export type BookingUpdateWithoutBooking_variantInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutBookingNestedInput
    booking_events?: BookingEventUpdateManyWithoutBookingNestedInput
    booking_additional_options?: BookingAdditionalOptionUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUpdateManyWithoutBookingNestedInput
    messages?: MessageUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutBooking_variantInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    transaction_id?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_events?: BookingEventUncheckedUpdateManyWithoutBookingNestedInput
    booking_additional_options?: BookingAdditionalOptionUncheckedUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBookingNestedInput
    messages?: MessageUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutBooking_variantInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    transaction_id?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingEventCreateManyBookingInput = {
    id?: string
    number_of_people: number
    event_id: string
    transaction_id: string
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type BookingAdditionalOptionCreateManyBookingInput = {
    id?: string
    amount: number
    option_id: string
    created?: Date | string
    updated?: Date | string
  }

  export type ReviewCreateManyBookingInput = {
    id?: string
    user_id: string
    apartment_id?: string | null
    rating: number
    comment?: string | null
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type MessageCreateManyBookingInput = {
    id?: string
    sender_id: string
    receiver_id: string
    message: string
    is_read?: boolean
    edited?: Date | string | null
    replace_to?: string | null
    is_excluded?: boolean
    created?: Date | string
    updated?: Date | string
  }

  export type BookingEventUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    number_of_people?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    event?: EventUpdateOneRequiredWithoutBooking_eventsNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutBooking_eventNestedInput
  }

  export type BookingEventUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    number_of_people?: IntFieldUpdateOperationsInput | number
    event_id?: StringFieldUpdateOperationsInput | string
    transaction_id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BookingEventUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    number_of_people?: IntFieldUpdateOperationsInput | number
    event_id?: StringFieldUpdateOperationsInput | string
    transaction_id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BookingAdditionalOptionUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    additional_option?: AdditionalOptionUpdateOneRequiredWithoutBooking_additional_optionsNestedInput
  }

  export type BookingAdditionalOptionUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    option_id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingAdditionalOptionUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    option_id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
    apartment?: ApartmentUpdateOneWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    apartment_id?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReviewUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    apartment_id?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MessageUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiver_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    edited?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSent_messagesNestedInput
    replaces?: MessageUpdateOneWithoutReplaced_byNestedInput
    replaced_by?: MessageUpdateManyWithoutReplacesNestedInput
  }

  export type MessageUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    sender_id?: StringFieldUpdateOperationsInput | string
    receiver_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    edited?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replace_to?: NullableStringFieldUpdateOperationsInput | string | null
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    replaced_by?: MessageUncheckedUpdateManyWithoutReplacesNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    sender_id?: StringFieldUpdateOperationsInput | string
    receiver_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    edited?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replace_to?: NullableStringFieldUpdateOperationsInput | string | null
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingAdditionalOptionCreateManyAdditional_optionInput = {
    id?: string
    amount: number
    booking_id: string
    created?: Date | string
    updated?: Date | string
  }

  export type BookingAdditionalOptionUpdateWithoutAdditional_optionInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutBooking_additional_optionsNestedInput
  }

  export type BookingAdditionalOptionUncheckedUpdateWithoutAdditional_optionInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    booking_id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingAdditionalOptionUncheckedUpdateManyWithoutAdditional_optionInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    booking_id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyTransfer_detailInput = {
    id?: string
    amount: number
    user_id: string
    description: string
    card_details_id?: string | null
    transaction_type: $Enums.TransactionType
    transaction_status: $Enums.TransactionStatus
    payment_method: $Enums.PaymentMethod
    created?: Date | string
    updated?: Date | string
  }

  export type TransactionUpdateWithoutTransfer_detailInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    transaction_type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transaction_status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    card_detail?: CardDetailUpdateOneWithoutTransactionsNestedInput
    booking?: BookingUpdateOneWithoutTransactionNestedInput
    booking_event?: BookingEventUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutTransfer_detailInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    card_details_id?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transaction_status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUncheckedUpdateOneWithoutTransactionNestedInput
    booking_event?: BookingEventUncheckedUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutTransfer_detailInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    card_details_id?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transaction_status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyCard_detailInput = {
    id?: string
    amount: number
    user_id: string
    description: string
    transfer_details_id?: string | null
    transaction_type: $Enums.TransactionType
    transaction_status: $Enums.TransactionStatus
    payment_method: $Enums.PaymentMethod
    created?: Date | string
    updated?: Date | string
  }

  export type TransactionUpdateWithoutCard_detailInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    transaction_type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transaction_status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    transfer_detail?: TransferDetailUpdateOneWithoutTransactionsNestedInput
    booking?: BookingUpdateOneWithoutTransactionNestedInput
    booking_event?: BookingEventUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutCard_detailInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    transfer_details_id?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transaction_status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUncheckedUpdateOneWithoutTransactionNestedInput
    booking_event?: BookingEventUncheckedUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutCard_detailInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    transfer_details_id?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    transaction_status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventImageCreateManyEventInput = {
    id?: string
    name: string
    image?: string | null
    description?: string | null
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type BookingEventCreateManyEventInput = {
    id?: string
    number_of_people: number
    booking_id: string
    transaction_id: string
    created?: Date | string
    updated?: Date | string
    is_excluded?: boolean
  }

  export type EventImageUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EventImageUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EventImageUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BookingEventUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    number_of_people?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
    booking?: BookingUpdateOneRequiredWithoutBooking_eventsNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutBooking_eventNestedInput
  }

  export type BookingEventUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    number_of_people?: IntFieldUpdateOperationsInput | number
    booking_id?: StringFieldUpdateOperationsInput | string
    transaction_id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BookingEventUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    number_of_people?: IntFieldUpdateOperationsInput | number
    booking_id?: StringFieldUpdateOperationsInput | string
    transaction_id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    is_excluded?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}